# 1. 入门案例

提取文章中的所有英文单词

```java
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Test1 {
    public static void main(String[] args) {
        String content="由于在开发Oak语言时，尚且不存在运行字节码的硬件平台，所以为了在开发时可以对这种语言进行实验研究，他们就在已有的硬件和软件平台基础上，按照自己所指定的规范，用软件建设了一个运行平台，整个系统除了比C++更加简单之外，没有什么大的区别。1992年的夏天，当Oak语言开发成功后，研究者们向硬件生产商进行演示了Green操作系统、Oak的程序设计语言、类库和其硬件，以说服他们使用Oak语言生产硬件芯片，但是，硬件生产商并未对此产生极大的热情。因为他们认为，在所有人对Oak语言还一无所知的情况下，就生产硬件产品的风险实在太大了，所以Oak语言也就因为缺乏硬件的支持而无法进入市场，从而被搁置了下来。";
        //1. 先创建一个Pattern 对象， 模式对象, 可以理解成就是一个正则表达式对象
        Pattern pattern = Pattern.compile("[a-zA-Z]+");
        //创建一个匹配器对象
        //理解：就是matcher匹配器按照 pattern 到content文本中去匹配
        //找到就返回true
        Matcher matcher = pattern.matcher(content);
        while (matcher.find()){
            System.out.println("找到"+matcher.group(0));
        }
    }
}

```

# 2. 函数分析

## 2.1 matcher.find()

1. 调用find以后，将子字符串的开始的索引记录到grops[0]
2. 将该子字符串的结束的索引+1 的值记录到groups[1]
3. 记录1 组()匹配到的字符串的开始到groups[2]  结束的索引+1 的值记录到groups[3] 
4. 记录2 组()匹配到的字符串的开始到groups[4]  结束的索引+1 的值记录到groups[5] 
5. 如果有更多的分组.....
6. 同时记录oldLast 的值为子字符串的结束的索引+1，即下次执行find 时，就从oldLast 开始匹配

## 2.2 matcher.group()

1. group(0) 表示匹配到的子字符串
2. group(1) 表示匹配到的子字符串的第一组字串
3. group(2) 表示匹配到的子字符串的第2 组字串

```java
    public String group(int group) {
        if (first < 0)
            throw new IllegalStateException("No match found");
        if (group < 0 || group > groupCount())
            throw new IndexOutOfBoundsException("No group " + group);
        if ((groups[group*2] == -1) || (groups[group*2+1] == -1))
            return null;
        return getSubSequence(groups[group * 2], groups[group * 2 + 1]).toString();
    }

```

# 3. 正则表达式语法

## 3.1 转义

转义号： \\\

需要用到转义的字符: 

> ( )  
>
> / \
>
> $ ^
>
> [] ^ . -
>
> ？ + * {}

## 3.2 元字符-字符匹配符

| 符号 | 含义                                                         | 实例           | 说明                                                 |
| ---- | ------------------------------------------------------------ | -------------- | ---------------------------------------------------- |
| []   | 匹配方括号内的任意字符                                       | [efgh]         | e,f,g,h中的任意一个字符                              |
| [^]  | 匹配除了方括号里的任意字符                                   | [^abc]         | 除a,b,c之外的任意一个字符，包括数字和特殊字符        |
| -    | 连字符                                                       | A-Z            | 任意单个大写字母                                     |
| .    | 匹配除\n以外的任何一个字符                                   | a..b           | 以a开头，b结尾，中间包括2个任意字符的长度为4的字符串 |
| \\\d | 匹配单个数字字符                                             | \\\d{3}(\\\d)? | 包含3或4个数字的字符串                               |
| \\\D | 匹配单个非数字字符，相当于[ ^0-9]                            | \\\D(\\\d)*    | 以单个非数字字符开头，后接任意个数数字字符串         |
| \\\w | 匹配单个数字，大小写字母,下划线字符,相当于[0-9a-zA-Z_]       | \\\d{3}\\\w{4} | 以3个数字字符开头的长度为7的数字字母字符串           |
| \\\W | 匹配单个非数字，大小写字母字符,下划线相当于[0-9a-zA-Z_]      | \\\\W+\\\d{2}  | 以至少1个非数字字母宇符开头，2个数字字符结尾的字符串 |
| \\\s | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。 |                |                                                      |
| \\\S | 匹配任何非空白字符。等价于 [ ^\\f\n\r\t\v]。                 |                |                                                      |

[.]表示匹配.本身

默认情况下是区分大小写的，如何不区分大小写呢

```
(?i)abc 表示abc都不区分大小写
a(?i)bc 表示bc不区分大小写
a((?i)b)c 只有b不区分大小写
或者
Pattern pattern = Pattern.compile(regExp,Pattern.CASE_INSENSITIVE);
```

## 3.3 选择匹配符

| 符号 | 含义                       | 实例   | 说明     |
| ---- | -------------------------- | ------ | -------- |
| \|   | 四配 \| 之前或之后的表达式 | ab\|cd | ab或者cd |

## 3.4 限定符

用于指定其前面的字符和组合项连续出现多少次

![image-20210706222839076](https://gitee.com/aik-aid/picture/raw/master/image-20210706222839076.png)

java匹配是贪婪匹配，即尽可能匹配多的

非贪婪匹配是在限定符后面加一个?

## 3.5 定位符

![image-20210706224130925](https://gitee.com/aik-aid/picture/raw/master/image-20210706224130925.png)

## 3.6 分组

![image-20210706225607460](https://gitee.com/aik-aid/picture/raw/master/image-20210706225607460.png)

![image-20210706230529803](https://gitee.com/aik-aid/picture/raw/master/image-20210706230529803.png)

| 符号 | 描述            |
| ---- | --------------- |
| ?=   | 正先行断言-存在 |
| ?!   | 负先行断言-排除 |
| ?<=  | 正后发断言-存在 |
| ?<!  | 负后发断言-排除 |

# 4. 实战

## 4.1 汉字

```java
^[\u0391-\uffe5]+$
```

## 4.2 邮政编码

```
^[1-9]\\d{5}$
```

## 4.3 QQ号码

```
^[1-9]\\d{4,9}$
```

## 4.4 手机号码

```
^1[3|4|5]\\d{9}$
```

## 4.5 URL



# 5. 常用类

![image-20210707003111276](https://gitee.com/aik-aid/picture/raw/master/image-20210707003111276.png)

用于查看整体匹配

![image-20210707003619247](https://gitee.com/aik-aid/picture/raw/master/image-20210707003619247.png)

![image-20210707004001355](https://gitee.com/aik-aid/picture/raw/master/image-20210707004001355.png)

![image-20210707004311873](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/image-20210707004311873.png)

# 6. 反向引用

1. **分组**
   我们可以用圆括号组成一个比较复杂的匹配模式， 那么个圆括号的部分我们可
   以看作是一个子表达式/一个分组。
2. **捕获**
   把正则表达式中子表达式/分组匹配的内容，保存到内存中以数字编号或显式命名
   分的组里，方便后面引用，从左向右， 以分组的左括号为标志，第一个出现的分组
   分的组号为1,第二个为2,以此类推。组0代表的是整个正则式分
3. **反向引用：**
   圆括号的内容被捕获后，可以在这个括号后被使用，从而写出一一个比较实用的匹
   配模式，这个我们称为反向引用，这种引用既可以是在正则表达式内部，也可以是
   在正则表达式外部，内部反向引用 \\\分组号，外部反向引用$分组号

![image-20210707005448940](https://gitee.com/aik-aid/picture/raw/master/image-20210707005448940.png)

![image-20210707103543563](https://gitee.com/aik-aid/picture/raw/master/image-20210707103543563.png)

# 7. String使用正则

1. 

```
public boolean matches(String regex) {
    return Pattern.matches(regex, this);
}
```

2. ```
   public String[] split(String regex, int limit)
   ```

3. ```
   public String replaceAll(String regex, String replacement) {
       return Pattern.compile(regex).matcher(this).replaceAll(replacement);
   }
   ```

