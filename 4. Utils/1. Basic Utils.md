# 1. VIM

> Learing From
>
> - vimtutor
> - https://missing.csail.mit.edu/2020/editors/

移动

- Basic movement: hjkl (left, down, up, right)
- Words: w (next word), b (beginning of word), e (end of word)
- Lines: 0 (beginning of line), ^ (first non-blank character), $ (end of line)
- Scroll: Ctrl-u (up), Ctrl-d (down)
- File: gg (beginning of file), G (end of file)
- Misc: % (corresponding item)
- Search: /{regex}, n / N for navigating matches

修改

- `i` enter Insert mode
- `o` / `O` insert line below / above
- `[n]d{motion}` delete {motion}
- `[n]c{motion}` change {motion}
- `x` delete character (equal do `dl`)
- `s` substitute character (equal to `xi`)
- `y` to copy / “yank”
- `p` to paste
- `u` to undo, `<C-r>` to redo

修饰语：

- `ci(` 改变当前括号内的内容
- `ci[` 改变当前方括号内的内容
- `da'` 删除一个单引号字符串， 包括周围的单引号

末行模式可用的命令

| 命令          | 作用                                 |
| ------------- | ------------------------------------ |
| :w [fileName] | 保存                                 |
| :q            | 退出                                 |
| :set nu       | 显示行号                             |
| :set nonu     | 不显示行号<br />                     |
| set ic        | 搜索时忽略大小写                     |
| set hls       | 高亮所有匹配的短语                   |
| :命令         | 执行该命令<br />                     |
| :![命令]      | 执行外部命令                         |
| :s/one/two    | 将当前光标所在行的第一个one替换成two |
| :s/one/two/g  | 将当前光标所在行的所有one替换成two   |
| /%s/one/two/g | 将全文中的所有one替换为two           |
| ?字符串       | 在文本中从下至上搜索该字符串         |
| /字符串       | 在文本中从上至下搜索该字符串         |

# 2. Regex

> Learing From
>
> - https://github.com/ziishaned/learn-regex/blob/master/README.md
> - https://missing.csail.mit.edu/2020/data-wrangling/
> - https://regexone.com/lesson/introduction_abcs

## 2.1 元字符

| 元字符 | 描述                                                         |
| ------ | ------------------------------------------------------------ |
| .      | 匹配任意单个字符除了换行符。                                 |
| [ ]    | 匹配方括号内的任意字符。                                     |
| [^ ]   | 匹配除了方括号里的任意字符                                   |
| *      | 匹配 >=0个 重复的在*号之前的字符。                           |
| +      | 匹配 >=1个 重复的+号前的字符。                               |
| ?      | 标记?之前的字符为可选                                        |
| {n,m}  | 匹配num个大括号之前的字符或字符集 (n <= num <= m).           |
| (xyz)  | 字符集，匹配与 xyz 完全相等的字符串.                         |
| \|     | 或运算符，匹配符号前或后的字符.                              |
| \      | 转义字符,用于匹配一些保留的字符 `[ ] ( ) { } . * + ? ^ $ \ |` |
| ^      | 从开始行开始匹配.                                            |
| $      | 从末端开始匹配.                                              |

[]号中的特殊字符：

- 如.就匹配.，而不在作为元字符

如何不区分大小写：

```shell
(?i)abc 表示abc都不区分大小写
a(?i)bc 表示bc不区分大小写
a((?i)b)c 只有b不区分大小写
```

贪婪

- java匹配是贪婪匹配，即尽可能匹配多的，非贪婪匹配是在限定符(`*`,`+`,`?`)后面加一个?

## 2.2 简写字符集

| .    | 除换行符外的所有字符                               |
| ---- | -------------------------------------------------- |
| \w   | 匹配所有字母数字，等同于 `[a-zA-Z0-9_]`            |
| \W   | 匹配所有非字母数字，即符号，等同于： `[^\w]`       |
| \d   | 匹配数字： `[0-9]`                                 |
| \D   | 匹配非数字： `[^\d]`                               |
| \s   | 匹配所有空格字符，等同于： `[\t\n\f\r\p{Z}]`       |
| \S   | 匹配所有非空格字符： `[^\s]`                       |
| \f   | 匹配一个换页符                                     |
| \n   | 匹配一个换行符                                     |
| \r   | 匹配一个回车符                                     |
| \t   | 匹配一个制表符                                     |
| \v   | 匹配一个垂直制表符                                 |
| \p   | 匹配 CR/LF（等同于 `\r\n`），用来匹配 DOS 行终止符 |

## 2.3 断言

先行断言和后发断言（合称 lookaround）都属于**非捕获组**（用于匹配模式，但不包括在匹配列表中）

| 符号 | 描述            |
| ---- | --------------- |
| ?=   | 正先行断言-存在 |
| ?!   | 负先行断言-排除 |
| ?<=  | 正后发断言-存在 |
| ?<!  | 负后发断言-排除 |

## 2.4 标志

| 标志 | 描述                                                  |
| ---- | ----------------------------------------------------- |
| i    | 忽略大小写。                                          |
| g    | 全局搜索。                                            |
| m    | 多行修饰符：锚点元字符 `^` `$` 工作范围在每行的起始。 |

格式为：/regular_expression/<标志>

## 2.5 分组

捕获

- 把正则表达式中子表达式/分组匹配的内容，保存到内存中以数字编号或显式命名分的组里，方便后面引用
- 从左向右， 以分组的左括号为标志，第一个出现的分组分的组号为1,第二个为2,以此类推。组0代表的是整个正则式分

反向引用

- 内部反向引用 \\\分组号，外部反向引用$分组号

![image-20210707005448940](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/image-20210707005448940.png)

# 3. Command

## 3.1 Data Wrangling

- sed：以正则的形式修改文本内容
- awk：`awk` 程序接受一个模式串（可选），以及一个代码块，指定当模式匹配时应该做何种操作。

> 在代码块中，`$0` 表示整行的内容，`$1` 到 `$n` 为一行中的 n 个区域
>
> 区域的分割基于 `awk` 的域分隔符（默认是空格，可以通过`-F`来修改
>

- wc：
- sort：
- uniq：
- grep | rg
- bc：
- xargs：

## 3.2 Job Control

信号

| 信号名            | 作用                                                         |
| ----------------- | ------------------------------------------------------------ |
| KILL              | 杀死进程(强制关闭)。**本信号不能被阻塞、处理和忽略。**       |
| TERM/INT          | 立即关闭整个服务，INT有快捷键Ctrl + C                        |
| HUP               | 终止进程，可以被nohup程序忽略掉,终端关闭时会发出这个信号，许多守护进程将这个信号解释为重新加载配置文件 |
| QUIT              | 在推出前会生成一个core dump，快捷键Ctrl + \                  |
| SIGCONT           | 继续一个stop的进程                                           |
| SIGSTP (Ctrl + Z) | stop进程。**本信号不能被阻塞、处理或忽略。**                 |

- bg: 将一个sto进程在后台运行
- fg: 将一个进程在前台运行
- &: 后缀为& 表示进程后台运行
- nohup: 让程序忽略SIGHUP信号运行
- jobs: 查看当前shell中未完成的任务

## 3.3 Top

动态监视进程活动与系统负载等信息

**第1行是任务队列信息，其参数如下：**

- 系统负载，即任务队列的平均长度。 三个数值分别为 1分钟、5分钟、15分钟前到现在的平均值。
- load average: 如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了。

| 当前时间 | 系统运行时间 | 当前登录用户数 | 系统负载                       |
| -------- | ------------ | -------------- | ------------------------------ |
| 05:43:27 | up 4:52      | 2 users        | load average: 0.58, 0.41, 0.30 |

第二行是任务信息，也就是进程信息

| total    | running  | sleeping | stopped  | zombie   |
| -------- | -------- | -------- | -------- | -------- |
| 进程总数 | 运行进程 | 睡眠进程 | 停止进程 | 僵死进程 |

第三行是CPU信息

| us                  | sy                  | ni   | id            | wa                    | hi           | si           | st   |
| ------------------- | ------------------- | ---- | ------------- | --------------------- | ------------ | ------------ | ---- |
| 用户空间占CPU百分比 | 内核空间占CPU百分比 |      | 空闲CPU百分比 | 等待IO的CPU时间百分比 | 硬中断百分比 | 软中断百分比 |      |

第四行为内存相关信息

| total        | used       | free       | buffers            |
| ------------ | ---------- | ---------- | ------------------ |
| 物理内存总量 | 使用的数量 | 空闲的总量 | 用于内核缓存的总量 |

第五行为swap相关信息

| total      | free             | used             | avail Mem                          |
| ---------- | ---------------- | ---------------- | ---------------------------------- |
| 交换区总量 | 使用的交换区总量 | 空闲的交换区总量 | 可用于进程下一次分配的物理内存数量 |

计算可用内存数有一个近似的公式： 
第四行的free + 第四行的buffers + 第五行的cached

| PID  | USER | PR     | NI     | VIRT                   | RES                                | SHR          | S        | %CPU | %MEM | TIME+COMMAND  |
| ---- | ---- | ------ | ------ | ---------------------- | ---------------------------------- | ------------ | -------- | ---- | ---- | ------------- |
|      |      | 优先级 | nice值 | 进程使用的虚拟内存总量 | 进程使用的、未被换出的物理内存大小 | 共享内存大小 | 进程状态 |      |      | 命令名/命令行 |

- 默认按照CPU进行排序
- 按M，根据内存排序
- 按N，根据PID排序
- 按z，突出显示活动进程
- 按i，显示空闲进程
- 按u <name>,查看特定用户的进程
- 按d <频率>，更改top刷新频率
- 按k，可以杀死进程

# 4. Shell

'' 和 ""

```shell
foo=bar
# 输出：foo=bar
echo "foo=$foo"
# 输出：foo=$foo
echo 'foo=$foo'
```

$符号

- `$0` - 脚本名
- `$1` 到 `$9` - 脚本的参数。 `$1` 是第一个参数，依此类推。
- `$@` - 所有参数
- `$#` - 参数个数
- `$?` - 前一个命令的返回值
- `$$` - 当前脚本的PID
- `!!` - 完整的上一条命令，包括参数。常见应用：当你因为权限不足执行命令失败时，可以使用 `sudo !!`再尝试一次。
- `$_` - 上一条命令的最后一个参数。如果你正在使用的是交互式 shell，你可以通过按下 `Esc` 之后键入 . 来获取这个值。

替换符

- 命令替换：$(ls)，会首先执行ls，然后将结果替换掉\$(ls) 
- <(cmd), 会执行 `CMD` 并将结果输出到一个临时文件中

| /etc        | 主要存放配置文件                                     |
| ----------- | ---------------------------------------------------- |
| /var        | 主要放日志文件                                       |
| /tmp        | 主要存放临时文件                                     |
| /opt        | 主要存放第三方软件                                   |
| /dev        | 用于存放设备文件,如鼠标，键盘等                      |
| /lost+found | 文件系统发生错误时，将一些丢失的文件片段放在这里     |
|             |                                                      |
| /root       | 超级用户家目录                                       |
| /home       | 用户家目录                                           |
| /boot       | 开机所需要的文件                                     |
| /lib        | 系统运行相关的库函数                                 |
| /sbin       | 只有root用户才能使用的二进制可执行文件               |
| /bin        | 存放二进制可执行文件，常用命令一般在此               |
| /proc       | 虚拟文件系统，例如系统内核，进程，外部设备，网络状态 |
| /usr        | unix system resources,存放系统资源                   |
| /usr/local  | 用户自行安装的软件                                   |

# 4. Git

> Learing From
>
> - https://missing-semester-cn.github.io/2020/version-control/

## 4.1 Git原理

### 4.1.1 Git状态

git的四个工作区域：工作区，暂存区，版本库，远程仓库

- 工作区是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。
- 暂存区是一个文件，保存了下次将要提交的文件列表信息，一般在 Git 仓库目录中。 按照 Git 的术语叫做“索引”。
- Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，复制的就是这里的数据。

文件的分类：未追踪文件(Untracked) 和 已追踪文件(tracked)

- 将未追踪文件纳入到追踪中使用`git add [file]...`
- 已追踪文件(Git文件)有三种状态：Unmodified，Modified，Staged

### 4.1.2 Git对象

`Blob对象`：保存一个文件的所有内容

```java
// 文件就是一组数据 
type blob = array<byte>;
```

`Tree对象`: 是一个表示blobs和其他tree的一种目录

```java
// 一个包含文件和目录的目录
type tree = map<string, tree | blob>;
```

`Commit对象`: 

```c
// 每个提交都包含一个父辈，元数据和顶层树
type commit = struct {
    parent: array<commit>
    author: string
    message: string
    snapshot: tree
}
```

`检验和`：Hash值, 使用`SHA-1哈希算法`; 这个hash值可以指向blob，commit，tree

---

暂存操作

- 使用`SHA-1哈希算法`为每一个文件计算校验和
- 然后在Git仓库中使用`blob`对象来保存文件

Commit操作

- 计算每一个子目录的检验和, 然后在 Git 仓库中这些校验和保存为`树对象`，快照则是被追踪的最顶层的树
- Git 便会创建一个提交对象, 
  - 包含了作者的姓名和邮箱、提交时输入的信息
  - 指向树对象（项目根目录）的指针
  - 指向它的父对象的指针

```c
// 每个提交都包含一个父辈，元数据和顶层树
type commit = struct {
    parent: array<commit>
    author: string
    message: string
    snapshot: tree
}
// Git 中的对象可以是 blob、树或提交：
type object = blob | tree | commit;
// Git 在储存数据时，所有的对象都会基于它们的 SHA-1 哈希 进行寻址。
objects = map<string, object>

def store(object):
    id = sha1(object)
    objects[id] = object

def load(id):
    return objects[id]
```

<img src="http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/commit-and-tree.png" alt="首次提交对象及其树结构。" style="zoom:50%;" />

![提交对象及其父对象。](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/commits-and-parents.png)

## 4.2 基础命令

1. 获取Git仓库

```shell
git init
# 命令会自动将其添加为远程仓库并默认以 “origin” 为简写
# 自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支
git clone <url>
```

2. 查看文件状态

```shell
git status
# 输出中有两栏，左栏指明了暂存区的状态，右栏指明了工作区的状态。
git status -s
```

3. `追踪文件` or `暂存已修改文件` or 用于合并时把有冲突的文件标记为已解决状态（命令执行后 文件状态为staged）。

```shell
# git add命令 准确含义是：将内容添加到下一次提交中
git add <file or directory>
```

4. 提交暂存区的数据

```shell
git commit
# Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤：
git commit -a
```

5. 移除文件

```shell
# 1. git rm命令的本质就是rm 和 git add
# 2. 如果只是简单地从工作目录中手工删除文件，运行 git status 时就会在 Changes not staged for commit 的提示。
# 3. 将文件从暂存区和工作区中删除：
git rm <file>
git rm -f <file>
# 4. 如果想把文件从暂存区域移除，但仍然希望保留在当前工作目录中，换句话说，仅是从跟踪清单中删除，使用 --cached 选项即可
git rm --cached <file>
```

6. 撤销操作

```shell
# 编辑提交的内容或信息
git commit --amend
# 1. 将已经staged的数据撤销为modified状态
git restore --staged <file>...
# 2. 撤销修改，将它还原成上次提交时的样子(或者刚克隆完的样子，或者刚把它放入工作目录时的样子)
git restore <file>...
```

7. 查看日志

```shell
git log
# 显示每次提交所引入的差异（按 补丁 的格式输出）
git log -p/ -patch
# 限制日志的数量
git log -n
#每个日志只显示一行
git log --pretty=oneline 
```

8. 重命名

```shell
git mv file_from file_to
```

9. 查看已暂存和未暂存的修改

```shell
# 查看未暂存的修改, 此命令比较的是工作目录中当前文件和暂存区域快照之间的差异。
git diff
# 查看已暂存的修改, 这条命令将比对已暂存文件与最后一次提交的文件差异
git diff --staged
```

## 4.3 忽略文件

忽略文件，使用.gitignore文件

- 星号（*）匹配零个或多个任意字符
- 问号（?）只匹配一个任意字符
- [abc] 匹配任何一个列在方括号中的字符
- 使用两个星号（**）表示匹配任意中间目录，比如 a/**/z 可以匹配 a/z 、 a/b/z 或 a/b/c/z 等。
- 匹配模式可以以（`/`）开头防止递归; 匹配模式可以以（`/`）结尾指定目录。

```shell
# 忽略所有的 .a 文件
*.a
# 但跟踪所有的 lib.a，即便你在前面忽略了 .a 文件
!lib.a
# 只忽略当前目录下的 TODO 文件，而不忽略 subdir/TODO
/TODO
# 忽略任何目录下名为 build 的文件夹
build/
# 忽略 doc/notes.txt，但不忽略 doc/server/arch.txt
doc/*.txt
# 忽略 doc/ 目录及其所有子目录下的 .pdf 文件
doc/**/*.pdf
```

## 4.4 远程操作

1. 显示远程仓库

```shell
git remote
# 显示远程仓库的简称 和 对应的url
git remote -v
```

2. 添加远程仓库

```shell
git remote add <shortname> <url>
```

3. 从远程仓库获取资源

```shell
# 只会将数据下载到你的本地仓库——它并不会自动合并或修改你当前的工作区的文件
# 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。
git fetch <remote>
# git fetch + git merge
# merge的是远程跟踪分支
git pull <remote>
```

4. 推送数据

```shell
# 只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。
git push <remote> <branch>
git push <remote> <localBranch>:<remoteBranch>
```

5. 重命名 和 移除

```shell
git remote rename <oldname> <newname>
git remote rm <name>
```

6. 查看某个远程仓库信息

```shell
git remote show <remote>
```

## 4.5 Tag操作

1. 列出标签

```shell
git tag 
git tag -l
# 通配符查询
git tag -l "v1.8.5*"
```

2. 创建轻量级标签（lightweight）

```shell
# 轻量标签很像一个不会改变的分支——它只是某个特定提交的引用。
git tag <tagName>
```

3. 创建附注标签（annotated）

```shell
# 其中包含打标签者的名字、电子邮件地址、日期时间， 此外还有一个标签信息
git tag -a <tagName> -m <message>
# 查看标签信息
git show <tagName>
```

4. 查看标签

```shell
git show <tagName>
```

5. 后期打标签

```shell
git tag -a <tagName> <checkSum>
```

6. 推送标签

```shell
# 默认情况下，git push 命令并不会传送标签到远程仓库服务器上, 需要显示push
git push <remote> <tagname>
# 批量推送,把所有不在远程仓库服务器上的标签全部传送到那里。
git push origin --tags
```

7. 删除标签

```shell
# 删除本地库的tag，没有删除远程库的
git tag -d <tagname>
# 删除远程库的tag
git push <remote> --delete <tagname>
```

## 4.6 分支操作

Git 的分支，其实本质上仅仅是指向提交对象的可变指针( 包含所指对象校验和的文件 )

1. 创建分支, 会在当前所在的提交对象上创建一个指针

```shell
git branch <branchName>
```

2. 切换分支，将Head指针指向其他的提交对象,将工作目录恢复成新的分支所指向的快照内容。 

```shell
git checkout <branchName>
# 新建并切换，等价于 git branch <> + gitr checkout <>
git checkout -b <branchName>
```

3. 查看分支

```shell
git brance
# 查看每一个分支的最后一次提交
git brance -v
# 查看哪些分支已经合并到当前分支，之后可以删除掉这些分支
git brance --merged
# 查看各个分支当前所指的对象
git log --oneline --decorate
```

4. 合并分支, 所在分支就是主分支,

```shell
# 1. Git 会使用两个分支的末端所指的快照以及这两个分支的公共祖先（C2），做一个简单的三方合并。
# 2. 如果有冲突，Git会停下来，等待你去解决冲突，可以使用git status来查看冲突文件，解决后使用git add标记为已解决
git merge <branchName>
```

5. 删除分支

```shell
git branch -d <branchName>
```

6. 远程分支，git fetch就是用来移动远程分支的

```shell
# 显示远程引用列表, 以<remote>/<branch>的形式命名
git ls -remote <remote>
git remote show <remote>
# 删除远程分支
git push <remote> --delete <remoteBranch>
# 创建远程跟踪分支
git checkout -b <branch> <remote>/<branch>
```

7. 跟踪分支

```shell
#  如果在一个跟踪分支上输入 git pull，Git 能自动地识别去哪个服务器上抓取、合并到哪个分支。
# 当克隆一个仓库时，它通常会自动地创建一个跟踪 origin/master 的 master 分支
# 自己创建远程跟踪分支
git checkout -b <branch> <remote>/<branch>
```

8. 变基：提交到某一分支上的所有修改都移至另一分支上, 也就是以另一个分支为基地

- 适用场景：一般我们这样做的目的是为了确保在向远程分支推送时能保持提交历史的整洁
- 不适合场景：**如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基。**

```shell
# 1. 原理是首先找到这两个分支的最近共同祖先
# 2. 然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件
# 3.  然后将当前分支指向目标基底， 后以此将之前另存为临时文件的修改依序应用
git rebase <baseBranch>
git rebase <basebranch> <topicbranch> 
# 取出 client 分支，找出它从 server 分支分歧之后的补丁， 然后把这些补丁在 master 分支上重放一遍，让 client 看起来像直接基于 master 修改一样
git rebase --onto master server client
```

![image-20220322152056563](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/image-20220322152056563.png)

# 5. tmux

概念：

- session：会话 / 任务
- windows：当前呈现在我们面前的这一个工作区域就是一个窗口
- pane: 窗口可以被不断切割，切割成一个个小块，这一个个小块我们叫做窗格

Session操作：

- 新建：tmux new -s  <session-name> 
- 离开：**ctrl + B d** 
- 
