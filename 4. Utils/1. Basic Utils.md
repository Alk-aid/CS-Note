# 1. VIM

> Learing From
>
> - vimtutor
> - https://missing.csail.mit.edu/2020/editors/

移动

- Basic movement: hjkl (left, down, up, right)
- Words: w (next word), b (beginning of word), e (end of word)
- Lines: 0 (beginning of line), ^ (first non-blank character), $ (end of line)
- Scroll: Ctrl-u (up), Ctrl-d (down)
- File: gg (beginning of file), G (end of file)
- Misc: % (corresponding item)
- Search: /{regex}, n / N for navigating matches

修改

- `i` enter Insert mode
- `o` / `O` insert line below / above
- `[n]d{motion}` delete {motion}
- `[n]c{motion}` change {motion}
- `x` delete character (equal do `dl`)
- `s` substitute character (equal to `xi`)
- `y` to copy / “yank”
- `p` to paste
- `u` to undo, `<C-r>` to redo

修饰语：

- `ci(` 改变当前括号内的内容
- `ci[` 改变当前方括号内的内容
- `da'` 删除一个单引号字符串， 包括周围的单引号

末行模式可用的命令

| 命令          | 作用                                 |
| ------------- | ------------------------------------ |
| :w [fileName] | 保存                                 |
| :q            | 退出                                 |
| :set nu       | 显示行号                             |
| :set nonu     | 不显示行号<br />                     |
| set ic        | 搜索时忽略大小写                     |
| set hls       | 高亮所有匹配的短语                   |
| :命令         | 执行该命令<br />                     |
| :![命令]      | 执行外部命令                         |
| :s/one/two    | 将当前光标所在行的第一个one替换成two |
| :s/one/two/g  | 将当前光标所在行的所有one替换成two   |
| /%s/one/two/g | 将全文中的所有one替换为two           |
| ?字符串       | 在文本中从下至上搜索该字符串         |
| /字符串       | 在文本中从上至下搜索该字符串         |

# 2. Regex

> Learing From
>
> - https://github.com/ziishaned/learn-regex/blob/master/README.md
> - https://missing.csail.mit.edu/2020/data-wrangling/
> - https://regexone.com/lesson/introduction_abcs

## 2.1 元字符

| 元字符 | 描述                                                         |
| ------ | ------------------------------------------------------------ |
| .      | 匹配任意单个字符除了换行符。                                 |
| [ ]    | 匹配方括号内的任意字符。                                     |
| [^ ]   | 匹配除了方括号里的任意字符                                   |
| *      | 匹配 >=0个 重复的在*号之前的字符。                           |
| +      | 匹配 >=1个 重复的+号前的字符。                               |
| ?      | 标记?之前的字符为可选                                        |
| {n,m}  | 匹配num个大括号之前的字符或字符集 (n <= num <= m).           |
| (xyz)  | 字符集，匹配与 xyz 完全相等的字符串.                         |
| \|     | 或运算符，匹配符号前或后的字符.                              |
| \      | 转义字符,用于匹配一些保留的字符 `[ ] ( ) { } . * + ? ^ $ \ |` |
| ^      | 从开始行开始匹配.                                            |
| $      | 从末端开始匹配.                                              |

[]号中的特殊字符：

- 如.就匹配.，而不在作为元字符

如何不区分大小写：

```shell
(?i)abc 表示abc都不区分大小写
a(?i)bc 表示bc不区分大小写
a((?i)b)c 只有b不区分大小写
```

贪婪

- java匹配是贪婪匹配，即尽可能匹配多的，非贪婪匹配是在限定符(`*`,`+`,`?`)后面加一个?

## 2.2 简写字符集

| .    | 除换行符外的所有字符                               |
| ---- | -------------------------------------------------- |
| \w   | 匹配所有字母数字，等同于 `[a-zA-Z0-9_]`            |
| \W   | 匹配所有非字母数字，即符号，等同于： `[^\w]`       |
| \d   | 匹配数字： `[0-9]`                                 |
| \D   | 匹配非数字： `[^\d]`                               |
| \s   | 匹配所有空格字符，等同于： `[\t\n\f\r\p{Z}]`       |
| \S   | 匹配所有非空格字符： `[^\s]`                       |
| \f   | 匹配一个换页符                                     |
| \n   | 匹配一个换行符                                     |
| \r   | 匹配一个回车符                                     |
| \t   | 匹配一个制表符                                     |
| \v   | 匹配一个垂直制表符                                 |
| \p   | 匹配 CR/LF（等同于 `\r\n`），用来匹配 DOS 行终止符 |

## 2.3 断言

先行断言和后发断言（合称 lookaround）都属于**非捕获组**（用于匹配模式，但不包括在匹配列表中）

| 符号 | 描述            |
| ---- | --------------- |
| ?=   | 正先行断言-存在 |
| ?!   | 负先行断言-排除 |
| ?<=  | 正后发断言-存在 |
| ?<!  | 负后发断言-排除 |

## 2.4 标志

| 标志 | 描述                                                  |
| ---- | ----------------------------------------------------- |
| i    | 忽略大小写。                                          |
| g    | 全局搜索。                                            |
| m    | 多行修饰符：锚点元字符 `^` `$` 工作范围在每行的起始。 |

格式为：/regular_expression/<标志>

## 2.5 分组

捕获

- 把正则表达式中子表达式/分组匹配的内容，保存到内存中以数字编号或显式命名分的组里，方便后面引用
- 从左向右， 以分组的左括号为标志，第一个出现的分组分的组号为1,第二个为2,以此类推。组0代表的是整个正则式分

反向引用

- 内部反向引用 \\\分组号，外部反向引用$分组号

![image-20210707005448940](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/image-20210707005448940.png)

# 3. Command

## 3.1 Data Wrangling

- sed：以正则的形式修改文本内容
- awk：`awk` 程序接受一个模式串（可选），以及一个代码块，指定当模式匹配时应该做何种操作。

> 在代码块中，`$0` 表示整行的内容，`$1` 到 `$n` 为一行中的 n 个区域
>
> 区域的分割基于 `awk` 的域分隔符（默认是空格，可以通过`-F`来修改
>

- wc：
- sort：
- uniq：
- grep | rg
- bc：
- xargs：

## 3.2 Job Control

信号

| 信号名             | 作用                                                         |
| ------------------ | ------------------------------------------------------------ |
| SIGHUP             | 终止进程，可以被nohup程序忽略掉,终端关闭时会发出这个信号，许多守护进程将这个信号解释为重新加载配置文件 |
| SIGINT (Ctrl + c)  | 中断进程，和SIGTERM几乎一致                                  |
| SIGQUIT(Ctrl + \\) |                                                              |
| SIGKILL            | 杀死进程(强制关闭)。**本信号不能被阻塞、处理和忽略。**       |
| SIGTERM            | 优雅关闭                                                     |
| SIGCONT            | 继续一个stop的进程                                           |
| SIGSTP (Ctrl + Z)  | stop进程。**本信号不能被阻塞、处理或忽略。**                 |

- bg: 将一个sto进程在后台运行
- fg: 将一个进程在前台运行
- &: 后缀为& 表示进程后台运行
- nohup: 让程序忽略SIGHUP信号运行
- jobs: 查看当前shell中未完成的任务

## 3.3 Top

动态监视进程活动与系统负载等信息

**第1行是任务队列信息，其参数如下：**

- 系统负载，即任务队列的平均长度。 三个数值分别为 1分钟、5分钟、15分钟前到现在的平均值。
- load average: 如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了。

| 当前时间 | 系统运行时间 | 当前登录用户数 | 系统负载                       |
| -------- | ------------ | -------------- | ------------------------------ |
| 05:43:27 | up 4:52      | 2 users        | load average: 0.58, 0.41, 0.30 |

第二行是任务信息，也就是进程信息

| total    | running  | sleeping | stopped  | zombie   |
| -------- | -------- | -------- | -------- | -------- |
| 进程总数 | 运行进程 | 睡眠进程 | 停止进程 | 僵死进程 |

第三行是CPU信息

| us                  | sy                  | ni   | id            | wa                    | hi           | si           | st   |
| ------------------- | ------------------- | ---- | ------------- | --------------------- | ------------ | ------------ | ---- |
| 用户空间占CPU百分比 | 内核空间占CPU百分比 |      | 空闲CPU百分比 | 等待IO的CPU时间百分比 | 硬中断百分比 | 软中断百分比 |      |

第四行为内存相关信息

| total        | used       | free       | buffers            |
| ------------ | ---------- | ---------- | ------------------ |
| 物理内存总量 | 使用的数量 | 空闲的总量 | 用于内核缓存的总量 |

第五行为swap相关信息

| total      | free             | used             | avail Mem                          |
| ---------- | ---------------- | ---------------- | ---------------------------------- |
| 交换区总量 | 使用的交换区总量 | 空闲的交换区总量 | 可用于进程下一次分配的物理内存数量 |

计算可用内存数有一个近似的公式： 
第四行的free + 第四行的buffers + 第五行的cached

| PID  | USER | PR     | NI     | VIRT                   | RES                                | SHR          | S        | %CPU | %MEM | TIME+COMMAND  |
| ---- | ---- | ------ | ------ | ---------------------- | ---------------------------------- | ------------ | -------- | ---- | ---- | ------------- |
|      |      | 优先级 | nice值 | 进程使用的虚拟内存总量 | 进程使用的、未被换出的物理内存大小 | 共享内存大小 | 进程状态 |      |      | 命令名/命令行 |

- 默认按照CPU进行排序
- 按M，根据内存排序
- 按N，根据PID排序
- 按z，突出显示活动进程
- 按i，显示空闲进程
- 按u <name>,查看特定用户的进程
- 按d <频率>，更改top刷新频率
- 按k，可以杀死进程

# 4. Shell

'' 和 ""

```shell
foo=bar
# 输出：foo=bar
echo "foo=$foo"
# 输出：foo=$foo
echo 'foo=$foo'
```

$符号

- `$0` - 脚本名
- `$1` 到 `$9` - 脚本的参数。 `$1` 是第一个参数，依此类推。
- `$@` - 所有参数
- `$#` - 参数个数
- `$?` - 前一个命令的返回值
- `$$` - 当前脚本的PID
- `!!` - 完整的上一条命令，包括参数。常见应用：当你因为权限不足执行命令失败时，可以使用 `sudo !!`再尝试一次。
- `$_` - 上一条命令的最后一个参数。如果你正在使用的是交互式 shell，你可以通过按下 `Esc` 之后键入 . 来获取这个值。

替换符

- 命令替换：$(ls)，会首先执行ls，然后将结果替换掉\$(ls) 
- <(cmd), 会执行 `CMD` 并将结果输出到一个临时文件中

| /etc        | 主要存放配置文件                                     |
| ----------- | ---------------------------------------------------- |
| /var        | 主要放日志文件                                       |
| /tmp        | 主要存放临时文件                                     |
| /opt        | 主要存放第三方软件                                   |
| /dev        | 用于存放设备文件,如鼠标，键盘等                      |
| /lost+found | 文件系统发生错误时，将一些丢失的文件片段放在这里     |
|             |                                                      |
| /root       | 超级用户家目录                                       |
| /home       | 用户家目录                                           |
| /boot       | 开机所需要的文件                                     |
| /lib        | 系统运行相关的库函数                                 |
| /sbin       | 只有root用户才能使用的二进制可执行文件               |
| /bin        | 存放二进制可执行文件，常用命令一般在此               |
| /proc       | 虚拟文件系统，例如系统内核，进程，外部设备，网络状态 |
| /usr        | unix system resources,存放系统资源                   |
| /usr/local  | 用户自行安装的软件                                   |

# 4. Git

> Learing From
>
> - GitBook

## 4.1 Git状态

git的四个工作区域：工作区，暂存区，版本库，远程仓库

- 工作区是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。
- 暂存区是一个文件，保存了下次将要提交的文件列表信息，一般在 Git 仓库目录中。 按照 Git 的术语叫做“索引”。
- Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，复制的就是这里的数据。

文件的分类：未追踪文件(Untracked) 和 已追踪文件(tracked)

- 将未追踪文件纳入到追踪中使用`git add [file]...`
- 已追踪文件(Git文件)有三种状态：Unmodified，Modified，Staged

## 4.2 基础命令

1. 获取Git仓库

```shell
git init
# 命令会自动将其添加为远程仓库并默认以 “origin” 为简写,自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支
git clone <url>
```

2. 查看文件状态

```shell
git status
# 输出中有两栏，左栏指明了暂存区的状态，右栏指明了工作区的状态。
git status -s
```

3. `追踪文件` or `暂存已修改文件` or 用于合并时把有冲突的文件标记为已解决状态（命令执行后 文件状态为staged）。

# 5. tmux

概念：

- session：会话 / 任务
- windows：当前呈现在我们面前的这一个工作区域就是一个窗口
- pane: 窗口可以被不断切割，切割成一个个小块，这一个个小块我们叫做窗格

Session操作：

- 新建：tmux new -s  <session-name> 
- 离开：**ctrl + B d** 
- 
