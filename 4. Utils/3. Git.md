

# 1. Git状态

git的四个工作区域：工作区，暂存区，版本库，远程仓库

- 工作区是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。
- 暂存区是一个文件，保存了下次将要提交的文件列表信息，一般在 Git 仓库目录中。 按照 Git 的术语叫做“索引”
- Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，复制的就是这里的数据。

文件的分类：未追踪文件(Untracked) 和 已追踪文件(tracked)

- 将未追踪文件纳入到追踪中使用`git add [file]...`
- 已追踪文件(Git文件)有三种状态：Unmodified，modified，staged



![Git 下文件生命周期图。](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/lifecycle.png)

# 2. 基础命令

1. 获取Git仓库

```shell
git init
# 命令会自动将其添加为远程仓库并默认以 “origin” 为简写,自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支
git clone <url>
```

2. 查看文件状态

```shell
git status
# 输出中有两栏，左栏指明了暂存区的状态，右栏指明了工作区的状态。
git status -s
```

3. `追踪文件` or `暂存已修改文件` or 用于合并时把有冲突的文件标记为已解决状态（命令执行后 文件状态为staged）。

```shell
# git add命令 准确含义是：将内容添加到下一次提交中
git add <file or directory>
```

4. 忽略文件，使用.gitignore文件

```git
# 1. 星号（*）匹配零个或多个任意字符
# 2. [abc] 匹配任何一个列在方括号中的字符
# 3. 问号（?）只匹配一个任意字符；
# 4. 匹配模式可以以（`/`）开头防止递归; 匹配模式可以以（`/`）结尾指定目录。
# 5. 使用两个星号（**）表示匹配任意中间目录，比如 a/**/z 可以匹配 a/z 、 a/b/z 或 a/b/c/z 等。
```

```shell
# 忽略所有的 .a 文件
*.a

# 但跟踪所有的 lib.a，即便你在前面忽略了 .a 文件
!lib.a

# 只忽略当前目录下的 TODO 文件，而不忽略 subdir/TODO
/TODO

# 忽略任何目录下名为 build 的文件夹
build/

# 忽略 doc/notes.txt，但不忽略 doc/server/arch.txt
doc/*.txt

# 忽略 doc/ 目录及其所有子目录下的 .pdf 文件
doc/**/*.pdf
```

5. 查看已暂存和未暂存的修改

```shell
# 查看未暂存的修改, 此命令比较的是工作目录中当前文件和暂存区域快照之间的差异。
git diff
# 查看已暂存的修改, 这条命令将比对已暂存文件与最后一次提交的文件差异
git diff --staged
```

6. 提交暂存区的数据

```shell
git commit
# Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤：
git commit -a
```

7. 移除文件

```shell
# 1. 如果只是简单地从工作目录中手工删除文件，运行 git status 时就会在 Changes not staged for commit 的提示。
# git rm命令的本质就是rm 和 git add
# 2. 将文件从暂存区和工作区中删除：
git rm <file>
git rm -f <file>
# 3. 如果想把文件从暂存区域移除，但仍然希望保留在当前工作目录中，换句话说，仅是从跟踪清单中删除，使用 --cached 选项即可
git rm --cached <file>
```

8. 重命名

```shell
git mv file_from file_to
```

9. 查看提交历史

```shell
git log
# 显示每次提交所引入的差异（按 补丁 的格式输出）
git log -p/ -patch
# 限制日志的数量
git log -n
#每个日志只显示一行
git log --pretty=oneline 
```

10. 撤销操作

- 第二次提交代替第一次提交的结果。

```shell
git commit -m 'initial commit'
git add forgotten_file
git commit --amend
```

- 将已经staged的数据撤销为modified状态

```shell
git restore --staged <file>...
```

- 撤销修改，将它还原成上次提交时的样子(或者刚克隆完的样子，或者刚把它放入工作目录时的样子)

```shell 
git restore <file>...
```

11. 远程仓库操作

- 显示远程仓库

```shell
git remote
# 显示远程仓库的简称 和 对应的url
git remote -v
```

- 添加远程仓库

```shell
git remote add <shortname> <url>
```

- 从远程仓库获取资源

```shell
# 只会将数据下载到你的本地仓库——它并不会自动合并或修改你当前的工作区的文件
# 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。
git fetch <remote>
# git fetch + git merge
git pull <remote>
```

- 推送数据

```shell
# 只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。
git push <remote> <branch>
git push <remote> <localBranch>:<remoteBranch>
```

- 查看某个远程仓库信息

```shell
git remote show <remote>
```

- 重命名 和 移除

```shell
git remote rename <oldname> <newname>
git remote rm <name>
```

12. 打标签

- 列出标签

```shell
git tag 
git tag -l
# 通配符查询
git tag -l "v1.8.5*"
```

- 创建轻量级标签（lightweight）

```shell
# 轻量标签很像一个不会改变的分支——它只是某个特定提交的引用。
git tag <tagName>
```

- 创建附注标签（annotated）

```shell
# 其中包含打标签者的名字、电子邮件地址、日期时间， 此外还有一个标签信息
git tag -a <tagName> -m <message>
# 查看标签信息
git show <tagName>
```

- 查看标签

```shell
git show <tagName>
```

- 后期打标签

```shell
git tag -a <tagName> <checkSum>
```

- 推送标签

```shell
# 默认情况下，git push 命令并不会传送标签到远程仓库服务器上, 需要显示push
git push <remote> <tagname>
# 批量推送,把所有不在远程仓库服务器上的标签全部传送到那里。
git push origin --tags
```

- 删除标签

```shell
# 删除本地库的tag，没有删除远程库的
git tag -d <tagname>
# 删除远程库的tag
git push <remote> --delete <tagname>
```

# 3. Git分支

## 3.1 Git如何保存对象

Git保存的是一系列不同时刻的快照。

1. 暂存操作

- 为每一个文件计算校验和，然后会把当前版本的文件快照保存到 Git 仓库中（Git 使用 *blob* 对象来保存它们）
- 将校验和加入到暂存区域等待提交

2. 提交操作

- 计算每一个子目录的校验和，然后在 Git 仓库中这些校验和保存为树对象
- Git创建一个提交对象
  - 包含指向这个树对象的指针。
  - 包含一个指向暂存内容快照的指针
  - 包含了作者的姓名和邮箱、提交时输入的信息
  - 指向它的父对象的指针。

<img src="http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/commit-and-tree.png" alt="首次提交对象及其树结构。" style="zoom:50%;" />

做些修改后再次提交，那么这次产生的提交对象会包含一个指向上次提交对象（父对象）的指针。

![提交对象及其父对象。](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/commits-and-parents.png)

## 3.2 Git分支

Git 的分支，其实本质上仅仅是指向提交对象的可变指针。

1. 创建分支, 会在当前所在的提交对象上创建一个指针

```shell
git branch <branchName>
```

2. 切换分支，将Head指针指向其他的提交对象,将工作目录恢复成新的分支所指向的快照内容。 

```shell
git checkout <branchName>
# 新建并切换，等价于 git branch <> + gitr checkout <>
git checkout -b <branchName>
```

3. 查看分支

```shell
git brance
# 查看每一个分支的最后一次提交
git brance -v
# 查看哪些分支已经合并到当前分支，之后可以删除掉这些分支
git brance --merged
# 查看各个分支当前所指的对象
git log --oneline --decorate
```

4. 合并分支, 所在分支就是主分支

```shell
git merge <branchName>
```

5. 删除分支

```shell
git branch -d <branchName>
```

6. 远程分支

```shell
# 显示远程引用列表, 以<remote>/<branch>的形式命名
git ls -remote <remote>
git remote show <remote>
# 删除远程分支
git push <remote> --delete <remoteBranch>
# 创建远程跟踪分支
git checkout -b <branch> <remote>/<branch>
```

- git fetch的作用

<img src="http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/remote-branches-3.png" alt="`git fetch` 更新你的远程仓库引用。" style="zoom:50%;" />



7. 变基：提交到某一分支上的所有修改都移至另一分支上, 也就是以另一个分支为基地

- 适用场景：一般我们这样做的目的是为了确保在向远程分支推送时能保持提交历史的整洁
- 不适合场景：**如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基。**

```shell
# 1. 原理是首先找到这两个分支的最近共同祖先
# 2. 然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件
# 3.  然后将当前分支指向目标基底， 后以此将之前另存为临时文件的修改依序应用
git rebase <baseBranch>
git rebase <basebranch> <topicbranch> 
# 取出 client 分支，找出它从 server 分支分歧之后的补丁， 然后把这些补丁在 master 分支上重放一遍，让 client 看起来像直接基于 master 修改一样
git rebase --onto master server client
```

![image-20220322152056563](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/image-20220322152056563.png)
