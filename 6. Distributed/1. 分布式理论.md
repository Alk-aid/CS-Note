> 亿级流量网站架构核心技术

# 1. 分布式架构

## 1.1 集中式 & 分布式 

`集中式`：

- `概念`：由一台或者多台计算机组成中心结点；数据存储与控制由这个系统完成，终端只负责数据的input和output
- `优点`：部署简单
- `缺点`：单点故障导致系统不可用；集中式难以扩容

`分布式`：

- `概念`：一个硬件或者软件组件分布在不同的网络计算机上，彼此之间仅仅通过消息传递进行通信和协调的系统
- `特点`：
  - 分布性：
  - 对等性：分布式机器没有主从之分；数据副本保证高可用，服务副本实现负载均衡
  - 并发性：同一个分布式的多个结点可能并发操作共享资源，如数据库或者分布式缓存
  - 缺乏全局时钟：很难定义两个事件的先后顺序

- `问题`:
  - 通信异常：因为网络波动导致通信失败，或者时延高
  - 网络分区：由于网络异常，导致只有部分结点之间能正常通信，而另一些不能；从而形成局部小集群；
  - 三态：成功，失败，超时
  - 节点故障

> TODO: https://segmentfault.com/a/1190000040420527

## 1.2 一致性

`分布式事务`：事务的参与者，服务器位于分布式系统的不同节点上；分布式事务可以看作是由多个分布式操作序列(子事务)组成的

`一致性的分类`

- `强一致性`：这种一致性级别是最符合用户直觉的，它要求系统写入什么，读出来的也会是什么，用户体验好，但实现起来往往对系统的性能影响大
- `弱一致性`：这种一致性级别约束了系统在写入成功后，不承诺立即可以读到写入的值，也不承诺多久之后数据能够达到一致，但会尽可能地保证到某个时间级别（比如秒级别）后，数据能够达到一致状态
- `最终一致性`：最终一致性是弱一致性的一个特例，系统会保证在一定时间内，能够达到一个数据一致的状态。

`最终一致性`的分类

- `因果一致性`：进程A更新数据后通知进程B，那么进程B对该数据的访问一定要是最新的
- `读己之所写`：进程A更新数据后，自己总能访问到最新的
- `会话一致性`：同一个会话的客户端更新后，能读到最新的
- `单调读一致性`：进程读到某个数据后，后续不可能读到比这更旧的值了
- `单调写一致性`：同一个进程的写操作被顺序执行

## 1.3 CAP

`CAP理论`: 分布式系统不可能同时满足一致性(Consistency), 可用性(Availability), 分区容错性(Partition tolerance)

| 选项            | 描述                                                         |
| --------------- | ------------------------------------------------------------ |
| C(Consistence)  | 服务器层面：数据在多个副本之间能够保持一致的特性（强一致性)<br>客户端层面：用户访问分布式系统中的任意节点，得到的数据必须一致(强一致性) |
| A(Availability) | 非故障的节点**在合理的时间内返回合理的响应**（不是错误和超时的响应） |
| P(Partition)    | 不同的节点分布在不同的子网络中，由于一些特殊的原因，这些子节点之间出现了网络不通的状态，但他们的内部子网络是正常的。从而导致了整个系统的环境被切分成了若干个孤立的区域 |
| T（Tolerance)   | 系统在遇到任何网络分区问题时，仍需要对外提供满足一致性和可用性的服务，除非整个网络都故障了<br>发生分区的时候(每个节点)依然能对外提供服务（不是指可用性，这里可以返回ERROR/TIMEOUT） |

CAP难以同时满足，只能由CP 或者 AP模式

- 分布式系统节点通过网络连接，必然有网络断开的风险，一定会出现分区问题（P）
- 放弃A：当遇到网络分区或者其他故障时，在此期间无法对外提供正常服务
- 放弃C：放弃C不是放弃一致性，而是放弃强一致性，保留最终一致性

## 1.4 BASE理论

BASE理论是对CAP的一种解决思路（AP方案的补充），包含三个思想：

- `Basically Available （基本可用）`：分布式系统在出现故障时，允许损失部分可用性，即保证核心可用
  - **响应时间上的损失**: 正常情况下，处理用户请求需要 0.5s 返回结果，但是由于系统出现故障，处理用户请求的时间变为3s 
  - **系统功能上的损失**：正常情况，用户可以使用系统全部功能,但是由于系统访问量突然剧增,系统的部分非核心功能无法使用(降级处理)

- `Soft State（软状态）`：**在一定时间内，允许出现中间状态，比如临时的不一致状态。**

- `Eventually Consistent（最终一致性）`：虽然无法保证强一致性，但是在软状态结束后，最终达到数据一致

> Redis的主从数据就是异步的，因此不满足强一致性，；而是保证最终一致性

最终一致性的实现方案

- **读时修复** : 在读取数据时，检测数据的不一致，进行修复
- **写时修复** : 在写入数据，检测数据的不一致时，进行修复
- **异步修复** : 这个是最常用的方式，通过定时对账检测副本数据的一致性，并修复

# 2. 一致性协议

- `出现原因`：每一个节点能知道自己的事务操作的结果，却无法知道其他分布式节点的操作结果；所以当一个事务要跨越多个分布式节点时，为了保证ACID，所以需要引入一个`协调者`(Coordinator)
- `协调者`：负责调度参与者的行为，并最终决定参与者是否要把事务真正进行提交
- `目的`：为了保证原子性 和 一致性

## 2.1 2PC(Two-phase-Commit)

2PC就是将事务的提交过程分为了两个阶段来进行处理

阶段一：提交事务请求(投票阶段)

- 事务询问：协调者向所有参与者发送事务内容，询问是否可以执行事务commit操作，然后等待各参与者的反应
- 执行事务：各参与者节点执行事务，并将undo 和 redo信息记录到事务日志中去
- 参与者反馈：如果参与者成功执行了事务操作，反馈YES,否则反馈NO

阶段二：执行事务提交

- 如果收到的反馈都是YES，则执行事务提交
  - 协调者向所有参与者发送Commit请求
  - 参与者收到Commit请求后，会执行Commit操作，然后执行完后释放占用的资源，参与者完成Commit后向协调者发送ACK
  - 协调者收到所有ACK后，完成事务
- 如果至少有一个返回了No或者超时，则中断事务
  - 协调者向参与者发送Rollback请求
  - 参与者收到RollBack请求后，会利用Undo信息执行事务回滚，回滚完释放占用的资源，然后向协调者发送Ack消息
  - 协调者收到所有的ACK后，完成事务中断

优点：原理简单， 实现方便

缺点：

- 同步阻塞：执行过程中，各个参与者都在等待其他参与者的响应而无法进行其他操作
- 单点问题：协调者出现问题那么就会使得流程无法运转，甚至在阶段二出现问题会使得资源不释放
- 脑裂：如果因为网络问题只有部分参与者收到了commit请求，就会导致数据不一致
- 过于保守：**二阶段提交协议没有设计较为完善的容错机制，任意一个节点是失败都会导致整个事务的失败**

## 2.2 3PC

CanCommit：

- 事务询问：协调者向所有的参与者发送一个包含事务内容的canCommit请求，询问是否可以执行事务提交操作，并开始等待响应
- 参与者响应：参与者收到请求后，如果认为自身可以执行事务则返回YES

PreCommit：

- 如果都返回YES，则执行事务预提交；
  - 协调者向参与者发送preCommit请求，进入Prepared阶段；参与者收到preCommit以后，会执行事务操作，并将undo 和 redo信息记录到事务日志中去；参与者执行成功后向协调者返回Ack响应，同时等待指令（commit或者abort）
- 如果至少有一个返回了No或者超时，则中断事务；
  - 协调者向所有参与者发送abort请求；无论是超时还是收到abort，参与者都中断事务

do Commit：

- 执行提交：
  - 收到了所有的Ack响应，然后向所有的参与者发送doCommit；
  - 参与者收到doCommit请求后，会执行Commit操作，然后执行完后释放占用的资源，参与者完成Commit后向协调者发送ACK
  - 协调者收到所有ACK后，完成事务
- 中断事务：
  - 协调者向所有参与者发送abort请求；
  - 参与者收到abort请求后，会利用Undo信息执行事务回滚，回滚完释放占用的资源，然后向协调者发送Ack消息
  - 协调者收到所有的ACK后，完成事务中断

> 注意：一旦进入阶段三，可能会出现 2 种故障：
>
> 1. 协调者出现问题
> 2. 协调者和参与者之间的网络故障
>
> 一旦出现了任一一种情况，最终都会导致参与者无法收到 doCommit 请求或者 abort 请求，针对这种情况，参与者都会在等待超时之后，继续进行事务提交

优点：

- 相比较 2PC，最大的优点是减少了参与者的阻塞范围（第一个阶段是不阻塞的)
- 并且能够在单点故障后继续达成一致（2PC 在提交阶段会出现此问题，而 3PC 会根据协调者的状态进行回滚或者提交）

缺点：

- 如果参与者收到了 preCommit 消息后，出现了网络分区，那么参与者等待超时后，都会进行事务的提交，这必然会出现事务不一致的问题

## 2.3 Paxos

定义：基于`消息传递`且具有`高度容错特性`的`一致性算法`

前提：消息可能会出现延迟，丢失，重复，但是消息不会被篡改

- 因为大多数系统都在同一局域网，所以消息被篡改很少
- 由于硬件和网络原因造成的消息不完整可以通过校验算法避免

目标：最终只有一个提案会被选中，当提案被选择后，进程最终也能获取到被选中的提案

分布式系统中最重要的是安全性 和 活性

- 安全性：保证永远都不会发送的事情
- 活性：指最终一定会发生的事情

### 2.3.1 推导

P1: 一个Acceptor必须批准它收到的第一个提案,一个提案被选定需要半数以上的Acceptor批准（一个Acceptor能批准多个提案）

P2:  如果一个提案[M0, V0]被选定后，那么所有编号比M0更高的，且被选定的提案，其Value也是V0

P2a：如果一个提案[M0, V0]被选定后，那么所有编号比M0更高的，且被Acceptor批准的提案，其Value也是V0

P2B: 如果一个提案[M0, V0]被选定后，那么之后任何Proposer产生的编号更高的提案，其Value值都必须为V0

P2C：如果提案[$M_n$, $V_n$]被提出，那么存在一个半数以上的Acceptor组成的集合S，满足以下两个条件中的任意一个：

- S中每个Acceptor都没有接受过编号小于$$M_n$$的提案。
- S中Acceptor接受过的最大编号的提案的value为$V_n$。

### 2.3.2 Proposer生成提案：

为了满足P2C，Proposer生成提案之前

- 应该先去**『学习』**已经被选定或者可能被选定的value，然后以该value作为自己提出的提案的value。
- 如果没有value被选定，Proposer才可以自己决定value的值
- 这个学习的阶段是通过一个**『Prepare请求』**实现的

Perpare请求(**提案生成算法**)

- `Prepare请求`: Proposer选择一个**新的提案编号N**，然后向**某个Acceptor集合**（半数以上）发送请求，要求该集合中的每个Acceptor做出如下响应（response）
  - 向Proposer承诺保证**不再接受**任何编号**小于N的提案**
  - 如果Acceptor已经接受过提案，那么就向Proposer响应**已经接受过**的编号小于N的**最大编号的提案**
- `Accept请求`:
  - 如果Proposer收到了**半数以上**的Acceptor的**响应**，那么它就可以生成编号为N，Value为V的**提案[N,V]**。这里的V是所有的响应中**编号最大的提案的Value**。
  - 如果所有的响应中**都没有提案**，那 么此时V就可以由Proposer**自己选择**
  - 生成提案后，Proposer将该**提案**发送给**半数以上**的Acceptor集合，并期望这些Acceptor能接受该提案
  - 注意：此时接受Accept请求的Acceptor集合**不一定**是之前响应Prepare请求的Acceptor集合

### 2.3.3 Acceptor批准提案

Acceptor**可以忽略任何请求**（包括Prepare请求和Accept请求）而不用担心破坏算法的**安全性**.

因此，我们这里要讨论的是什么时候Acceptor可以响应一个请求,我们对Acceptor接受提案给出如下约束

> P1a：一个Acceptor只要尚**未响应过**任何**编号大于N**的**Prepare请求**，那么他就可以**接受**这个**编号为N的提案**

- 如果Acceptor收到一个编号为N的Prepare请求，在此之前它已经响应过编号大于N的Prepare请求。根据P1a，该Acceptor不可能接受编号为N的提案。因此，该Acceptor可以忽略编号为N的Prepare请求。当然，也可以回复一个error，让Proposer尽早知道自己的提案不会被接受。

一个Acceptor**只需记住**：1. 已接受的编号最大的提案 2. 已响应的请求的最大编号

### 2.3.4 流程总结

Paxos算法分为**两个阶段**。具体如下：

**阶段一：**

- Proposer选择一个**提案编号N**，然后向**半数以上**的Acceptor发送编号为N的**Prepare请求**。
- 如果一个Acceptor收到一个编号为N的Prepare请求，且N**大于**该Acceptor已经**响应过的**所有**Prepare请求**的编号，那么它就会将它已经**接受过的编号最大的提案（如果有的话）**作为响应反馈给Proposer，同时该Acceptor承诺**不再接受**任何**编号小于N的提案**。

**阶段二：**

- 如果Proposer收到**半数以上**Acceptor对其发出的编号为N的Prepare请求的**响应**，那么它就会发送一个针对**[N,V]提案**的**Accept请求**给**半数以上**的Acceptor。注意：V就是收到的**响应**中**编号最大的提案的value**，如果响应中**不包含任何提案**，那么V就由Proposer**自己决定**。
- 如果Acceptor收到一个针对编号为N的提案的Accept请求，只要该Acceptor**没有**对编号**大于N**的**Prepare请求**做出过**响应**，它就**接受该提案**。

![Paxos算法流程](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/1752522-44c5a422f917bfc5.jpg)

### 2.3.5 Learner学习被选定的value

![幻灯片17.png](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/1752522-0fab48ed2bdf358a.png)

### 2.3.6 如何保证Paxos算法的活性

![幻灯片18.png](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/1752522-28b18dd606777074.png)

