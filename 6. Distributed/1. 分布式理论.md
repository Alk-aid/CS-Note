> 亿级流量网站架构核心技术

# 1. 分布式架构

## 1.1 集中式 & 分布式 

`集中式`：

- `概念`：由一台或者多台计算机组成中心结点；数据存储与控制由这个系统完成，终端只负责数据的input和output，存储
- `优点`：部署简单
- `缺点`：单点故障导致系统不可用；集中式难以扩容

`分布式`：

- `概念`：一个硬件或者软件组件分布在不同的网络计算机上，彼此之间仅仅通过消息传递进行通信和协调的系统
- `特点`：
  - 分布性：
  - 对等性：分布式机器没有主从之分；数据副本保证高可用，服务副本实现负载均衡
  - 并发性：同一个分布式的多个结点可能并发操作共享资源，如数据库或者分布式缓存
  - 缺乏全局时钟：很难定义两个事件的先后顺序

- `问题`:
  - 通信异常：因为网络波动导致通信失败，或者时延高
  - 网络分区：由于网络异常，导致只有部分结点之间能正常通信，而另一些不能；从而形成局部小集群；
  - 三态：成功，失败，超时
  - 节点故障

> TODO: https://segmentfault.com/a/1190000040420527

## 1.2 一致性

`分布式事务`：事务的参与者，服务器位于分布式系统的不同节点上；分布式事务可以看作是由多个分布式操作序列(子事务)组成的

`一致性的分类`

- `强一致性`：这种一致性级别是最符合用户直觉的，它要求系统写入什么，读出来的也会是什么，用户体验好，但实现起来往往对系统的性能影响大
- `弱一致性`：这种一致性级别约束了系统在写入成功后，不承诺立即可以读到写入的值，也不承诺多久之后数据能够达到一致，但会尽可能地保证到某个时间级别（比如秒级别）后，数据能够达到一致状态
- `最终一致性`：最终一致性是弱一致性的一个特例，系统会保证在一定时间内，能够达到一个数据一致的状态。

`最终一致性`的分类

- `因果一致性`：进程A更新数据后通知进程B，那么进程B对该数据的访问一定要是最新的
- `读己之所写`：进程A更新数据后，自己总能访问到最新的
- `会话一致性`：同一个会话的客户端更新后，能读到最新的
- `单调读一致性`：进程读到某个数据后，后续不可能读到比这更旧的值了
- `单调写一致性`：同一个进程的写操作被顺序执行

## 1.3 CAP

`CAP理论`: 分布式系统不可能同时满足一致性(Consistency), 可用性(Availability), 分区容错性(Partition tolerance)

- Consistency（一致性）：用户访问分布式系统中的任意节点，得到的数据必须一致。
- Availability （可用性）：对于用户的每一个操作请求总是能在有限的时间内返回正常的响应的结果(成功或失败)
- Partition（分区）：因为网络故障或其它原因导致分布式系统中的部分节点与其它节点失去连接，形成独立分区。
- Tolerance（容错）：在集群出现分区时，整个系统也要持续对外提供服务。

CAP难以同时满足，只能由CP 或者 AP模式

- 分布式系统节点通过网络连接，必然有网络断开的风险，一定会出现分区问题（P）
- 放弃A：当遇到网络分区或者其他故障时，在此期间无法对外提供正常服务
- 放弃C：放弃C不是放弃一致性，而是放弃强一致性，保留最终一致性

## 1.4 BASE理论

BASE理论是对CAP的一种解决思路（AP方案的补充），包含三个思想：

- `Basically Available （基本可用）`：分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。
  - **响应时间上的损失**: 正常情况下，处理用户请求需要 0.5s 返回结果，但是由于系统出现故障，处理用户请求的时间变为3s 
  - **系统功能上的损失**：正常情况，用户可以使用系统全部功能,但是由于系统访问量突然剧增,系统的部分非核心功能无法使用(降级处理)。

- `Soft State（软状态）`：**在一定时间内，允许出现中间状态，比如临时的不一致状态。**

- `Eventually Consistent（最终一致性）`：虽然无法保证强一致性，但是在软状态结束后，最终达到数据一致。

> Redis的主从数据就是异步的，因此不满足强一致性，；而是保证最终一致性

最终一致性的实现方案

- **读时修复** : 在读取数据时，检测数据的不一致，进行修复。
- **写时修复** : 在写入数据，检测数据的不一致时，进行修复。
- **异步修复** : 这个是最常用的方式，通过定时对账检测副本数据的一致性，并修复。

# 2. 一致性协议

- `出现原因`：每一个节点能知道自己的事务操作的结果，却无法知道其他分布式节点的操作结果；所以当一个事务要跨越多个分布式节点时，为了保证ACID，所以需要引入一个`协调者`(Coordinator)
- `协调者`：负责调度参与者的行为，并最终决定参与者是否要把事务真正进行提交
- `目的`：为了保证原子性 和 一致性

## 2.1 2PC(Two-phase-Commit)

2PC就是将事务的提交过程分为了两个阶段来进行处理

阶段一：提交事务请求(投票阶段)

- 事务询问：协调者向所有参与者发送事务内容，询问是否可以执行事务commit操作，然后等待各参与者的反应
- 执行事务：各参与者节点执行事务，并将undo 和 redo信息记录到事务日志中去
- 参与者反馈：如果参与者成功执行了事务操作，反馈YES,否则反馈NO

阶段二：执行事务提交

- 如果收到的反馈都是YES，则执行事务提交
  - 协调者向所有参与者发送Commit请求
  - 参与者收到Commit请求后，会执行Commit操作，然后执行完后释放占用的资源，参与者完成Commit后向协调者发送ACK
  - 协调者收到所有ACK后，完成事务
- 如果至少有一个返回了No或者超时，则中断事务
  - 协调者向参与者发送Rollback请求
  - 参与者收到RollBack请求后，会利用Undo信息执行事务回滚，回滚完释放占用的资源，然后向协调者发送Ack消息
  - 协调者收到所有的ACK后，完成事务中断

优点：原理简单， 实现方便

缺点：

- 同步阻塞：执行过程中，各个参与者都在等待其他参与者的响应而无法进行其他操作
- 单点问题：协调者出现问题那么就会使得流程无法运转，甚至在阶段二出现问题会使得资源不释放
- 脑裂：如果因为网络问题只有部分参与者收到了commit请求，就会导致数据不一致

## 2.2 3PC

CanCommit：

- 事务询问：协调者向所有的参与者发送一个包含事务内容的canCommit请求，询问是否可以执行事务提交操作，并开始等待响应
- 参与者响应：参与者收到请求后，如果认为自身可以执行事务则返回YES

PreCommit：

- 如果都返回YES，则执行事务预提交；
  - 协调者向参与者发送preCommit请求，进入Prepared阶段；参与者收到preCommit以后，会执行事务操作，并将undo 和 redo信息记录到事务日志中去；参与者执行成功后向协调者返回Ack响应，同时等待指令（commit或者abort）
- 如果至少有一个返回了No或者超时，则中断事务；
  - 协调者向所有参与者发送abort请求；无论是超时还是收到abort，参与者都中断事务

do Commit：

- 执行提交：
  - 收到了所有的Ack响应，然后向所有的参与者发送doCommit；
  - 参与者收到doCommit请求后，会执行Commit操作，然后执行完后释放占用的资源，参与者完成Commit后向协调者发送ACK
  - 协调者收到所有ACK后，完成事务
- 中断事务：
  - 协调者向所有参与者发送abort请求；
  - 参与者收到abort请求后，会利用Undo信息执行事务回滚，回滚完释放占用的资源，然后向协调者发送Ack消息
  - 协调者收到所有的ACK后，完成事务中断

> 注意：一旦进入阶段三，可能会出现 2 种故障：
>
> 1. 协调者出现问题
> 2. 协调者和参与者之间的网络故障
>
> 一段出现了任一一种情况，最终都会导致参与者无法收到 doCommit 请求或者 abort 请求，针对这种情况，参与者都会在等待超时之后，继续进行事务提交。

优点：

- 相比较 2PC，最大的优点是减少了参与者的阻塞范围（第一个阶段是不阻塞的)
- 并且能够在单点故障后继续达成一致（2PC 在提交阶段会出现此问题，而 3PC 会根据协调者的状态进行回滚或者提交）。

缺点：

- 如果参与者收到了 preCommit 消息后，出现了网络分区，那么参与者等待超时后，都会进行事务的提交，这必然会出现事务不一致的问题。

## 2.3 Paxos

基于消息传递且具有高度容错特性的一致性算法

Paxos算法的核心是一致性算法

消息可能会出现延迟，丢失，重复，但是消息不会被损坏

分布式系统中最重要的是安全性 和 活性

- 安全性：保证永远都不会发送的事情
- 活性：指最终一定会发生的事情

P1: 一个Acceptor必须批准它收到的第一个提案,一个提案被选定需要半数以上的Acceptor批准（一个Acceptor能批准多个提案）

P2: 如果编号为M0,VALUE为V0的提案被选中，那么所有编号比M0更高的被选择的提案，其Value也是V0

P2a：如果编号为M0,VALUE为V0的提案被选中，那么所有编号比M0更高的，且被Acceptor批准的提案，其Value也是V0

P2B：
