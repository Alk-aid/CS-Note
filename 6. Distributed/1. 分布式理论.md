# 1. 分布式架构

## 1.2 一致性

`分布式事务`：事务的参与者，服务器位于分布式系统的不同节点上；分布式事务可以看作是由多个分布式操作序列(子事务)组成的

`一致性的分类`

- `强一致性`：这种一致性级别是最符合用户直觉的，它要求系统写入什么，读出来的也会是什么，用户体验好，但实现起来往往对系统的性能影响大
- `弱一致性`：这种一致性级别约束了系统在写入成功后，不承诺立即可以读到写入的值，也不承诺多久之后数据能够达到一致，但会尽可能地保证到某个时间级别（比如秒级别）后，数据能够达到一致状态
- `最终一致性`：最终一致性是弱一致性的一个特例，系统会保证在一定时间内，能够达到一个数据一致的状态。



# 2. 一致性协议

- `出现原因`：每一个节点能知道自己的事务操作的结果，却无法知道其他分布式节点的操作结果；所以当一个事务要跨越多个分布式节点时，为了保证ACID，所以需要引入一个`协调者`(Coordinator)
- `协调者`：负责调度参与者的行为，并最终决定参与者是否要把事务真正进行提交
- `目的`：为了保证原子性 和 一致性

## 2.1 2PC(Two-phase-Commit)

2PC就是将事务的提交过程分为了两个阶段来进行处理

阶段一：提交事务请求(投票阶段)

- 事务询问：协调者向所有参与者发送事务内容，询问是否可以执行事务commit操作，然后等待各参与者的反应
- 执行事务：各参与者节点执行事务，并将undo 和 redo信息记录到事务日志中去
- 参与者反馈：如果参与者成功执行了事务操作，反馈YES,否则反馈NO

阶段二：执行事务提交

- 如果收到的反馈都是YES，则执行事务提交
  - 协调者向所有参与者发送Commit请求
  - 参与者收到Commit请求后，会执行Commit操作，然后执行完后释放占用的资源，参与者完成Commit后向协调者发送ACK
  - 协调者收到所有ACK后，完成事务
- 如果至少有一个返回了No或者超时，则中断事务
  - 协调者向参与者发送Rollback请求
  - 参与者收到RollBack请求后，会利用Undo信息执行事务回滚，回滚完释放占用的资源，然后向协调者发送Ack消息
  - 协调者收到所有的ACK后，完成事务中断

优点：原理简单， 实现方便

缺点：

- 同步阻塞：执行过程中，各个参与者都在等待其他参与者的响应而无法进行其他操作
- 单点问题：协调者出现问题那么就会使得流程无法运转，甚至在阶段二出现问题会使得资源不释放
- 脑裂：如果因为网络问题只有部分参与者收到了commit请求，就会导致数据不一致
- 过于保守：**二阶段提交协议没有设计较为完善的容错机制，任意一个节点是失败都会导致整个事务的失败**

## 2.2 3PC

CanCommit：

- 事务询问：协调者向所有的参与者发送一个包含事务内容的canCommit请求，询问是否可以执行事务提交操作，并开始等待响应
- 参与者响应：参与者收到请求后，如果认为自身可以执行事务则返回YES

PreCommit：

- 如果都返回YES，则执行事务预提交；
  - 协调者向参与者发送preCommit请求，进入Prepared阶段；参与者收到preCommit以后，会执行事务操作，并将undo 和 redo信息记录到事务日志中去；参与者执行成功后向协调者返回Ack响应，同时等待指令（commit或者abort）
- 如果至少有一个返回了No或者超时，则中断事务；
  - 协调者向所有参与者发送abort请求；无论是超时还是收到abort，参与者都中断事务

do Commit：

- 执行提交：
  - 收到了所有的Ack响应，然后向所有的参与者发送doCommit；
  - 参与者收到doCommit请求后，会执行Commit操作，然后执行完后释放占用的资源，参与者完成Commit后向协调者发送ACK
  - 协调者收到所有ACK后，完成事务
- 中断事务：
  - 协调者向所有参与者发送abort请求；
  - 参与者收到abort请求后，会利用Undo信息执行事务回滚，回滚完释放占用的资源，然后向协调者发送Ack消息
  - 协调者收到所有的ACK后，完成事务中断

> 注意：一旦进入阶段三，可能会出现 2 种故障：
>
> 1. 协调者出现问题
> 2. 协调者和参与者之间的网络故障
>
> 一旦出现了任一一种情况，最终都会导致参与者无法收到 doCommit 请求或者 abort 请求，针对这种情况，参与者都会在等待超时之后，继续进行事务提交

优点：

- 相比较 2PC，最大的优点是减少了参与者的阻塞范围（第一个阶段是不阻塞的)
- 并且能够在单点故障后继续达成一致（2PC 在提交阶段会出现此问题，而 3PC 会根据协调者的状态进行回滚或者提交）

缺点：

- 如果参与者收到了 preCommit 消息后，出现了网络分区，那么参与者等待超时后，都会进行事务的提交，这必然会出现事务不一致的问题

# 3. 一致性算法

拜占庭将军问题

## 3.1 Paxos

定义：基于`消息传递`且具有`高度容错特性`的`一致性算法`

前提：消息可能会出现延迟，丢失，重复，但是消息不会被篡改

- 因为大多数系统都在同一局域网，所以消息被篡改很少
- 由于硬件和网络原因造成的消息不完整可以通过校验算法避免

目标：最终只有一个提案会被选中，当提案被选择后，进程最终也能获取到被选中的提案

分布式系统中最重要的是安全性 和 活性

- 安全性：保证永远都不会发送的事情
- 活性：指最终一定会发生的事情

### 3.1.1 推导

P1: 一个Acceptor必须批准它收到的第一个提案,一个提案被选定需要半数以上的Acceptor批准（一个Acceptor能批准多个提案）

P2:  如果一个提案[M0, V0]被选定后，那么所有编号比M0更高的，且被选定的提案，其Value也是V0

P2a：如果一个提案[M0, V0]被选定后，那么所有编号比M0更高的，且被Acceptor批准的提案，其Value也是V0

P2B: 如果一个提案[M0, V0]被选定后，那么之后任何Proposer产生的编号更高的提案，其Value值都必须为V0

P2C：如果提案[$M_n$, $V_n$]被提出，那么存在一个半数以上的Acceptor组成的集合S，满足以下两个条件中的任意一个：

- S中每个Acceptor都没有接受过编号小于$$M_n$$的提案。
- S中Acceptor接受过的最大编号的提案的value为$V_n$。

### 3.1.2 Proposer生成提案：

为了满足P2C，Proposer生成提案之前

- 应该先去**『学习』**已经被选定或者可能被选定的value，然后以该value作为自己提出的提案的value。
- 如果没有value被选定，Proposer才可以自己决定value的值
- 这个学习的阶段是通过一个**『Prepare请求』**实现的

Perpare请求(**提案生成算法**)

- `Prepare请求`: Proposer选择一个**新的提案编号N**，然后向**某个Acceptor集合**（半数以上）发送请求，要求该集合中的每个Acceptor做出如下响应（response）
  - 向Proposer承诺保证**不再接受**任何编号**小于N的提案**
  - 如果Acceptor已经接受过提案，那么就向Proposer响应**已经接受过**的编号小于N的**最大编号的提案**
- `Accept请求`:
  - 如果Proposer收到了**半数以上**的Acceptor的**响应**，那么它就可以生成编号为N，Value为V的**提案[N,V]**。这里的V是所有的响应中**编号最大的提案的Value**。
  - 如果所有的响应中**都没有提案**，那 么此时V就可以由Proposer**自己选择**
  - 生成提案后，Proposer将该**提案**发送给**半数以上**的Acceptor集合，并期望这些Acceptor能接受该提案
  - 注意：此时接受Accept请求的Acceptor集合**不一定**是之前响应Prepare请求的Acceptor集合

### 3.1.3 Acceptor批准提案

Acceptor**可以忽略任何请求**（包括Prepare请求和Accept请求）而不用担心破坏算法的**安全性**.

因此，我们这里要讨论的是什么时候Acceptor可以响应一个请求,我们对Acceptor接受提案给出如下约束

> P1a：一个Acceptor只要尚**未响应过**任何**编号大于N**的**Prepare请求**，那么他就可以**接受**这个**编号为N的提案**

- 如果Acceptor收到一个编号为N的Prepare请求，在此之前它已经响应过编号大于N的Prepare请求。根据P1a，该Acceptor不可能接受编号为N的提案。因此，该Acceptor可以忽略编号为N的Prepare请求。当然，也可以回复一个error，让Proposer尽早知道自己的提案不会被接受。

一个Acceptor**只需记住**：1. 已接受的编号最大的提案 2. 已响应的请求的最大编号

### 3.1.4 流程总结

Paxos算法分为**两个阶段**。具体如下：

**阶段一：**

- Proposer选择一个**提案编号N**，然后向**半数以上**的Acceptor发送编号为N的**Prepare请求**。
- 如果一个Acceptor收到一个编号为N的Prepare请求，且N**大于**该Acceptor已经**响应过的**所有**Prepare请求**的编号，那么它就会将它已经**接受过的编号最大的提案（如果有的话）**作为响应反馈给Proposer，同时该Acceptor承诺**不再接受**任何**编号小于N的提案**。

**阶段二：**

- 如果Proposer收到**半数以上**Acceptor对其发出的编号为N的Prepare请求的**响应**，那么它就会发送一个针对**[N,V]提案**的**Accept请求**给**半数以上**的Acceptor。注意：V就是收到的**响应**中**编号最大的提案的value**，如果响应中**不包含任何提案**，那么V就由Proposer**自己决定**。
- 如果Acceptor收到一个针对编号为N的提案的Accept请求，只要该Acceptor**没有**对编号**大于N**的**Prepare请求**做出过**响应**，它就**接受该提案**。

![Paxos算法流程](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/1752522-44c5a422f917bfc5.jpg)

### 3.1.5 Learner学习被选定的value

![幻灯片17.png](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/1752522-0fab48ed2bdf358a.png)

### 3.1.6 如何保证Paxos算法的活性

![幻灯片18.png](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/1752522-28b18dd606777074.png)

## 3.2 Raft



