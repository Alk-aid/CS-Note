# 1. 全局唯一 ID

# 2. 分布式锁

分布式锁解决的问题是: 在分布式系统下不同进程对于共享资源的访问需要互斥来防止彼此干扰

分布式锁需要具备的特点:

- **互斥性**: 任意时刻，只有一个客户端能持有锁。
- **锁超时释放**：持有锁超时，可以释放，防止不必要的资源浪费，也可以防止死锁。
- **可重入性**:一个线程如果获取了锁之后,可以再次对其请求加锁。
- **高性能和高可用**：加锁和解锁需要开销尽可能低，同时也要保证高可用，避免分布式锁失效。
- **安全性**：锁只能被持有的客户端删除，不能被其他客户端删除

## 2.1 Redis

> https://juejin.cn/post/6936956908007850014#heading-2

**目的**：使用分布式锁来限制程序的并发执行。

**格式**：用lua脚本实现加锁和解锁的的原子性

```sh
// 原子性加锁并设置过期时间
set <key> true ex <seconds> nx
del <key>
```

**演化：**

- 开始是setnx <key> true(加锁操作)
- 但是如果执行过程中出现了异常，那么这个锁就永远得不到释放；所以需要添加一个过期事件expire <key> <seconds>
- 但是如果setnx 和 expire执行之间出现了错误，那么还是会出现死锁情况。所以setnx 和 expire操作应该是原子性的
- 使用事务是不行的，因为Redis的事务不是原子性的，会出现没抢到锁还是执行了expire

**超时问题**：

- 因为业务执行流程较长，使得到了过期时间而业务代码未执行完就自动释放锁
- 守护线程解决方案：额外起一个线程，定期检查线程是否还持有锁，如果有则延长过期时间。有和引入redlock相同的问题
- 超时回滚解决方案：当我们解锁时发现锁已经被其他线程获取了，说明此时我们执行的操作已经是“不安全”的了，此时需要进行回滚，并返回失败

**可重入性**： Java中需要配合ThreadLocal来实现可重入性

**加锁失败**：因为获取不到Redis分布式锁, 不会进入阻塞状态, 本质上是一个boolean判断

- `直接抛出异常，通知客户端稍后重试`：适合于由用户直接发起的请求，用户看到错误后，自己点重试，起到人工延时的作用
- `sleep以后然后重试`：会阻塞当前的消息处理线程，容易造成消息处理有延时
- `将请求转移至延时队列中，过一会再试`：将消息序列化作为zset的value，过期时间作为score，放入到zset中；多个线程轮询zset获取到期的任务进行处理。

**RedLock算法**: 工业上有争议

- `出现原因`：在集群模式下，可能出一个客户端在主节点申请一把锁，但是这个锁还未同步到从节点，主节点就挂掉了；导致另一个客户端请求加锁时，新的主节点立刻就批准了；导致一把锁背多个客户端持有
- 需要提供多个Redis实例，加锁时向过半结点发送set(key,valie,nx = True,ex = xxx)指令，只要过半结点set成功，则认为加锁成功

---

## 2.2 Zookeeper

Zookeeper方案：安全性更好

1、创建一个锁目录 /locks，该节点为持久节点

2、想要获取锁的线程都在锁目录下创建一个临时顺序节点

3、获取锁目录下所有子节点，对子节点按节点自增序号从小到大排序

4、判断本节点是不是第一个子节点，如果是，则成功获取锁，开始执行业务逻辑操作；如果不是，则监听自己的上一个节点的删除事件

5、持有锁的线程释放锁，只需删除当前节点即可。

6、当自己监听的节点被删除时，监听事件触发，则回到第3步重新进行判断，直到获取到锁。

# 3. 分布式缓存

# 4. 分布式任务

# 5. 分布式会话

# 6. 分布式文件系统

# 7. 分布式存储系统

# 8. 分布式计算

