# 1. JMM基础

内存模型的作用：通过屏蔽各种硬件和操作系统对内存的访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。

内存模型的结构：主内存 和 工作内存

- 主内存：所有的共享变量都存储在主内存当中。共享变量有实例字段，static字段，数据
- 工作内存：每个线程都有自己的工作内存，工作内存保存的是主内存中的变量副本
- 线程只能访问工作内存，不能直接访问主内存；不同线程也无法直接访问对方工作内存中的变量
- 这里说的主内存、工作内存与 Java 内存区域中的堆、栈、方法区等不是同一个层次的内存划分。

存在的问题

- 工作内存数据一致性问题： 各个线程都有自己的工作内存，其中保存共享变量的副本，那么就有可能出现数据不一致的情况。可用通过volatile 或 synchronized来解决
- **指令重排序优化**：Java 中重排序通常是编译器或运行时环境为了优化程序性能而采取的对指令进行重新排序执行的一种手段。
  - 重排序分为两类：编译期重排序和运行期重排序
  - 重排序遵循的原则：`as-if-serial`,存在数据依赖关系的不允许重排序。
  - 多线程环境下，可能因为指令重排序导致运行结果与预期不同。
  - 解决方案：禁止指令重排序，通过volatile或者synchronized部分禁止

# 2. 并发三要素

**三要素是什么**

- `原子性`：一个操作或者多个操作，要么全部执行（执行的过程不会被任何因素打断），要么就都不执行
- `可见性`：多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值
- `有序性`：一个线程中的所有操作必须按照程序的顺序来执行。

**导致三要素出现的原因**

- `原子性`：多个线程并发执行，一个线程没执行完就会出现线程的切换
- `可见性`：CPU增加了缓存，容易导致缓存和主存中的数据不一致
- `有序性`：编译程序优化指令执行次序，来优化程序性能

> 而这三大特性，归根结底，是为了实现多线程的 **数据一致性**，使得程序在多线程并发，指令重排序优化的环境中能如预期运行。

**实现原子性**：

- 通过同一时间内只有一个线程能访问对应的共享变量，即使时间片用完，也不会释放锁，等到获得到时间片以后，重入锁继续执行
- 使用 `synchronized` 或者 `lock`来保证方法和代码块内的操作是原子性的。

**实现可见性**

- JMM 是通过 **"变量修改后将新值同步回主内存**， **变量读取前从主内存刷新变量值"** 来实现可见性的。具体而言
- `volatile`：当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。
- `synchronized`：在`Java内存模型`中，synchronized规定，线程在加锁时， `先清空工作内存 → 在主内存中拷贝最新变量的副本到工作内存 → 执行完代码 → 将更改后的共享变量的值刷新到主内存中 → 释放互斥锁。`
- 其实他们的底层都和lock前缀和MESI协议有关

**实现有序性**

- 通过禁止指令重排序来实现，在 Java 中，可以使用 `synchronized` 和 `volatile`
- `volatile` 关键字会禁止指令重排序。
- `synchronized` 关键字通过互斥保证同一时刻只允许一条线程操作。
- 使用`synchronized并不能解决有序性`问题，**但是如果是该`变量`整个都在synchronized代码块的保护范围内**，那么变量就不会被多个线程同时操作，也不用考虑有序性问题！在这种情况下相当于解决了重排序问题！
- 但是如果共享变量逃逸出了代码块，那么仍然会造成指令重排序问题

# 3. Happens Before

**什么是Happens Before**

- 注意，两个操作之间具有 happens-before 关系，并不意味着前一个操作必须要在后一个操作之前执行！而是要求前一个操作（执行的结果）对后一个操作可见

**八大原则**

- `单一线程原则`：在一个线程内，在程序前面的操作先行发生于后面的操作。
- `线程启动规则`: Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。
- `线程加入规则`: Thread 对象的结束先行发生于 join() 方法返回。
- `线程中断规则`: 对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生
- `对象终结规则`: 一个对象的初始化先行发生于它的 finalize() 方法的开始。
- `管程锁定规则`: 一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。
- `volatile 变量规则`: 对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。
- `传递性`: 如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。

# 4. 内存屏障

**Java 通过 内存屏障（memory barrier） 保证底层操作的有序性和可见性**

- 在两个CPU指令之间插入内存屏障指令，来禁止指令重排序，从而保障**有序性**的。
- 会对volatile写指令加上lock前缀，从而使得数据立即同步回主存，然后通过MESI协议来通知其他CPU，从而保证可见性

**常见有 4 种屏障**

- `LoadLoad` 屏障 - 对于这样的语句 `Load1; LoadLoad; Load2`，在 Load2 及后续读取操作要读取的数据被访问前，保证 Load1 要读取的数据被读取完毕。
- `StoreStore` 屏障 - 对于这样的语句 `Store1; StoreStore; Store2`，在 Store2 及后续写入操作执行前，保证 Store1 的写入操作对其它处理器可见。
- `LoadStore` 屏障 - 对于这样的语句 `Load1; LoadStore; Store2`，在 Store2 及后续写入操作被执行前，保证 Load1 要读取的数据被读取完毕。
- `StoreLoad` 屏障 - 对于这样的语句 `Store1; StoreLoad; Load2`，在 Load2 及后续所有读取操作执行前，保证 Store1 的写入对所有处理器可见。它的开销是四种屏障中最大的（冲刷写缓冲器，清空无效化队列）。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。

# 5. 线程安全

**什么是线程安全**

- 当多个线程同时访问一个 对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都能获得正确的结果，那么就称这个对象是线程安全的

**线程安全的划分等级**

- `不可变`：天然的线程安全，如String，包装类，枚举类型，final关键字修饰的基本数据类型
- `绝对线程安全`：不管运行时环境如何，调用者都不需要任何额外的同步措施。
- `相对线程安全`：单独操作是线程安全的，对于一些特定顺序的连续调用，需要添加额外的同步手段。如Vector，JUC下的集合类
- `线程兼容`：对象本身并不是线程安全的，但是可以通过添加同步手段实现线程安全
- `线程对立`：无论是否采取了同步措施，都无法在多线程环境中并发使用的代码。

**变量的线程安全**：

- 局部变量是线程安全的
- 局部变量引用的对象，如果未逃离出方法则是安全的；否则不是
- 成员变量：如果他们被共享了，而且含有写操作，则这段代码是临界区，需要考虑线程安全
- 一段代码块内如果存在对`共享资源`的`多线程` `读写`操作，称这段代码块为**临界区**

# 6. 线程安全的实现

**悲观锁和乐观锁**

- `悲观锁`：悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据。
- `乐观锁`：乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。

**线程安全的实现**

- `互斥同步`：synchronized 和 ReentrantLock等有锁并发。是一种悲观锁的思维。
- `非阻塞同步`：采用CAS，是一种乐观锁的思维。
  - CAS需要Compare和Swap这两个步骤具备`原子性`，通过`硬件`来保证
- `无同步方案`：如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。
  - 栈封闭: 多线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。
  - ThreadLocal: 把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。

# 7. 线程活跃度

- `活锁`：出现在两个线程 **`互相改变对方的结束条件`**，谁也无法结束。
- `饥饿`：某些线程因为优先级太低，导致一直无法获得资源的现象。

# 8. 指令重排序

指令重排序的目的：提高处理的速度

重排序的种类：

- 编译器重排序：
- CPU重排序：
- 内存的重排序：由缓存造成的，类似于

