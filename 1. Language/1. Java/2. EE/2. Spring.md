# ---------------使用篇-----------------

# 1. IOC

- IoC（Inversion Of Control）控制反转，Spring反向控制应用程序所需要使用的外部资源,把对象创建和对象之间的调用过程，交给Spring进行管理
- **Spring 控制的资源全部放置在 Spring 容器中，该容器称为 IoC 容器**
- Bean管理主要有两个操作：创建对象和注入属性

## 1.1 XML开发

### 1.1.1 Bean

**用来创建对象**

```xml
<bean id="beanId" name="beanName1,beanName2" class="ClassName"></bean>
```

#### I 基本属性

* id：bean 的名称，通过 id 值获取 bean (首字母小写)
* class：bean 的类型，使用完全限定类名
* name：bean 的名称，可以通过name值获取bean，用于多人配合时给bean起别名

#### II 作用范围

格式：

```xml
<bean scope="singleton"></bean>
```

取值：

- singleton：设定创建出的对象保存在 Spring 容器中，是一个单例的对象，**加载spring配置文件时候就会创建单实例对象设置**
- prototype：设定创建出的对象保存在 Spring 容器中，是一个非单例（原型）的对象，**在调用getBean方法时候创建多实例对象。**
- request、session、application、 websocket ：设定创建出的对象放置在 web 容器对应的位置

Spring 容器中 Bean 的**线程安全**问题：

* 原型 Bean，每次创建一个新对象，线程之间并不存在 Bean 共享，所以不会有线程安全的问题

* 单例 Bean，所有线程共享一个单例实例 Bean，因此是存在资源的竞争，如果单例 Bean是一个**无状态 Bean**，也就是线程中的操作不会对 Bean 的成员执行查询以外的操作，那么这个单例 Bean 是线程安全的

  解决方法：开发人员来进行线程安全的保证，最简单的办法就是把 Bean 的作用域 singleton 改为 protopyte

> 默认是单例模式

#### III 生命周期

> bean生命周期
>
> 1. 通过构造器创建bean实例（无参数构造）
> 2. 为bean的属性设置值和对其他bean引用（调用set方法）
> 3. 调用bean的初始化的方法（需要进行配置初始化的方法）
> 4. bean可以使用了（对象获取到了）
> 5. 当容器关闭时候，调用bean的销毁的方法（需要进行配置销毁的方法） 

作用：定义 bean 对象在初始化或销毁时完成的工作

格式：

```xml
<bean init-method="init" destroy-method="destroy></bean>
```

取值：bean 对应的类中对应的具体方法名

实现接口的方式实现初始化，无需配置文件配置 init-method：

* 实现 InitializingBean，定义初始化逻辑
* 实现 DisposableBean，定义销毁逻辑

注意事项：

- 当 scope=“singleton” 时，Spring 容器中有且仅有一个对象，init 方法在创建容器时仅执行一次
- 当 scope=“prototype” 时，Spring 容器要创建同一类型的多个对象，init 方法在每个对象创建时均执行一次
- 当 scope=“singleton” 时，关闭容器（.close()）会导致bean实例的销毁，调用 destroy 方法一次
- 当 scope=“prototype” 时，对象的销毁由垃圾回收机制 gc 控制，destroy 方法将不会被执行

bean 配置：

```xml
<!--init-method和destroy-method用于控制bean的生命周期-->
<bean id="userService3" scope="prototype" init-method="init" destroy-method="destroy" class="service.impl.UserServiceImpl"/>
```

业务层实现类：

```java
public class UserServiceImpl implements UserService{
    public UserServiceImpl(){
        System.out.println(" constructor is running...");
    }

    public void init(){
        System.out.println("init....");
    }

    public void destroy(){
        System.out.println("destroy....");
    }

    public void save() {
        System.out.println("user service running...");
    }
}
```

测试类：

```java
UserService userService = (UserService)ctx.getBean("userService3");
```

#### IV 工厂

静态工厂

- 作用：定义 bean 对象创建方式，使用静态工厂的形式创建 bean，兼容早期遗留系统的升级工作

- 格式：

```xml
<bean class="FactoryClassName" factory-method="factoryMethodName"></bean>
```

- 取值：工厂 bean 中用于获取对象的静态方法名

- 注意事项：class 属性必须配置成静态工厂的类名

- bean配置：

```xml
<!--静态工厂创建 bean-->
<bean id="userService4" class="service.UserServiceFactory" factory-method="getService"/>
```

工厂类：

```java
public class UserServiceFactory {
    public static UserService getService(){
        System.out.println("factory create object...");
        return new UserServiceImpl();
    }
}
```

测试类：

```java
UserService userService = (UserService)ctx.getBean("userService4");
```

---

实例工厂

- 作用：定义 bean 对象创建方式，使用实例工厂的形式创建 bean，兼容早期遗留系统的升级工作

- 格式：

```xml
<bean factory-bean="factoryBeanId" factory-method="factoryMethodName"></bean>
```

- 注意事项：

  - 使用实例工厂创建 bean 首先需要将实例工厂配置 bean，交由 Spring 进行管理


  - factory-bean 是实例工厂的 Id


- bean 配置：

```xml
<!--实例工厂创建 bean，依赖工厂对象对应的 bean-->
<bean id="factoryBean" class="service.UserServiceFactory2"/>
<bean id="userService5" factory-bean="factoryBean" factory-method="getService"/>
```

- 工厂类：

```java
public class UserServiceFactory2 {
    public UserService getService(){
        System.out.println(" instance factory create object...");
        return new UserServiceImpl();
    }
}
```

#### V 获取Bean

applicationContext 子类相关API：

| 方法                                              | 说明                                             |
| ------------------------------------------------- | ------------------------------------------------ |
| String[] getBeanDefinitionNames()                 | 获取 Spring 容器中定义的所有 JavaBean 的名称     |
| BeanDefinition getBeanDefinition(String beanName) | 返回给定 bean 名称的 BeanDefinition              |
| String[] getBeanNamesForType(Class<?> type)       | 获取 Spring 容器中指定类型的所有 JavaBean 的名称 |
| Environment getEnvironment()                      | 获取与此组件关联的环境                           |

### 1.1.2 DI(Dependency Injection)

- IoC（Inversion Of Control）控制翻转，Spring 反向控制应用程序所需要使用的外部资源

- DI（Dependency Injection）依赖注入，应用程序运行依赖的资源由 Spring 为其提供，资源进入应用程序的方式称为注入。简单说就是利用反射机制为类的属性赋值的操作

- IoC 和 DI 的关系：IoC 与 DI 是同一件事站在不同角度看待问题

#### I set注入

基本属性：

* name：对应 bean 中的属性名，要注入的变量名，要求该属性必须提供可访问的 set 方法
   (严格规范此名称是 set 方法对应名称，首字母必须小写)
* value：设定非引用类型属性对应的值，不能与 ref 同时使用
* ref：设定引用类型属性对应 bean 的 id ，不能与 value 同时使用

> 实现原理就是调用对应的set方法，至于调用哪个set方法是根据name来确定的

**代码实现：**

* DAO层：要注入的资源

  ```java
  public interface UserDao {
      public void save();
  }
  ```

  ```java
  public class UserDaoImpl implements UserDao{
      public void save(){
          System.out.println("user dao running...");
      }
  }
  ```

* Service业务层

  ```java
  public interface UserService {
      public void save();
  }
  ```

  ```java
  public class UserServiceImpl implements UserService {
  	private UserDao userDao;
      private int num;
      
      //1.对需要进行注入的变量添加set方法
      public void setUserDao(UserDao userDao) {
          this.userDao = userDao;
      }
      
  	public void setNum(int num) {
          this.num = num;
      }
      
      public void save() {
          System.out.println("user service running..." + num);
          userDao.save();
          bookDao.save();
      }
  }
  ```

* 配置applicationContext.xml

  ```xml
  <!--2.将要注入的资源声明为bean-->
  <bean id="userDao" class="dao.impl.UserDaoImpl"/>
  
  <bean id="userService" class="service.impl.UserServiceImpl">
  	<!--3.将要注入的引用类型的变量通过property属性进行注入，-->
      <property name="userDao" ref="userDao"/>
      <property name="num" value="666"/>
  </bean>
  ```

* 测试类

  ```java
  public class UserApp {
      public static void main(String[] args) {
          ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");
          UserService userService = (UserService) ctx.getBean("userService");
          userService.save();
      }
  }
  ```

#### II 构造注入

属性：

* name：对应bean中的构造方法所携带的参数名
* value：设定非引用类型构造方法参数对应的值，不能与 ref 同时使用
* ref：设定引用类型构造方法参数对应 bean 的 id ，不能与 value 同时使用
* type ：设定构造方法参数的类型，用于按类型匹配参数或进行类型校验
* index ：设定构造方法参数的位置，用于按位置匹配参数，参数 index 值从 0 开始计数

```xml
<bean id="userDao" class="dao.impl.UserDaoImpl">
    <!--使用构造方法进行注入，需要保障注入的属性与bean中定义的属性一致-->
	<!--一致指顺序一致或类型一致或使用index解决该问题-->
    <constructor-arg index="2" value="123"/>
    <constructor-arg index="1" value="root"/>
    <constructor-arg index="0" value="com.mysql.jdbc.Driver"/>
</bean>
```

```xml
<bean id="userService" class="service.impl.UserServiceImpl">
	<constructor-arg name="userDao" ref="userDao"/>
	<constructor-arg name="num" value="666666"/>
</bean>
```

> 使用构造的情况可以是给final类型的对象，或者set方法是private的

#### III 集合注入

标签：<array> <list> <set> <map> <props>，<property>或<constructor-arg>标签的子标签

```xml
<bean id="bookDao" class="dao.impl.BookDaoImpl">
    <property name="al">
        <list>
            <value>seazean</value>
            <value>66666</value>
        </list>
    </property>
    <property name="properties">
        <props>
            <prop key="name">seazean666</prop>
            <prop key="value">666666</prop>
        </props>
    </property>
    <property name="arr">
        <array>
            <value>123456</value>
            <value>66666</value>
        </array>
    </property>
    <property name="hs">
        <set>
            <value>seazean</value>
            <value>66666</value>
        </set>
    </property>
    <property name="hm">
        <map>
            <entry key="name" value="seazean66666"/>
            <entry key="value" value="6666666666"/>
        </map>
    </property>
</bean>
```

### 1.1.3 引入外部属性文件

操作步骤：

1. 准备外部 properties 文件

2. 开启 context 命名空间支持

   ```xml
   <?xml version="1.0" encoding="UTF-8"?>
   <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xmlns:context="http://www.springframework.org/schema/context"
          xsi:schemaLocation="
           http://www.springframework.org/schema/beans
           https://www.springframework.org/schema/beans/spring-beans.xsd
           http://www.springframework.org/schema/context
           https://www.springframework.org/schema/context/spring-context.xsd
           ">
   ```

3. 加载指定的 properties 文件

   ```xml
   <context:property-placeholder location="classpath:data.properties" />
   ```

4. 使用加载的数据

   ```xml
   <property name="propertyName" value="${propertiesName}"/>
   ```

- 注意：如果需要加载所有的 properties 文件，可以使用`*.properties`表示加载所有的 properties 文件.

```xml
<context:property-placeholder location="classpath:*.properties"/>
```

- 注意：读取数据使用**${propertiesName}**格式进行，其中 propertiesName 指 properties 文件中的属性名

### 1.1.4 import

标签：<import>，<beans>标签的子标签

作用：在当前配置文件中导入其他配置文件中的项

格式：

```xml
<beans>
    <import />
</beans>
```

属性：

* resource：加载的配置文件名

```xml
<import resource=“config2.xml"/>
```

Spring容器加载多个配置文件：

* applicationContext-book.xml

  ```xml
  <bean id="bookDao" class="dao.impl.BookDaoImpl">
      <property name="num" value="1"/>
  </bean>
  ```

* applicationContext-user.xml

  ```xml
  <bean id="userDao" class="dao.impl.UserDaoImpl">
      <property name="userName" value="${username}"/>
      <property name="password" value="${pwd}"/>
  </bean>
  
  <bean id="userService" class="service.impl.UserServiceImpl">
      <property name="userDao" ref="userDao"/>
      <property name="bookDao" ref="bookDao"/>
  </bean>
  ```

* applicationContext.xml

  ```xml
  <import resource="applicationContext-user.xml"/>
  <import resource="applicationContext-book.xml"/>
  
  <bean id="bookDao" class="com.seazean.dao.impl.BookDaoImpl">
      <property name="num" value="2"/>
  </bean>
  ```

* 测试类

  ```java
  new ClassPathXmlApplicationContext("applicationContext-user.xml","applicationContext-book.xml");
  new ClassPathXmlApplicationContext("applicationContext.xml");
  ```

Spring 容器中的 bean 定义冲突问题

- 同 id 的 bean，后定义的覆盖先定义的
- 导入配置文件可以理解为将导入的配置文件复制粘贴到对应位置，程序执行选择最下面的配置使用
- 导入配置文件的顺序与位置不同可能会导致最终程序运行结果不同

### 1.1.5 整合mybatis

Mybatis 核心配置文件消失

1. 环境 environment 转换成数据源对象
2. 映射 Mapper 扫描工作交由 spring 处理
3. 类型别名交由 spring 处理

---

过程

1. pom.xml，导入坐标

```xml
<dependency>
    <groupId>org.mybatis</groupId>
    <artifactId>mybatis</artifactId>
    <version>3.5.3</version>
</dependency>
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>5.1.47</version>
</dependency>
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid</artifactId>
    <version>1.1.16</version>
</dependency>

<dependency>
    <groupId>org.mybatis</groupId>
    <artifactId>mybatis-spring</artifactId>
    <version>1.3.0</version>
</dependency>

<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
    <version>5.1.9.RELEASE</version>
</dependency>
```

2. jdbc.properties 连接mysql

   ```properties
   jdbc.driver=com.mysql.jdbc.Driver
   jdbc.url=jdbc:mysql://192.168.2.185:3306/spring_db
   jdbc.username=root
   jdbc.password=123456
   ```

3. AccountDao.xml

   ```xml
   <?xml version="1.0" encoding="UTF-8" ?>
   <!DOCTYPE mapper
           PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
           "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
   <mapper namespace="dao.AccountDao">
       <!--配置根据id查询-->
       <select id="findById" resultType="account" parameterType="int">
           SELECT * FROM account WHERE id = #{id}
       </select>
   </mapper>
   ```

4. ApplicationContext.xml

   ```xml
   <?xml version="1.0" encoding="UTF-8"?>
   <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xmlns:context="http://www.springframework.org/schema/context"
          xsi:schemaLocation="
           http://www.springframework.org/schema/beans
           https://www.springframework.org/schema/beans/spring-beans.xsd
           http://www.springframework.org/schema/context
           https://www.springframework.org/schema/context/spring-context.xsd
           ">
       <!--加载properties配置文件-->
       <context:property-placeholder location="classpath:jdbc.properties"/>
   
       <!--加载druid资源-->
       <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">
           <property name="driverClassName" value="${jdbc.driver}"/>
           <property name="url" value="${jdbc.url}"/>
           <property name="username" value="${jdbc.username}"/>
           <property name="password" value="${jdbc.password}"/>
       </bean>
   
       <!--配置service作为spring的bean,注入dao-->
       <bean id="accountService" class="service.impl.AccountServiceImpl">
           <property name="accountDao" ref="accountDao"/>
       </bean>
   
       <!--spring整合mybatis后控制的创建连接的对象,domain下包括所有引用类-->
       <bean class="org.mybatis.spring.SqlSessionFactoryBean">
           <property name="dataSource" ref="dataSource"/>
           <property name="typeAliasesPackage" value="domain"/>
       </bean>
   
       <!--加载mybatis映射配置的扫描，将其作为spring的bean进行管理-->
       <bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
           <property name="basePackage" value="dao"/>
       </bean>
   </beans>
   ```

5. DAO层

   ```java
   public interface AccountDao {
   	Account findById(Integer id);
   }
   ```

6. Service层

   ```java
   public interface AccountService {
       Account findById(Integer id);
   }
   ```

   ```java
   public class AccountServiceImpl implements AccountService {
       private AccountDao accountDao;
   	//set注入
       public void setAccountDao(AccountDao accountDao) {
           this.accountDao = accountDao;
       }
   
       @Override
       public Account findById(Integer id) {
           return accountDao.findById(id);
       }
   }
   
   ```

7. 测试类

   ```java
   public class App {
       public static void main(String[] args) {
           ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");
           AccountService accountService = (AccountService) ctx.getBean("accountService");
           Account ac = accountService.findById(1);
           System.out.println(ac);
   	}
   }
   ```


## 1.2 注解开发

### 1.2.1 注解驱动

#### I XML格式

启动注解扫描，加载类中配置的注解项：

```xml
<context:component-scan base-package="packageName1,packageName2"/>
```

说明：

- 在进行包扫描时，会对配置的包及其子包中所有文件进行扫描，多个包采用`,`隔开
- 扫描过程是以文件夹递归迭代的形式进行的
- 扫描过程仅读取合法的 java 文件
- 扫描时仅读取 spring 可识别的注解
- 扫描结束后会将可识别的有效注解转化为 spring 对应的资源加入 IoC 容器
- 从加载效率上来说注解优于 XML 配置文件

<img src="https://gitee.com/seazean/images/raw/master/Frame/注解驱动示例.png" style="zoom: 67%;" />

#### II 纯注解形式

注解配置类

名称：@Configuration、@ComponentScan

类型：类注解

作用：**设置当前类为 Spring 核心配置加载类**

格式：

```java
@Configuration
@ComponentScan({"scanPackageName1","scanPackageName2"})
public class SpringConfigClassName{
}
```

说明：

- 核心配合类用于替换 Spring 核心配置文件，此类可以设置空的，不设置变量与属性
- bean 扫描工作使用注解 @ComponentScan 替代，多个包用 `{} 和 ,` 隔开

加载纯注解格式上下文对象，需要使用 **AnnotationConfigApplicationContext**

```java
@Configuration
public class SpringConfig {
    @Bean
    public Person person() {
        return new Person1("lisi", 20);
    }
}

public class MainTest {
    public static void main(String[] args) {
        ApplicationContext applicationContext = new 
            		AnnotationConfigApplicationContext(SpringConfig.class);
        //方式一：名称对应类名
        Person bean = applicationContext.getBean(Person.class);
        System.out.println(bean);
		
        //方式二：名称对应方法名 
        Person bean1 = (Person) applicationContext.getBean("person1");	
        
        //方法三：指定名称@Bean("person2")
    }
}
```

#### III 扫描器

组件扫描过滤器

开发过程中，需要根据需求加载必要的bean，排除指定bean

![](https://gitee.com/seazean/images/raw/master/Frame/组件扫描器.png)



名称：@ComponentScan

类型：**类注解**

作用：设置 Spring 配置加载类扫描规则

格式：

```java
@ComponentScan(
    value = {"dao","service"},			//设置基础扫描路径
    excludeFilters =					//设置过滤规则，当前为排除过滤
	@ComponentScan.Filter(				//设置过滤器
	    type= FilterType.ANNOTATION,  	//设置过滤方式为按照注解进行过滤
	    classes = Service.class)     	//设置具体的过滤项，过滤所有@Service修饰的bean
    )
)
```

属性：

* includeFilters：设置包含性过滤器 
* excludeFilters：设置排除性过滤器
* type：设置过滤器类型

### 1.2.2 Bean

#### I 设置Bean

给容器中注册组件的方式

1. 包扫描+组件标注注解(@Component、@Controller、@Service、@Repository) 
2. @Bean(导入第三方包里面的组件):
3. @Import(快速给容器中导入一个组件)

##### 组件标注注解

> 过于常见

##### @Bean

名称：@Bean

类型：方法注解

作用：设置该方法的返回值作为 Spring 管理的 bean

格式：

```java
@Component
public class JDBCConfig {
    @Bean("dataSource")
    public static DruidDataSource getDataSource() {
        DruidDataSource ds = new DruidDataSource();
        ds.setDriverClassName("com.mysql.jdbc.Driver");
        ds.setUrl("jdbc:mysql://192.168.2.185:3306/spring_db");
        ds.setUsername("root");
        ds.setPassword("123456");
        return ds;
    }
}
```

说明：

- 因为第三方 bean 无法在其源码上进行修改，使用 @Bean 解决第三方 bean 的引入问题
- @Bean 所在的类必须被 Spring 扫描加载，否则该注解无法生效

相关属性

- value（默认）：定义 bean 的访问 id,默认的话 方法名是bean的id
- initMethod：声明初始化方法，参数是方法名称，对应方法的定义在要导入的组件中进行定义
- destroyMethod：声明销毁方法，参数是方法名称，对应方法的定义在要导入的组件中进行定义

##### @Import

类型：类注解

作用：导入第三方 bean 作为 Spring 控制的资源，这些类都会被 Spring 创建并放入 ioc 容器

格式：

```java
@Configuration
@Import(OtherClassName.class)
public class ClassName {
}
```

说明：

- @Import 注解在同一个类上，仅允许添加一次，如果需要导入多个，使用数组的形式进行设定
- 在被导入的类中可以继续使用 @Import 导入其他资源

如导入资源

```java
@Configuration
@ComponentScan(value = {"service","dao"})
@Import(JDBCConfig.class)
public class SpringConfig {
}
```

#### II 作用范围

名称：@Scope

类型：类注解，写在类定义上方

作用：设置该类作为 bean 对应的 scope 属性

格式：

```java
@Scope
public class ClassName{}
```

相关属性

- value（默认）：定义 bean 的作用域，默认为 singleton，非单例取值 prototype

#### III 生命周期

名称：@PostConstruct、@PreDestroy

类型：方法注解，写在方法定义上方

作用：设置该类作为 bean 对应的生命周期方法

示例：

```java
//定义bean，后面添加bean的id
@Component("userService")
//定义bean的作用域
@Scope("singleton")
public class UserServiceImpl implements UserService {
    //初始化
    @PostConstruct
    public void init(){
        System.out.println("user service init...");
    }
	//销毁
    @PreDestroy
    public void destroy(){
        System.out.println("user service destroy...");
    }
}
```

> 对于@Bean的，可以通过设置initMethod，destoryMethod来进行生命周期管理

#### IV 加载资源

### 1.2.3 DI

#### I 基本类型

1. 名称：@Value

2. 类型：属性注解、方法注解

3. 作用：设置对应属性的值或对方法进行传参

4. 格式：

```java
//@Value("${jdbc.username}")
@Value("root")
private String username;
```

5. 说明：

- value 值仅支持非引用类型数据，赋值时对方法的所有参数全部赋值

- value 值支持读取 properties 文件中的属性值，通过类属性将 properties 中数据传入类中

- value 值支持 SpEL

- @value 注解如果添加在属性上方，可以省略 set 方法（set 方法的目的是为属性赋值）

6. 相关属性：

- value（默认）：定义对应的属性值或参数值

#### II 属性填充

1. 名称：@Autowired、@Qualifier

2. 类型：属性注解、方法注解

3. 作用：设置对应属性的对象、对方法进行引用类型传

4. 格式：

   ```java
   @Autowired(required = false)
   @Qualifier("userDao")
   private UserDao userDao;
   ```


5. 说明：

- @Autowired 默认按类型装配，指定 @Qualifier 后可以指定自动装配的 bean 的 id

6. 相关属性：

- required：**为 true （默认）表示注入 bean 时该 bean 必须存在**，不然就会注入失败抛出异常；为 false  表示注入时该 bean 存在就注入，不存在就忽略跳过

注意：在使用 @Autowired 时，首先在容器中查询对应类型的 bean，如果查询结果刚好为一个，就将该 bean 装配给 @Autowired 指定的数据，如果查询的结果不止一个，那么 @Autowired 会根据名称来查找。如果查询的结果为空，那么会抛出异常。解决方法：使用 required = false

#### III 属性设置

1. 名称：@Primary

2. 类型：类注解

3. 作用：设置类对应的 bean 按类型装配时优先装配

4. 范例：

```java
@Primary
public class ClassName{}
```

5. 说明：

- @Autowired 默认按类型装配，当出现相同类型的 bean，使用 @Primary 提高按类型自动装配的优先级，多个 @Primary 会导致优先级设置无效

#### IV @Resource

@Resource 相关属性

- name：设置注入的 bean 的 id

- type：设置注入的 bean 的类型，接收的参数为 Class 类型

**@Autowired 和 @Resource之间的区别**：

*  @Autowired 默认是按照类型装配注入的，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）

*  @Resource 默认按照名称来装配注入，只有当找不到与名称匹配的bean才会按照类型来装配注入

### 1.2.4 文件读取

名称：@PropertySource

类型：类注解

作用：加载properties文件中的属性值

格式：

```java
@PropertySource(value = "classpath:filename.properties")
public class ClassName {
    @Value("${propertiesAttributeName}")
    private String attributeName;
}
```

说明：

- 不支持 * 通配符，加载后，所有 Spring 控制的 bean 中均可使用对应属性值，加载多个需要用 `{} 和 ,` 隔开

相关属性

- value（默认）：设置加载的 properties 文件名

- ignoreResourceNotFound：如果资源未找到，是否忽略，默认为 false

### 1.2.5 加载控制

#### I 依赖加载

@DependsOn

- 名称：@DependsOn

- 类型：类注解、方法注解

- 作用：控制 bean 的加载顺序，使其在指定 bean 加载完毕后再加载

- 格式：

  ```java
  @DependsOn("beanId")
  public class ClassName {
  }
  ```

- 说明：

  - 配置在方法上，使 @DependsOn 指定的 bean 优先于 @Bean 配置的 bean 进行加载

  - 配置在类上，使 @DependsOn 指定的 bean 优先于当前类中所有 @Bean 配置的 bean 进行加载

  - 配置在类上，使 @DependsOn 指定的 bean 优先于 @Component 等配置的 bean 进行加载

- 相关属性

  - value（默认）：设置当前 bean 所依赖的 bean 的 id

@Order

- 名称：@Order

- 类型：**配置类注解**

- 作用：控制配置类的加载顺序，值越小越先加载

- 格式：

  ```java
  @Order(1)
  public class SpringConfigClassName {
  }
  ```

@Lazy

- 名称：@Lazy

- 类型：类注解、方法注解

- 作用：控制 bean 的加载时机，使其延迟加载，获取的时候加载

- 格式：

  ```java
  @Lazy
  public class ClassName {
  }
  ```

#### II 应用场景

@DependsOn

- 微信订阅号，发布消息和订阅消息的bean的加载顺序控制（先开订阅，再发布）

- 双11活动期间，零点前是结算策略A，零点后是结算策略B，策略B操作的数据为促销数据。策略B加载顺序与促销数据的加载顺序

@Lazy

- 程序灾难出现后对应的应急预案处理是启动容器时加载时机

@Order

- 多个种类的配置出现后，优先加载系统级的，然后加载业务级的，避免细粒度的加载控制




# 2. AOP

## 2.1 基本概述

AOP（Aspect Oriented Programing）：面向切面编程，一种编程**范式**，指导开发者如何组织程序结构

AOP 弥补了 OOP 的不足，基于 OOP 基础之上进行横向开发：

- OOP 规定程序开发以类为主体模型，一切围绕对象进行，完成某个任务先构建模型

- AOP 程序开发主要关注基于 OOP 开发中的共性功能，一切围绕共性功能进行，完成某个任务先构建可能遇到的所有共性功能（当所有功能都开发出来也就没有共性与非共性之分），将软件开发由手工制作走向半自动化/全自动化阶段，实现“插拔式组件体系结构”搭建

AOP 作用：

* 提高代码的可重用性
* 业务代码编码更简洁
* 业务代码维护更高效
* 业务功能扩展更便捷

## 2.2 核心概念

### 2.2.1 概念详述

- Joinpoint（连接点）：就是方法
- Pointcut（切入点）：就是挖掉共性功能的方法
- Advice（通知）：就是共性功能，最终以一个方法的形式呈现
- Aspect（切面）：就是共性功能与挖的位置的对应关系
- Target（目标对象）：就是挖掉功能的方法对应的类产生的对象，这种对象是无法直接完成最终工作的
- Weaving（织入）：就是将挖掉的功能回填的动态过程
- Proxy（代理）：目标对象无法直接完成工作，需要对其进行功能回填，通过创建原始对象的代理对象实现
- Introduction（引入/引介）：就是对原始对象无中生有的添加成员变量或成员方法

### 2.2.2 入门案例

开发步骤：

- 开发阶段

  - 制作程序

  - 将非共性功能开发到对应的目标对象类中，并制作成切入点方法

  - 将共性功能独立开发出来，制作成通知

  - 在配置文件中，声明切入点

  - 在配置文件中，声明切入点与通知间的关系（含通知类型），即切面

- 运行阶段（AOP 完成）

  - Spring 容器加载配置文件，监控所有配置的**切入点**方法的执行

  - 当监控到切入点方法被运行，**使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置将通知对应的功能织入**，完成完整的代码逻辑并运行

1. 导入坐标 pom.xml

   ```xml
   <dependency>
       <groupId>org.springframework</groupId>
       <artifactId>spring-context</artifactId>
       <version>5.1.9.RELEASE</version>
   </dependency>
   <dependency>
       <groupId>org.aspectj</groupId>
       <artifactId>aspectjweaver</artifactId>
       <version>1.9.4</version>
   </dependency>
   ```

2. 业务层抽取通用代码  service / UserServiceImpl

   ```java
   public interface UserService {
       public void save();
   }
   ```

   ```java
   public class UserServiceImpl implements UserService {
       @Override
       public void save() {
           //System.out.println("共性功能");
           System.out.println("user service running...");
       }
   }
   ```

   aop.AOPAdvice

   ```java
   //1.制作通知类，在类中定义一个方法用于完成共性功能
   public class AOPAdvice {
       //共性功能抽取后职称独立的方法
       public void function(){
           System.out.println("共性功能");
       }
   }
   ```

3. 把通知加入spring容器管理，配置aop  applicationContext.xml

   ```xml
   <?xml version="1.0" encoding="UTF-8"?>
   <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xmlns:context="http://www.springframework.org/schema/context"
          xmlns:aop="http://www.springframework.org/schema/aop"
          xsi:schemaLocation="
           http://www.springframework.org/schema/beans
           https://www.springframework.org/schema/beans/spring-beans.xsd
           http://www.springframework.org/schema/context
           https://www.springframework.org/schema/context/spring-context.xsd
           http://www.springframework.org/schema/aop
           https://www.springframework.org/schema/aop/spring-aop.xsd
           ">
       <!--原始Spring控制资源-->
       <bean id="userService" class= "service.impl.UserServiceImpl"/>
       <!--2.配置共性功能成功spring控制的资源-->
       <bean id="myAdvice" class="aop.AOPAdvice"/>
       <!--3.开启AOP命名空间: beans标签内-->
       <!--4.配置AOP-->
       <aop:config>
           <!--5.配置切入点-->
           <aop:pointcut id="pt" expression="execution(* *..*(..))"/>
           <!--6.配置切面（切入点与通知的关系）-->
           <aop:aspect ref="myAdvice">
               <!--7.配置具体的切入点对应通知中那个操作方法-->
               <aop:before method="function" pointcut-ref="pt"/>
           </aop:aspect>
       </aop:config>
   </beans>
   ```

4. 测试类

   ```java
   public class App {
       public static void main(String[] args) {
           ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");
           UserService userService = (UserService) ctx.getBean("userService");
           userService.save();//先输出共性功能，然后 user service running...
       }
   }
   ```

## 2.3 XML开发

### 2.3.1 AspectJ

Aspect（切面）用于描述切入点与通知间的关系，是 AOP 编程中的一个概念

AspectJ 是基于 java 语言对 Aspect 的实现

### 2.3.2 Pointcut

#### I 切入点

> 切入点描述的是某个方法
>
> 切入点表达式是一个快速匹配方法描述的通配格式，类似于正则表达式.

#### II 表达式

格式：

```xml
关键字(访问修饰符  返回值  包名.类名.方法名(参数)异常名)
```

示例：

```java
//匹配UserService中只含有一个参数的findById方法
execution(public User service.UserService.findById(int))
```

格式解析：

* 关键字：描述表达式的匹配模式（参看关键字列表）
* 访问修饰符：方法的访问控制权限修饰符
* 类名：方法所在的类（此处可以配置接口名称）
* 异常：方法定义中指定抛出的异常

关键字：

- execution ：匹配执行指定方法

- args ：匹配带有指定参数类型的方法

- within、this、target、@within、@target、@args、@annotation、bean、reference pointcut等


通配符：

* *：单个独立的任意符号，可以独立出现，也可以作为前缀或者后缀的匹配符出现

  ```java
  //匹配com.seazean包下的任意包中的UserService类或接口中所有find开头的带有一个任意参数的方法
  execution(public * com.seazean.*.UserService.find*(*)
  ```

* .. ：多个连续的任意符号，可以独立出现，常用于简化包名与参数

  ```java
  //匹配com包下的任意包中的UserService类或接口中所有名称为findById参数任意数量和类型的方法
  execution(public User com..UserService.findById(..))
  ```

* +：专用于匹配子类类型

  ```java
  //匹配任意包下的Service结尾的类或者接口的子类或者实现类
  execution(* *..*Service+.*(..))
  ```

逻辑运算符：

- &&：连接两个切入点表达式，表示两个切入点表达式同时成立的匹配
- ||：连接两个切入点表达式，表示两个切入点表达式成立任意一个的匹配
- ! ：连接单个切入点表达式，表示该切入点表达式不成立的匹配

示例：

```java
execution(* *(..))		//前三个都是匹配全部
execution(* *..*(..))
execution(* *..*.*(..))
execution(public * *..*.*(..))
execution(public int *..*.*(..))
execution(public void *..*.*(..))
execution(public void com..*.*(..)) 
execution(public void com..service.*.*(..))
execution(public void com.seazean.service.*.*(..))
execution(public void com.seazean.service.User*.*(..))
execution(public void com.seazean.service.*Service.*(..))
execution(public void com.seazean.service.UserService.*(..))
execution(public User com.seazean.service.UserService.find*(..))	//find开头
execution(public User com.seazean.service.UserService.*Id(..))		//I
execution(public User com.seazean.service.UserService.findById(..))
execution(public User com.seazean.service.UserService.findById(int))
execution(public User com.seazean.service.UserService.findById(int,int))
execution(public User com.seazean.service.UserService.findById(int,*))
execution(public User com.seazean.service.UserService.findById())
execution(List com.seazean.service.*Service+.findAll(..))
```

### 2.3.3 Advice

#### I 通知类型

AOP 的通知类型共5种：前置通知，后置通知、返回后通知、抛出异常后通知、环绕通知。

**before：**

> 1. **前置通知**：原始方法执行前执行，如果通知中抛出异常，阻止原始方法运行
> 2. 应用：数据校验
>
> 3. 格式
>
> ```xml
> <aop:aspect ref="adviceId">
>     <aop:before method="methodName" pointcut="execution(* *(..))"/>
>     <!--一个aop:aspect标签中可以配置多个aop:before标签-->
> </aop:aspect>
> ```
>
> 4. 基本属性：
>
> - method：在通知类中设置当前通知类别对应的方法
>
> - pointcut：设置当前通知对应的切入点表达式，与pointcut-ref属性冲突
>
> - pointcut-ref：设置当前通知对应的切入点id，与pointcut属性冲突

after

> 作用：设置后置通知
>
> * **后置通知**：原始方法执行后执行，无论原始方法中是否出现异常，都将执行通知
>
> * 应用：现场清理
>
> 格式：
>
> ```xml
> <aop:aspect ref="adviceId">
>     <aop:after method="methodName" pointcut="execution(* *(..))"/>
>     <!--一个aop:aspect标签中可以配置多个aop:after标签-->
> </aop:aspect>
> ```
>
> 基本属性：
>
> - method：在通知类中设置当前通知类别对应的方法
>
> - pointcut：设置当前通知对应的切入点表达式，与pointcut-ref属性冲突
>
> - pointcut-ref：设置当前通知对应的切入点id，与pointcut属性冲突

after-r

> 作用：设置返回后通知
>
> * **返回后通知**：原始方法正常执行完毕并返回结果后执行，如果原始方法中抛出异常，无法执行
>
> * 应用：返回值相关数据处理
>
> 格式：
>
> ```xml
> <aop:aspect ref="adviceId">
>     <aop:after-returning method="methodName" pointcut="execution(* *(..))"/>
>     <!--一个aop:aspect标签中可以配置多个aop:after-returning标签-->
> </aop:aspect>
> ```
>
> 基本属性：
>
> - method：在通知类中设置当前通知类别对应的方法
> - pointcut：设置当前通知对应的切入点表达式，与pointcut-ref属性冲突
> - pointcut-ref：设置当前通知对应的切入点id，与pointcut属性冲突
> - returning：设置接受返回值的参数，与通知类中对应方法的参数一致

after-t

> 作用：设置抛出异常后通知
>
> * **抛出异常后通知**：原始方法抛出异常后执行，如果原始方法没有抛出异常，无法执行
> * 应用：对原始方法中出现的异常信息进行处理
>
> 格式：
>
> ```xml
> <aop:aspect ref="adviceId">
>     <aop:after-throwing method="methodName" pointcut="execution(* *(..))"/>
>     <!--一个aop:aspect标签中可以配置多个aop:after-throwing标签-->
> </aop:aspect>
> ```
>
> 基本属性：
>
> - method：在通知类中设置当前通知类别对应的方法
> - pointcut：设置当前通知对应的切入点表达式，与pointcut-ref属性冲突
> - pointcut-ref：设置当前通知对应的切入点id，与pointcut属性冲突
> - throwing：设置接受异常对象的参数，与通知类中对应方法的参数一致

around

> 作用：设置环绕通知
>
> * **环绕通知**：在原始方法执行前后均有对应执行执行，还可以阻止原始方法的执行
>
> * 应用：功能强大，可以做任何事情
>
> 格式：
>
> ```xml
> <aop:aspect ref="adviceId">
>     <aop:around method="methodName" pointcut="execution(* *(..))"/>
>     <!--一个aop:aspect标签中可以配置多个aop:around标签-->
> </aop:aspect>
> ```
>
> 基本属性：
>
> - method ：在通知类中设置当前通知类别对应的方法
>
> - pointcut ：设置当前通知对应的切入点表达式，与pointcut-ref属性冲突
>
> - pointcut-ref ：设置当前通知对应的切入点id，与pointcut属性冲突
>
> 环绕通知的开发方式（参考通知顺序章节）：
>
> - 环绕通知是**在原始方法的前后添加功能**，在环绕通知中，存在对原始方法的显式调用
>
>   ```java
>   public Object around(ProceedingJoinPoint pjp) throws Throwable {
>       Object ret = pjp.proceed();
>       return ret;
>   }
>   ```
>
> - 环绕通知方法相关说明：
>
>   - 方法须设定Object类型的返回值，否则会**拦截**原始方法的返回。如果原始方法返回值类型为void，通知方法也可以设定返回值类型为void，最终返回null
>
>   - 方法需在第一个参数位置设定ProceedingJoinPoint对象，通过该对象调用proceed()方法，实现**对原始方法的调用**。如省略该参数，原始方法将无法执行
>
>   - 使用proceed()方法调用原始方法时，因无法预知原始方法运行过程中是否会出现异常，强制抛出Throwable对象，封装原始方法中可能出现的异常信息

#### II 通知顺序

当同一个切入点配置了多个通知时，通知会存在运行的先后顺序，该顺序以通知配置的顺序为准。

* AOPAdvice

  ```java
  public class AOPAdvice {
      public void before(){
          System.out.println("before...);
      }
      public void after(){
          System.out.println("after...");
      }
      public void afterReturing(){
          System.out.println("afterReturing...");
      }
      public void afterThrowing(){
          System.out.println("afterThrowing...");
      }
      public Object around(ProceedingJoinPoint pjp) {
          System.out.println("around before...");
         	//对原始方法的调用
          Object ret = pjp.proceed();
          System.out.println("around after..."+ret);
     	    return ret;
      }
  }
  ```

* applicationContext.xml  **顺序执行**

  ```xml
  <aop:config>
      <aop:pointcut id="pt" expression="execution(* *..*(..))"/>
      <aop:aspect ref="myAdvice">
  		<aop:before method="before" pointcut-ref="pt"/>
          <aop:after method="after" pointcut-ref="pt"/>
          <aop:after-returning method="afterReturing" pointcut-ref="pt"/>
          <aop:after-throwing method="afterThrowing" pointcut-ref="pt"/>
          <aop:around method="around" pointcut-ref="pt"/>
      </aop:aspect>
  </aop:config>
  ```


## 2.4 注解开发

### 2.4.1 AOP注解

AOP 注解简化 XML：

![](https://gitee.com/seazean/images/raw/master/Frame/AOP注解开发.png)

注意事项：

1. 切入点最终体现为一个方法，无参无返回值，无实际方法体内容，但不能是抽象方法

2. 引用切入点时必须使用方法调用名称，方法后面的（）不能省略

3. 切面类中定义的切入点只能在当前类中使用，如果想引用其他类中定义的切入点使用“类名.方法名()”引用

4. 可以在通知类型注解后添加参数，实现 XML 配置中的属性，例如 after-returning 后的 returning 性

### 2.4.2 启用注解

#### I XML

开启 AOP 注解支持：

```xml
<aop:aspectj-autoproxy/>
<context:component-scan base-package="aop,config,service"/><!--启动Spring扫描-->
```

开发步骤：

1. 导入坐标（伴随 spring-context 坐标导入已经依赖导入完成）
2. 开启 AOP 注解支持
3. 配置切面 @Aspect
4. 定义专用的切入点方法，并配置切入点 @Pointcut
5. 为通知方法配置通知类型及对应切入点 @Before

#### II 纯注解

注解：@EnableAspectJAutoProxy

位置：Spring 注解配置类定义上方

作用：设置当前类开启 AOP 注解驱动的支持，加载 AOP 注解

格式：

```java
@Configuration
@ComponentScan("com.seazean")
@EnableAspectJAutoProxy
public class SpringConfig {
}
```

#### 2.4.3 基本注解

#### I Aspect

注解：@Aspect

位置：类定义上方

作用：设置当前类为切面类

格式：

```java
@Aspect
public class AopAdvice {
}
```

#### II Pointcut

注解：@Pointcut

位置：方法定义上方

作用：使用当前方法名作为切入点引用名称

格式：

```java
@Pointcut("execution(* *(..))")
public void pt() {
}
```

说明：被修饰的方法忽略其业务功能，格式设定为无参无返回值的方法，方法体内空实现（非抽象）

#### III Before

注解：@Before

位置：方法定义上方

作用：标注当前方法作为前置通知

格式：

```java
@Before("pt()")
public void before(JoinPoint joinPoint){
    //joinPoint.getArgs();
}
```

注意：**多个参数时，JoinPoint参数一定要在第一位**

#### IV After

注解：@After

位置：方法定义上方

作用：标注当前方法作为后置通知

格式：

```java
@After("pt()")
public void after(){
}
```

#### V AfterR

注解：@AfterReturning

位置：方法定义上方

作用：标注当前方法作为返回后通知

格式：

```java
@AfterReturning(value="pt()",returning = "result")
public void afterReturning(Object result) {
}
```

特殊参数：

- returning ：设定使用通知方法参数**接收**返回值的变量名

#### VI AfterT

注解：@AfterThrowing

位置：方法定义上方

作用：标注当前方法作为异常后通知

格式：

```java
@AfterThrowing(value="pt()",throwing = "t")
public void afterThrowing(Throwable t){
}
```

特殊参数：

- throwing ：设定使用通知方法参数接收原始方法中抛出的异常对象名

#### VII Around

注解：@Around

位置：方法定义上方

作用：标注当前方法作为环绕通知

格式：

```java
@Around("pt()")
public Object around(ProceedingJoinPoint pjp) throws Throwable {
    Object ret = pjp.proceed();
    return ret;
}
```

### 2.4.3 执行顺序

AOP 使用 XML 配置情况下，通知的执行顺序由配置顺序决定，在注解情况下由于不存在配置顺序的概念，参照通知所配置的**方法名字符串对应的编码值顺序**，可以简单理解为字母排序

- 同一个通知类中，相同通知类型以方法名排序为准

  ```java
  @Before("aop.AOPPointcut.pt()")
  public void aop001Log(){}
  
  @Before("aop.AOPPointcut.pt()")
  public void aop002Exception(){}
  ```

- 不同通知类中，以类名排序为准

- 使用 @Order 注解通过变更 bean 的加载顺序改变通知的加载顺序

  ```java
  @Component
  @Aspect
  @Order(1)  //先执行
  public class AOPAdvice2 {
  }
  ```

  ```java
  @Component
  @Aspect
  @Order(2) 
  public class AOPAdvice1 {//默认执行此通知
  }
  ```

## 2.5 AOP原理

Spirng 可以通过配置的形式控制使用的代理形式，Spring 会先判断是否实现了接口，如果实现了接口就使用 JDK 动态代理，如果没有实现接口则使用 CGLIB 动态代理，通过配置可以修改为使用 CGLIB 

- XML 配置

  ```xml
  <!--XML配置AOP-->
  <aop:config proxy-target-class="false"></aop:config>
  ```

- XML 注解支持

  ```xml
  <!--注解配置AOP-->
  <aop:aspectj-autoproxy proxy-target-class="false"/>
  ```

- 注解驱动

  ```java
  //修改为使用 cglib 创建代理对象
  @EnableAspectJAutoProxy(proxyTargetClass = true)
  ```

* JDK 动态代理和 CGLIB 动态代理的区别：

  * JDK 动态代理只能对实现了接口的类生成代理，没有实现接口的类不能使用。
  * CGLIB 动态代理即使被代理的类没有实现接口也可以使用，因为 CGLIB 动态代理是使用继承被代理类的方式进行扩展
  * CGLIB 动态代理是通过继承的方式，覆盖被代理类的方法来进行代理，所以如果方法是被 final 修饰的话，就不能进行代理

# 3. 事务(ToDo)

## 3.1 事务机制

### 3.1.1 介绍

Spring 事务一般加到业务层，对应着业务的操作，Spring 事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，Spring 是无法提供事务功能的，Spring 只提供统一事务管理接口

Spring 在事务开始时，根据当前环境中设置的隔离级别，调整数据库隔离级别，由此保持一致。程序是否支持事务首先取决于数据库 ，比如 MySQL ，如果是 **innodb 引擎**，是支持事务的；如果 MySQ L使用 myisam 引擎，那从根上就是不支持事务的

### 3.1.2 隔离级别

TransactionDefinition 接口中定义了五个表示隔离级别的常量：

- TransactionDefinition.ISOLATION_DEFAULT：使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ 隔离级别，Oracle 默认采用的 READ_COMMITTED隔离级别.
- TransactionDefinition.ISOLATION_READ_UNCOMMITTED：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读
- TransactionDefinition.ISOLATION_READ_COMMITTED：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生
- TransactionDefinition.ISOLATION_REPEATABLE_READ：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。
- TransactionDefinition.ISOLATION_SERIALIZABLE：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别

MySQL InnoDB 存储引擎的默认支持的隔离级别是 **REPEATABLE-READ（可重读）**

**分布式事务**：允许多个独立的事务资源（transactional resources）参与到一个全局的事务中。事务资源通常是关系型数据库系统，但也可以是其他类型的资源，全局事务要求在其中的所有参与的事务要么都提交，要么都回滚，这对于事务原有的 ACID 要求又有了提高

在使用分布式事务时，InnoDB 存储引擎的事务隔离级别必须设置为 SERIALIZABLE

### 3.1.3 传播行为

* TransactionDefinition.PROPAGATION_REQUIRED： 如果当前存在事务，则**加入该事务**；如果当前没有事务，则创建一个新的事务
  * 内外层是相同的事务
  * 在 aMethod 或者在 bMethod 内的任何地方出现异常，事务都会被回滚
* TransactionDefinition.PROPAGATION_SUPPORTS： 如果当前存在事务，则**加入该事务**；如果当前没有事务，则以非事务的方式继续运行
* TransactionDefinition.PROPAGATION_MANDATORY： 如果当前存在事务，则**加入该事务**；如果当前没有事务，则抛出异常

**不支持当前事务**的情况：

- TransactionDefinition.PROPAGATION_REQUIRES_NEW： 创建一个新的事务，如果当前存在事务，则把当前事务挂起。
  - 内外层是不同的事务，如果 bMethod 已经提交，如果 aMethod 失败回滚 ，bMethod 不会回滚
  - 如果 bMethod 失败回滚，ServiceB 抛出的异常被 ServiceA 捕获，如果 B 抛出的异常是 A 会回滚的异常，aMethod 事务需要回滚，否则仍然可以提交
- TransactionDefinition.PROPAGATION_NOT_SUPPORTED： **以非事务方式运行**，如果当前存在事务，则把当前事务挂起
- TransactionDefinition.PROPAGATION_NEVER： **以非事务方式运行**，如果当前存在事务，则抛出异常

其他情况：

* TransactionDefinition.PROPAGATION_NESTED： 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于 PROPAGATION_REQUIRED 
  * 如果 ServiceB 异常回滚，可以通过 try-catch 机制执行 ServiceC
  * 如果 ServiceB 提交， ServiceA 可以根据具体的配置决定是 commit 还是 rollback

requied：必须的、supports：支持的、mandatory：强制的、nested：嵌套的

### 3.1.4 超时属性

事务超时，就是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。在 `TransactionDefinition` 中以 int 的值来表示超时时间，其单位是秒，默认值为-1

### 3.1.5 只读属性

对于只有读取数据查询的事务，可以指定事务类型为 readonly，即只读事务；只读事务不涉及数据的修改，数据库会提供一些优化手段，适合用在有多条数据库查询操作的方法中

读操作为什么需要启用事务支持：

* MySQL  默认对每一个新建立的连接都启用了 `autocommit` 模式，在该模式下，每一个发送到 MySQL 服务器的 `sql` 语句都会在一个**单独**的事务中进行处理，执行结束后会自动提交事务，并开启一个新的事务
* 执行多条查询语句，如果方法加上了 `Transactional` 注解，这个方法执行的所有 `sql` 会被放在一个事务中，如果声明了只读事务的话，数据库就会去优化它的执行，并不会带来其他的收益。如果不加 `Transactional`，每条 `sql` 会开启一个单独的事务，中间被其它事务修改了数据，比如在前条 SQL 查询之后，后条 SQL 查询之前，数据被其他用户改变，则这次整体的统计查询将会出**现读数据不一致的状态**

# ---------------IOC原理篇-----------------

# 1. 什么是IOC

IoC 全称为 `Inversion of Control`，翻译为 “控制反转”。**所谓 IOC ，就是由 Spring IOC 容器来负责对象的生命周期和对象之间的关系**

如何理解“控制反转”好呢？理解好它的关键在于我们需要回答如下四个问题：

1. 谁控制谁

> 在传统的开发模式下，我们都是采用直接 new 一个对象的方式来创建对象，也就是说你依赖的对象直接由你自己控制，但是有了 IOC 容器后，则直接由 IoC 容器来控制。所以“谁控制谁”，当然是 IoC 容器控制对象。

2. 控制什么：控制对象

3. 为何是反转

> 没有 IoC 的时候我们都是在自己对象中主动去创建被依赖的对象，这是正转。但是有了 IoC 后，所依赖的对象直接由 IoC 容器创建后注入到被注入的对象中，依赖的对象由原来的主动获取变成被动接受，所以是反转。

4. 哪些方面反转了：所依赖对象的获取被反转了。

# 2. 统一资源加载策略

资源加载策略需要满足如下要求：

1. 职能划分清楚。资源的定义和资源的加载应该要有一个清晰的界限；
2. 统一的抽象。统一的资源定义和资源加载策略。资源加载后要返回统一的抽象给客户端，客户端要对资源进行怎样的处理，应该由抽象资源接口来界定。

## 2.1 统一资源

`org.springframework.core.io.Resource` 为 Spring 框架所有资源的抽象和访问接口，它继承 `org.springframework.core.io.InputStreamSource`接口。作为所有资源的统一抽象，Source 定义了一些通用的方法，由子类 `AbstractResource` 提供统一的默认实现。定义如下：

```java
public interface Resource extends InputStreamSource{
    
}
```

类结构图如下：

![202105092051297881.png](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/202105092051297881.png)

从上图可以看到，Resource 根据资源的不同类型提供不同的具体实现，如下：

- FileSystemResource：对 `java.io.File` 类型资源的封装，只要是跟 File 打交道的，基本上与 FileSystemResource 也可以打交道。支持文件和 URL 的形式，实现 WritableResource 接口，且从 Spring Framework 5.0 开始，FileSystemResource 使用NIO.2 API进行读/写交互
- ByteArrayResource：对字节数组提供的数据的封装。如果通过 InputStream 形式访问该类型的资源，该实现会根据字节数组的数据构造一个相应的 ByteArrayInputStream。
- UrlResource：对 `java.net.URL`类型资源的封装。内部委派 URL 进行具体的资源操作。
- ClassPathResource：class path 类型资源的实现。使用给定的 ClassLoader 或者给定的 Class 来加载资源。
- InputStreamResource：将给定的 InputStream 作为一种资源的 Resource 的实现类。

---

AbstractResource 为 Resource 接口的默认实现，它实现了 Resource 接口的大部分的公共实现.

> 如果我们想要实现自定义的 Resource，记住不要实现 Resource 接口，而应该继承 AbstractResource 抽象类，然后根据当前的具体资源特性覆盖相应的方法即可。

## 2.2 统一资源定位

一开始就说了 Spring 将资源的定义和资源的加载区分开了，Resource 定义了统一的资源，那资源的加载则由 ResourceLoader 来统一定义。

`org.springframework.core.io.ResourceLoader` 为 Spring 资源加载的统一抽象，具体的资源加载则由相应的实现类来完成，所以我们可以将 ResourceLoader 称作为统一资源定位器。其定义如下：

```java
public interface ResourceLoader {
    String CLASSPATH_URL_PREFIX = ResourceUtils.CLASSPATH_URL_PREFIX;

    Resource getResource(String location);

    ClassLoader getClassLoader();
}
```

ResourceLoader 接口提供两个方法：`getResource()`、`getClassLoader()`。

1. `getResource()`根据所提供资源的路径 location 返回 Resource 实例，但是它不确保该 Resource 一定存在，需要调用 `Resource.exist()`方法判断。该方法支持以下模式的资源加载：

- URL位置资源，如”file:C:/test.dat”
- ClassPath位置资源，如”classpath:test.dat”
- 相对路径资源，如”WEB-INF/test.dat”，此时返回的Resource实例根据实现不同而不同
- 该方法的主要实现是在其子类 DefaultResourceLoader 中实现，具体过程我们在分析 DefaultResourceLoader 时做详细说明。

2. `getClassLoader()` 返回 ClassLoader 实例，对于想要获取 ResourceLoader 使用的 ClassLoader 用户来说，可以直接调用该方法来获取，在分析 Resource 时，提到了一个类 ClassPathResource ，这个类是可以根据指定的 ClassLoader 来加载资源的。



作为 Spring 统一的资源加载器，它提供了统一的抽象，具体的实现则由相应的子类来负责实现，其类的类结构图如下：

![202105092051301142.png](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/202105092051301142.png)

### 2.2.1 DefaultResourceLoader

DefaultResourceLoader 是 ResourceLoader 的默认实现

#### I ClassLoader

1. DefaultResourceLoader 接收 ClassLoader 作为构造函数的参数或者使用不带参数的构造函数.
2. 在使用不带参数的构造函数时，使用的 ClassLoader 为默认的 ClassLoader（一般为`Thread.currentThread().getContextClassLoader()`）
3. 可以通过 `ClassUtils.getDefaultClassLoader()`获取。
4. 当然也可以调用 `setClassLoader()`方法进行后续设置

```java
public DefaultResourceLoader() {
    this.classLoader = ClassUtils.getDefaultClassLoader();
}

public DefaultResourceLoader(@Nullable ClassLoader classLoader) {
    this.classLoader = classLoader;
}

public void setClassLoader(@Nullable ClassLoader classLoader) {
    this.classLoader = classLoader;
}

@Override
@Nullable
public ClassLoader getClassLoader() {
    return (this.classLoader != null ? this.classLoader : ClassUtils.getDefaultClassLoader());
}
```

#### II getResource()

ResourceLoader 中最核心的方法为 `getResource()`,它根据提供的 location 返回相应的 Resource，而 DefaultResourceLoader 对该方法提供了核心实现(它的两个子类都没有提供覆盖该方法，所以可以断定ResourceLoader 的资源加载策略就封装 DefaultResourceLoader中)，如下：

```java
public Resource getResource(String location) {
    Assert.notNull(location, "Location must not be null");
	//1. 首先通过 ProtocolResolver 来加载资源，成功返回 Resource
    for (ProtocolResolver protocolResolver : this.protocolResolvers) {
        Resource resource = protocolResolver.resolve(location, this);
        if (resource != null) {
            return resource;
        }
    }
	// 2. 若 location 以 / 开头，则调用 getResourceByPath()构造 ClassPathContextResource 类型资源并返回。
    if (location.startsWith("/")) {
        return getResourceByPath(location);
    }
    //3. 若 location 以 classpath: 开头，则构造 ClassPathResource 类型资源并返回，在构造该资源时，通过 getClassLoader()获取当前的 ClassLoader。
    else if (location.startsWith(CLASSPATH_URL_PREFIX)) {
        return new ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader());
    }
    //构造 URL
    else {
        try {
           	//构造 URL ，尝试通过它进行资源定位
            URL url = new URL(location);
            //判断是否为 FileURL , 如果是则构造 FileUrlResource 类型资源
            //否则构造 UrlResource
            return (ResourceUtils.isFileURL(url) ? new FileUrlResource(url) : new UrlResource(url));
        }
        //若在加载过程中抛出 MalformedURLException 异常，则委派 getResourceByPath() 实现资源定位加载
        catch (MalformedURLException ex) {
            return getResourceByPath(location);
        }
    }
}
```

#### III ProtocolResolver

1. ProtocolResolver ，用户自定义协议资源解决策略，作为 DefaultResourceLoader 的 SPI，它允许用户自定义资源加载协议，而不需要继承 ResourceLoader 的子类。
2. 在介绍 Resource 时，提到如果要实现自定义 Resource，我们只需要继承 DefaultResource 即可
3. 但是有了 ProtocolResolver 后，我们不需要直接继承 DefaultResourceLoader，改为实现 ProtocolResolver 接口也可以实现自定义的 ResourceLoader。
4. ProtocolResolver 接口，仅有一个方法 `Resource resolve(String location, ResourceLoader resourceLoader)`，该方法接收两个参数：资源路径location，指定的加载器 ResourceLoader，返回为相应的 Resource 。
5. 自定义的 Resolver 如何加入 Spring 体系呢？调用 `DefaultResourceLoader.addProtocolResolver()` 即可，如下：

#### IV 演示

下面示例是演示 DefaultResourceLoader 加载资源的具体策略

```java
ResourceLoader resourceLoader = new DefaultResourceLoader();

Resource fileResource1 = resourceLoader.getResource("D:/Users/chenming673/Documents/spark.txt");
System.out.println("fileResource1 is FileSystemResource:" + (fileResource1 instanceof FileSystemResource));

Resource fileResource2 = resourceLoader.getResource("/Users/chenming673/Documents/spark.txt");
System.out.println("fileResource2 is ClassPathResource:" + (fileResource2 instanceof ClassPathResource));

Resource urlResource1 = resourceLoader.getResource("file:/Users/chenming673/Documents/spark.txt");
System.out.println("urlResource1 is UrlResource:" + (urlResource1 instanceof UrlResource));

Resource urlResource2 = resourceLoader.getResource("http://www.baidu.com");
System.out.println("urlResource1 is urlResource:" + (urlResource2 instanceof  UrlResource));
```

运行结果：

```java
fileResource1 is FileSystemResource:false
fileResource2 is ClassPathResource:true
urlResource1 is UrlResource:true
urlResource1 is urlResource:true
```

其实对于 fileResource1 我们更加希望是 FileSystemResource 资源类型，但是事与愿违，它是 ClassPathResource 类型。在`getResource()`资源加载策略中，我们知道 `D:/Users/chenming673/Documents/spark.txt`资源其实在该方法中没有相应的资源类型，那么它就会在抛出 MalformedURLException 异常时通过 `getResourceByPath()` 构造一个 ClassPathResource 类型的资源。而指定有协议前缀的资源路径，则通过 URL 就可以定义，所以返回的都是UrlResource类型。

### 2.2.2 FileSystemResourceLoader

从上面的示例我们看到，其实 DefaultResourceLoader 对`getResourceByPath(String)`方法处理其实不是很恰当，这个时候我们可以使用 FileSystemResourceLoader ，它继承 DefaultResourceLoader 且覆写了 `getResourceByPath(String)`，使之从文件系统加载资源并以 FileSystemResource 类型返回，这样我们就可以得到想要的资源类型，如下：

### 2.2.3 ResourcePatternResolver

# 3. 加载Bean

## 3.1 概述

先看一段熟悉的代码：

```java
ClassPathResource resource = new ClassPathResource("bean.xml");
DefaultListableBeanFactory factory = new DefaultListableBeanFactory();
XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);
reader.loadBeanDefinitions(resource);
```

这段代码是 Spring 中编程式使用 IOC 容器，通过这四段简单的代码，我们可以初步判断 IOC 容器的使用过程。

- 获取资源
- 获取 BeanFactory
- 根据新建的 BeanFactory 创建一个BeanDefinitionReader对象，该Reader 对象为资源的解析器
- 装载资源 整个过程就分为三个步骤：资源定位、装载、注册，如下：

1. **资源定位**。我们一般用外部资源来描述 Bean 对象，所以在初始化 IOC 容器的第一步就是需要定位这个外部资源。在上一篇博客已经详细说明了资源加载的过程。
2. **装载**。装载就是 BeanDefinition 的载入。BeanDefinitionReader 读取、解析 Resource 资源，也就是将用户定义的 Bean 表示成 IOC 容器的内部数据结构：BeanDefinition。在 IOC 容器内部维护着一个 BeanDefinition Map 的数据结构，在配置文件中每一个 `<bean>` 都对应着一个BeanDefinition对象。 
3. **注册**。向IOC容器注册在第二步解析好的 BeanDefinition，这个过程是通过 BeanDefinitionRegistry 接口来实现的。在 IOC 容器内部其实是将第二个过程解析得到的 BeanDefinition 注入到一个 HashMap 容器中，IOC 容器就是通过这个 HashMap 来维护这些 BeanDefinition 的。在这里需要注意的一点是这个过程并没有完成依赖注入，依赖注册是发生在应用第一次调用 `getBean()` 向容器索要 Bean 时。当然我们可以通过设置预处理，即对某个 Bean 设置 lazyinit 属性，那么这个 Bean 的依赖注入就会在容器初始化的时候完成。 


