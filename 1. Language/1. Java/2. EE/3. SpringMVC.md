# 1. 基本介绍

软件开发三层架构：

- 表现层：负责数据展示

- 业务层：负责业务处理

- 数据层：负责数据操作

  ![](https://gitee.com/seazean/images/raw/master/Frame/SpringMVC-MVC三层架构.png)

MVC（Model View Controller），一种用于设计创建Web应用程序表现层的模式

- Model（模型）：数据模型，用于封装数据

- View（视图）：页面视图，用于展示数据

  - jsp  
  - html

* Controller（控制器）：处理用户交互的调度器，用于根据用户需求处理程序逻辑

  * Servlet
  * SpringMVC

  ![](https://gitee.com/seazean/images/raw/master/Frame/SpringMVC-MVC功能图示.png)

> 1. SpringMVC就是一个Spring。 
> 2. SpringMVC能够创建对象， 放入到容器中（SpringMVC容器）， springmvc容器中放的是控制器对象
> 3. web开发底层是servlet， springmvc中有一个对象是Servlet ： **DispatherServlet(中央调度器)**
> 4.  DispatherServlet: **负责接收用户的所有请求**， 用户把请求给了DispatherServlet， 之后DispatherServlet**把请求转发给我们的Controller对象**， 最后是Controller对象处理请求。
> 5. 

# 2. 基本配置

## 2.1 入门项目

### 2.1.1 流程分析

* 服务器启动
  1. 加载 web.xml 中 DispatcherServlet
  2. 读取 spring-mvc.xml 中的配置，加载所有 controller 包中所有标记为 bean 的类
  3. 读取 bean 中方法上方标注 @RequestMapping 的内容
* 处理请求
  1. DispatcherServlet 配置拦截所有请求 /
  2. 使用请求路径与所有加载的 @RequestMapping 的内容进行比对
  3. 执行对应的方法
  4. 根据方法的返回值在 webapp 目录中查找对应的页面并展示  

### 2.1.2 代码实现

1. pom.xml 导入坐标

```xml
<modelVersion>4.0.0</modelVersion>

<groupId>demo</groupId>
<artifactId>spring_base_config</artifactId>
<version>1.0-SNAPSHOT</version>
<packaging>war</packaging>

<properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <maven.compiler.source>1.8</maven.compiler.source>
    <maven.compiler.target>1.8</maven.compiler.target>
</properties>

<dependencies>
    <!-- servlet3.0规范的坐标 -->
    <dependency>
        <groupId>javax.servlet</groupId>
        <artifactId>javax.servlet-api</artifactId>
        <version>3.1.0</version>
        <scope>provided</scope>
    </dependency>
    <!--jsp坐标-->
    <dependency>
        <groupId>javax.servlet.jsp</groupId>
        <artifactId>jsp-api</artifactId>
        <version>2.1</version>
        <scope>provided</scope>
    </dependency>
    <!--spring的坐标-->
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-context</artifactId>
        <version>5.1.9.RELEASE</version>
    </dependency>
    <!--springmvc的坐标-->
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-webmvc</artifactId>
        <version>5.1.9.RELEASE</version>
    </dependency>
</dependencies>

<!--构建-->
<build>
    <!--设置插件-->
    <plugins>
        <!--具体的插件配置-->
        <plugin>
            <groupId>org.apache.tomcat.maven</groupId>
            <artifactId>tomcat7-maven-plugin</artifactId>
            <version>2.1</version>
            <configuration>
                <port>80</port>
                <path>/</path>
            </configuration>
        </plugin>
    </plugins>
</build>
```

2. webapp / WEB-INF / web.xml，配置SpringMVC核心控制器，请求转发到对应的具体业务处理器Controller中（等同于Servlet配置）

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"
         version="3.1">
    <!--配置Servlet-->
    <servlet>
        <servlet-name>DispatcherServlet</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <!--加载Spring控制文件-->
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>classpath*:spring-mvc.xml</param-value>
        </init-param>
    </servlet>
    <servlet-mapping>
        <servlet-name>DispatcherServlet</servlet-name>
        <url-pattern>/</url-pattern>
    </servlet-mapping>
</web-app>
```

3. resouces / spring-mvc.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/mvc 
        http://www.springframework.org/schema/mvc/spring-mvc.xsd">
    <!--扫描加载所有的控制类-->
    <context:component-scan base-package="controller"/>
</beans>
```

4. 设定具体 Controller，控制层 java / controller / UserController

```java
@Controller  //@Component衍生注解
public class UserController {
    //设定当前方法的访问映射地址，等同于Servlet在web.xml中的配置
    @RequestMapping("/save")
    //设置当前方法返回值类型为String，用于指定请求完成后跳转的页面
    public String save(){
        System.out.println("user mvc controller is running ...");
        //设定具体跳转的页面
    	return "success.jsp";
    }
}
```

## 2.2 web.xml配置

1. 配置DispatcherServlet

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"
         version="3.1">
    <!--配置Servlet-->
    <servlet>
        <servlet-name>DispatcherServlet</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <!--加载Spring控制文件-->
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>classpath*:spring-mvc.xml</param-value>
        </init-param>
    </servlet>
    <servlet-mapping>
        <servlet-name>DispatcherServlet</servlet-name>
        <url-pattern>/</url-pattern>
    </servlet-mapping>
</web-app>
```

2. 中文乱码处理 SpringMVC 提供专用的中文字符过滤器，用于处理乱码问题。

```xml
<!--乱码处理过滤器，与Servlet中使用的完全相同，差异之处在于处理器的类由Spring提供-->
<filter>
    <filter-name>CharacterEncodingFilter</filter-name>
    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
    <init-param>
        <param-name>encoding</param-name>
        <param-value>UTF-8</param-value>
    </init-param>
</filter>
<filter-mapping>
    <filter-name>CharacterEncodingFilter</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping>
```

3. listener 用于加载spring容器，详情见ssm.md

## 2.3 spring-mvc.xml配置

### 2.3.1 扫描bean

1. 扫描bean: 加入到springmvc容器中的bean是controller的

```xml
<context:component-scan base-package="com.seazean">
    <context:include-filter 
						type="annotation" 
						expression="org.springframework.stereotype.Controller"/>
</context:component-scan>

```

### 2.3.2 静态资源加载

**当你的前端控制器用了/作为url-pattern** 他就会替代tomcat中的default  导致所有的静态资源都给DispatcherServlet处理，**默认情况下**DispatcherServlet没用处理静态资源的能力，没有控制器对象能处理静态资源的访问，所以静态资源都是404。

这种情况下想要访问静态资源有两种处理方式

#### I 第一种处理方式

在spring.mvc配置文件中加入

```xml
<!--    注解驱动-->
<mvc:annotation-driven/>
<!--    处理静态资源-->
<mvc:default-servlet-handler/>
```

**原理**是：加入这个标签一行，框架会创建一个**Controller对象 **  `DefaultServletHttpRequestHandler`(类似于我们自己创建的MyController)

`DefaultServletHttpRequestHandler`这个对象可以把接受的请求转发给tomcat的default这个servlet

**注意**：这个需要和<mvc:annotation-driven/>搭配使用，来解决<mvc:default-servlet-handler/>和@RequestMapping的冲突

不加的话 所有的请求就都给了tomcat的default

#### II 第二种处理方式

```xml
<mvc:resources mapping="/static/**" location="/static/"/>
```

加入后框架会创建ResourceHttpRequestHandler这个处理器对象

让这个对象处理静态资源的访问，不依赖于tomcat服务器

mapping:访问静态资源的url地址，使用通配符**

location:静态资源在你的项目中的目录位置

这个同样与@RequestMapping有冲突要加 mvc:annotation-driven/

### 2.3.3 视图解析器

3. 视图解析器

```xml
<bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
    <property name="prefix" value="/WEB-INF/view/"/>
    <property name="suffix" value=".jsp"/>
</bean>
```

## 2.4 请求映射

名称：@RequestMapping

类型：方法注解、类注解

位置：处理器类中的方法定义上方、处理器类定义上方

### 2.4.1 作用在方法上

作用：绑定请求地址与对应处理方法间的关系

无类映射地址访问格式： http://localhost/requestURL2

```java
@Controller
public class UserController {
    @RequestMapping("/requestURL2")
    public String requestURL2() {
        return "page.jsp";
    }
}
```

### 2.4.2 作用在类上

作用：为当前处理器中所有方法设定公共的访问路径前缀

带有类映射地址访问格式，将类映射地址作为前缀添加在实际映射地址前面：**/user/requestURL1**

最终返回的页面如果未设定绝对访问路径，将从类映射地址所在目录中查找 **webapp/user/page.jsp**

```java
@Controller
@RequestMapping("/user")
public class UserController {
    @RequestMapping("/requestURL2")
    public String requestURL2() {
        return "page.jsp";
    }
} 
```

### 2.4.3 常用属性

```java
@RequestMapping(
    value="/requestURL3", //设定请求路径，与path属性、 value属性相同
    method = RequestMethod.GET, //设定请求方式
    params = "name", //设定请求参数条件
    headers = "content-type=text/*", //设定请求消息头条件
    consumes = "text/*", //用于指定可以接收的请求正文类型（MIME类型）
    produces = "text/*" //用于指定可以生成的响应正文类型（MIME类型）
)
public String requestURL3() {
    return "/page.jsp";
}
```



# 3. 基本操作

## 3.1 请求处理

如果不适用@RequestParam的话，**处理器方法的形参名和请求中参数名必须一样** 。

本质过程:	 ![image-20210405001738213](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/image-20210405001738213.png)

### 3.1.1 普通类型

SpringMVC 将传递的参数封装到处理器方法的形参中，达到快速访问参数的目的

* 访问 URL：http://localhost/requestParam1?name=seazean&age=14  

  ```java
  @Controller
  public class UserController {
      @RequestMapping("/requestParam1")
      public String requestParam1(String name ,int age){
          System.out.println("name=" + name + ",age=" + age);
          return "page.jsp";
      }
  }
  ```

  ```jsp
  <%@page pageEncoding="UTF-8" language="java" contentType="text/html;UTF-8" %>
  <html>
  <body>
  	<h1>请求参数测试页面</h1>
  </body>
  </html>
  ```

@RequestParam 的使用：

* 类型：形参注解

* 位置：处理器类中的方法形参前方

* 作用：绑定请求参数与对应处理方法形参间的关系 

* 访问 URL：http://localhost/requestParam2?userName=Jock

  ```java
  @RequestMapping("/requestParam2")
  public String requestParam2(@RequestParam(
                              name = "userName",
                              required = true,	//为true代表必须有参数
                              defaultValue = "s") String name){
      System.out.println("name=" + name);
      return "page.jsp";
  }
  ```

### 3.1.2 POJO类型

#### I 简单类型

当 POJO 中使用简单类型属性时， 参数名称与 POJO 类属性名保持一致  

* 访问 URL： http://localhost/requestParam3?name=seazean&age=14  

  ```java
  @RequestMapping("/requestParam3")
  public String requestParam3(User user){
      System.out.println("name=" + user.getName());
      return "page.jsp";
  }
  ```

  ```java
  public class User {
      private String name;
      private Integer age;
      //......
  }
  ```

> 属性名和请求中的参数要一样，并且需要有set/get方法

#### II 参数冲突

当 POJO 类型属性与其他形参出现同名问题时，将被**同时赋值**，建议使用 @RequestParam 注解进行区分

* 访问 URL： http://localhost/requestParam4?name=seazean&age=14  

  ```java
  @RequestMapping("/requestParam4")
  public String requestParam4(User user, String age){
      System.out.println("user.age=" + user.getAge() + ",age=" + age);//14 14 
      return "page.jsp";
  }
  ```

#### III 复杂类型

当 POJO 中出现对象属性时，参数名称与对象层次结构名称保持一致  

* 访问 URL： http://localhost/requestParam5?address.province=beijing  

  ```java
  @RequestMapping("/requestParam5")
  public String requestParam5(User user){
      System.out.println("user.address=" + user.getAddress().getProvince());
      return "page.jsp";
  }
  ```

  ```java
  public class User {
      private String name;
      private Integer age;
      private Address address; //....
  }
  ```

  ```java
  public class Address {
      private String province;
      private String city;
      private String address;
  }
  ```

#### IV 容器类型

POJO 中出现集合类型的处理方式

* 通过 URL 地址中同名参数，可以为 POJO 中的集合属性进行赋值，集合属性要求保存简单数据

  访问 URL：http://localhost/requestParam6?nick=Jock1&nick=Jockme&nick=zahc

  ```java
  @RequestMapping("/requestParam6")
  public String requestParam6(User user){
      System.out.println("user=" + user);
      //user = User{name='null',age=null,nick={Jock1,Jockme,zahc}}
      return "page.jsp";
  }
  ```

  ```java
  public class User {
      private String name;
      private Integer age;
      private List<String> nick;
  }
  ```

* POJO 中出现 List 保存对象数据，参数名称与对象层次结构名称保持一致，使用数组格式描述集合中对象的位置访问 URL：http://localhost/requestParam7?addresses[0].province=bj&addresses[1].province=tj  

  ```java
  @RequestMapping("/requestParam7")
  public String requestParam7(User user){
      System.out.println("user.addresses=" + user.getAddress());
      //{Address{provice=bj,city='null',address='null'}},{Address{....}}
      return "page.jsp";
  }
  ```

  ```java
  public class User {
      private String name;
      private Integer age;
      private List<Address> addresses;
  }
  ```

* POJO 中出现 Map 保存对象数据，参数名称与对象层次结构名称保持一致，使用映射格式描述集合中对象位置

  URL: http://localhost/requestParam8?addressMap[’home’].province=bj&addressMap[’job’].province=tj  

  ```java
  @RequestMapping("/requestParam8")
  public String requestParam8(User user){
      System.out.println("user.addressMap=" + user.getAddressMap());
      //user.addressMap={home=Address{p=,c=,a=},job=Address{....}}
      return "page.jsp";
  }
  ```

  ```java
  public class User {
      private Map<String,Address> addressMap;
      //....
  }
  ```

### 3.1.3 数组集合

#### I 数组类型

请求参数名与处理器方法形参名保持一致，且请求参数数量＞ 1个  

* 访问 URL： http://localhost/requestParam9?nick=Jockme&nick=zahc  

  ```java
  @RequestMapping("/requestParam9")
  public String requestParam9(String[] nick){
      System.out.println(nick[0] + "," + nick[1]);
      return "page.jsp";
  }
  ```

#### II 集合类型

保存简单类型数据，请求参数名与处理器方法形参名保持一致，且请求参数数量＞ 1个

* 访问 URL： http://localhost/requestParam10?nick=Jockme&nick=zahc

  ```java
  @RequestMapping("/requestParam10")
  public String requestParam10(@RequestParam("nick") List<String> nick){
      System.out.println(nick);
      return "page.jsp";
  }
  ```

* 注意： SpringMVC 默认将 List 作为对象处理，赋值前先创建对象，然后将 nick **作为对象的属性**进行处理。List 是接口无法创建对象，报无法找到构造方法异常；修复类型为可创建对象的 ArrayList 类型后，对象可以创建但没有 nick 属性，因此数据为空
  解决方法：需要告知 SpringMVC 的处理器 nick 是一组数据，而不是一个单一属性。通过 @RequestParam 注解，将数量大于 1 个 names 参数打包成参数数组后， SpringMVC 才能识别该数据格式，并判定形参类型是否为数组或集合，并按数组或集合对象的形式操作数据

### 3.1.4 转换器

#### I 类型

开启转换配置：`<mvc:annotation-driven />  `
作用：提供 Controller 请求转发，Json 自动转换等功能

如果访问 URL：http://localhost/requestParam1?name=seazean&age=seazean，会出现报错，类型转化异常

```java
@RequestMapping("/requestParam1")
public String requestParam1(String name ,int age){
    System.out.println("name=" + name + ",age=" + age);
    return "page.jsp";
}
```

SpringMVC 对接收的数据进行自动类型转换，该工作通过 Converter 接口实现：

* **标量转换器**
  StringToBooleanConverter String → Boolean
  ObjectToStringConverter Object → String
  StringToNumberConverterFactory String → Number（ Integer、 Long 等）
  NumberToNumberConverterFactory Number子类型之间（Integer、 Long、 Double 等）
  StringToCharacterConverter String → java.lang.Character
  NumberToCharacterConverter Number子类型（Integer、 Long、 Double 等）→ java.lang.Character
  CharacterToNumberFactory java.lang.Character → Number子类型（Integer、Long、Double 等）
  StringToEnumConverterFactory String → enum类型
  EnumToStringConverter enum类型 → String
  StringToLocaleConverter String → java.util.Local
  PropertiesToStringConverter java.util.Properties → String
  StringToPropertiesConverter String → java.util.Properties  
* **集合、数组相关转换器**
  ArrayToCollectionConverter 数组 → 集合（ List、 Set）
  CollectionToArrayConverter 集合（ List、 Set） →数组
  ArrayToArrayConverter 数组间
  CollectionToCollectionConverter 集合间（ List、 Set）
  MapToMapConverter Map间
  ArrayToStringConverter 数组→String类型
  StringToArrayConverter String →数组， trim后使用“,”split
  ArrayToObjectConverter 数组 → Object
  ObjectToArrayConverter Object → 单元素数组
  CollectionToStringConverter 集合（ List、 Set） →String
  StringToCollectionConverter String → 集合（ List、 Set）， trim后使用“,”split
  CollectionToObjectConverter 集合 → Object
  ObjectToCollectionConverter Object → 单元素集合  
* **默认转换器**
  ObjectToObjectConverter Object间
  IdToEntityConverter Id → Entity

   FallbackObjectToStringConverter Object → String  

#### II 日期

![](https://gitee.com/seazean/images/raw/master/Frame/SpringMVC-date数据类型转换.png)

如果访问 URL：http://localhost/requestParam11?date=1999-09-09 会报错，所以需要日期类型转换

* 声明自定义的转换格式并覆盖系统转换格式，配置 resources / spring-mvc.xml

  ```xml
  <!--5.启用自定义Converter-->
  <mvc:annotation-driven conversion-service="conversionService"/>
  <!--1.设定格式类型Converter，注册为Bean，受SpringMVC管理-->
  <bean id="conversionService" class="org.springframework.format.support.FormattingConversionServiceFactoryBean">
      <!--2.自定义Converter格式类型设定，该设定使用的是同类型覆盖的思想-->
      <property name="formatters">
          <!--3.使用set保障相同类型的转换器仅保留一个，避免冲突-->
          <set>
              <!--4.设置具体的格式类型-->
              <bean class="org.springframework.format.datetime.DateFormatter">
                  <!--5.类型规则-->
                  <property name="pattern" value="yyyy-MM-dd"/>
              </bean>
          </set>
      </property>
  </bean>
  ```

* @DateTimeFormat
  类型：形参注解、成员变量注解
  位置：形参前面 或 成员变量上方
  作用：为当前参数或变量指定类型转换规则

  ```java
  public String requestParam12(@DateTimeFormat(pattern = "yyyy-MM-dd") Date date){
      System.out.println("date=" + date);
      return "page.jsp";
  }
  ```

  ```java
  @DateTimeFormat(pattern = "yyyy-MM-dd")
  private Date date;
  ```

  依赖注解驱动支持，xml 开启配置：

  ```xml
  <mvc:annotation-driven />  
  ```

#### III 自定义

自定义类型转换器，实现 Converter 接口或者直接容器中注入：

* 方式一：

  ```java
  public class WebConfig implements WebMvcConfigurer {
      @Bean
      public WebMvcConfigurer webMvcConfigurer() {
          return new WebMvcConfigurer() {
              @Override
              public void addFormatters(FormatterRegistry registry) {
                  registry.addConverter(new Converter<String, Date>() {
                      @Override
                      public Pet convert(String source) {
                      	DateFormat df = new SimpleDateFormat("yyyy-MM-dd");
                          Date date = null;
                          //类型转换器无法预计使用过程中出现的异常，因此必须在类型转换器内部捕获，
                          //不允许抛出，框架无法预计此类异常如何处理
                          try {
                              date = df.parse(source);
                          } catch (ParseException e) {
                              e.printStackTrace();
                          }
                          return date;
                      }
                  });
          }
      }
  }
  ```

* 方式二：

  ```java
  //本例中的泛型填写的是String，Date，最终出现字符串转日期时，该类型转换器生效
  public class MyDateConverter implements Converter<String, Date> {
      //重写接口的抽象方法，参数由泛型决定
      public Date convert(String source) {
          DateFormat df = new SimpleDateFormat("yyyy-MM-dd");
          Date date = null;
          //类型转换器无法预计使用过程中出现的异常，因此必须在类型转换器内部捕获，
          //不允许抛出，框架无法预计此类异常如何处理
          try {
              date = df.parse(source);
          } catch (ParseException e) {
              e.printStackTrace();
          }
          return date;
      }
  }
  ```

  配置 resources / spring-mvc.xml，注册自定义转换器，将功能加入到 SpringMVC 转换服务 ConverterService 中

  ```xml
  <!--1.将自定义Converter注册为Bean，受SpringMVC管理-->
  <bean id="myDateConverter" class="converter.MyDateConverter"/>
  <!--2.设定自定义Converter服务bean-->
  <bean id="conversionService"
        class="org.springframework.context.support.ConversionServiceFactoryBean">
      <!--3.注入所有的自定义Converter，该设定使用的是同类型覆盖的思想-->
      <property name="converters">
          <!--4.set保障同类型转换器仅保留一个，去重规则以Converter<S,T>的泛型为准-->
          <set>
              <!--5.具体的类型转换器-->
              <ref bean="myDateConverter"/>
          </set>
      </property>
  </bean>
  
  <!--开启注解驱动，加载自定义格式化转换器对应的类型转换服务-->
  <mvc:annotation-driven conversion-service="conversionService"/>
  ```

* 使用转换器

  ```java
  @RequestMapping("/requestParam12")
  public String requestParam12(Date date){
      System.out.println(date);
      return "page.jsp";
  }
  ```


### 3.1.5 解决请求参数中文乱码

在提交请求参数时，get请求中文没用乱码，使用post 中文有乱码。

需要使用过滤器处理乱码问题 

**在web.xml中配置**

```xml
<filter>
    <filter-name>characterEncodingFilter</filter-name>
    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
    <!--    设置项目中使用的字符编码-->
    <init-param>
        <param-name>encoding</param-name>
        <param-value>utf-8</param-value>
    </init-param>
    <!--    强制请求对象使用encoding编码的值-->
    <init-param>
        <param-name>forceRequestEncoding</param-name>
        <param-value>true</param-value>
    </init-param>
    <!--    强制响应对象使用encoding编码的值-->
    <init-param>
        <param-name>forceResponseEncoding</param-name>
        <param-value>true</param-value>
    </init-param>
</filter>

<filter-mapping>
    <filter-name>characterEncodingFilter</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping>
```

## 3.2 响应处理

处理器的返回值有四大类

- ModelAdnView
- String
- void
- Object

### 3.2.1 ModelAndView

Model用来接受数据相当于 		   

```java
request.setAttribute("asd","asdasdasd");
```

View用来跳转到其他资源 相当于

```java
req.getRequestDispatcher("/login.jsp").forward(xxx,xxx);
```

### 3.2.2 String

#### I 普通

返回值是字符串 用于 **只进行跳转但是不传递数据**

String: 表示视图，可以是逻辑名词，也可以是完整视图路径

```java
@RequestMapping("/view.dao")
public String getView(){
    System.out.println("进行逻辑视图转化");
    return "login";
}
```

因为我们配置了视图解析器 所以会跳转到**\WEB-INF\view\login.jsp**

**注**：

> 如果想在返回值为String的情况下传递数据,那就使用request.setAttribute 那么就可以传递数据

#### II 请求转发

```java
@Controller
public class UserController {
    @RequestMapping("/showPage1")
	public String showPage1() {
   	 	System.out.println("user mvc controller is running ...");
    	return "forward:/WEB-INF/page/page.jsp;
	}
}
```

#### III 请求重定向

```java
@RequestMapping("/showPage2")
public String showPage2() {
    System.out.println("user mvc controller is running ...");
    return "redirect:/WEB-INF/page/page.jsp";//不能访问WEB-INF下的资源
}
```

### 3.2.3 void

不能表示数据，也不能表示视图

**适合ajax请求** 通过Resonse 输出数据 响应ajax请求

![image-20210405110139024](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/image-20210405110139024.png)

### 3.2.4 Object

这个Object可以是Integer String 自定义对象 Map List等

但返回的对象不是作为逻辑视图出现的，而是**作为直接在页面显示的数据出现的**

> 返回对象，需要使用@ResponseBody注解
>
> 1. 将 Controller 的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到 Response 的 body 区
> 2. 如果返回值是字符串，那么直接将字符串返回客户端；
> 3. 如果是一个对象，会**将对象转化为 Json**，返回客户端

---

现在作ajax，主要使用json的数据格式，实现步骤

1. 加入处理json的工具库的依赖，springmvc默认使用的jackson

2. 在springmvc配置文件中加入注解驱动   <mvc:annotation-driven> 

   这个注解驱动实现的功能是 **完成java对象到json,xml.text,二进制数据格式的转换**

   类似于以下操作

   ![image-20210405110213183](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/image-20210405110213183.png) 

3. 在处理器方法的上面加上@ResponseBody

   相当于完成以下操作  **通过HttpServletResponse将json数据输出到浏览器**

![image-20210405110306327](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/image-20210405110306327.png)

## 3.3 Restful

代码实现：

* restful.jsp：

  * Get请求和POST请求直接设置method为get或post就行了
  * put和delete请求需要设置method为post，并且页面表单**使用隐藏域提交请求类型**，参数名称固定为 _method，value为请求方式
  
  ```html
  <h1>restful风格请求表单</h1>
  <!--切换请求路径为restful风格-->
  <form action="/user" method="post">
  	<!--一隐藏域，切换为PUT请求或DELETE请求，但是form表单的提交方式method属性必须填写post-->
  	<input name="_method" type="hidden" value="PUT"/>
  	<input value="REST-PUT 提交" type="submit"/>
  </form>
  ```
  
* java / controller / UserController

  ```java
  @RestController				//设置rest风格的控制器
  @RequestMapping("/user/")	//设置公共访问路径，配合下方访问路径使用
  public class UserController {
      @GetMapping("/user")
      //@RequestMapping(value = "/user",method = RequestMethod.GET)
      public String getUser(){
          return "GET-张三";
      }
  
      @PostMapping("/user")
      //@RequestMapping(value = "/user",method = RequestMethod.POST)
      public String saveUser(){
          return "POST-张三";
      }
  
      @PutMapping("/user")
      //@RequestMapping(value = "/user",method = RequestMethod.PUT)
      public String putUser(){
          return "PUT-张三";
      }
  
      @DeleteMapping("/user")
      //@RequestMapping(value = "/user",method = RequestMethod.DELETE)
      public String deleteUser(){
          return "DELETE-张三";
      }
  }
  ```

* 配置拦截器 web.xml

  ```xml
  <!--配置拦截器，解析请求中的参数_method，否则无法发起PUT请求与DELETE请求，配合页面表单使用-->
  <filter>
      <filter-name>HiddenHttpMethodFilter</filter-name>
      <filter-class>org.springframework.web.filter.HiddenHttpMethodFilter</filter-class>
  </filter>
  <filter-mapping>
      <filter-name>HiddenHttpMethodFilter</filter-name>
      <servlet-name>DispatcherServlet</servlet-name>
  </filter-mapping>
  ```

### 3.3.3 参数注解

Restful 开发中的参数注解

```java
@GetMapping("{id}")
public String getMessage(@PathVariable("id") Integer id){
}
```

使用 @PathVariable 注解获取路径上配置的具名变量，一般在有多个参数的时候添加

其他注解：

* @RequestHeader：获取请求头
* @RequestParam：获取请求参数（指问号后的参数，url?a=1&b=2）
* @CookieValue：获取 Cookie 值
* @RequestAttribute：获取 request 域属性
* @RequestBody：获取请求体 [POST]
* @MatrixVariable：矩阵变量
* @ModelAttribute：自定义类型变量

```java
@RestController	
@RequestMapping("/user/")
public class UserController {
    //rest风格访问路径简化书写方式，配合类注解@RequestMapping使用
    @RequestMapping("{id}")
    public String restLocation2(@PathVariable Integer id){
        System.out.println("restful is running ....get:" + id);
        return "success.jsp";
    }

    //@RequestMapping(value = "{id}",method = RequestMethod.GET)
    @GetMapping("{id}")
    public String get(@PathVariable Integer id){
        System.out.println("restful is running ....get:" + id);
        return "success.jsp";
    }

    @PostMapping("{id}")
    public String post(@PathVariable Integer id){
        System.out.println("restful is running ....post:" + id);
        return "success.jsp";
    }

    @PutMapping("{id}")
    public String put(@PathVariable Integer id){
        System.out.println("restful is running ....put:" + id);
        return "success.jsp";
    }

    @DeleteMapping("{id}")
    public String delete(@PathVariable Integer id){
        System.out.println("restful is running ....delete:" + id);
        return "success.jsp";
    }
}
```

## 3.4 Servlet

SpringMVC 提供访问原始 Servlet 接口的功能

* SpringMVC 提供访问原始 Servlet 接口 API 的功能，通过形参声明即可 

  ```java
  @RequestMapping("/servletApi")
  public String servletApi(HttpServletRequest request,
                           HttpServletResponse response, HttpSession session){
      System.out.println(request);
      System.out.println(response);
      System.out.println(session);
      request.setAttribute("name","seazean");
      System.out.println(request.getAttribute("name"));
      return "page.jsp";
  }
  ```

* Head 数据获取快捷操作方式
  名称：@RequestHeader
  类型：形参注解
  位置：处理器类中的方法形参前方
  作用：绑定请求头数据与对应处理方法形参间的关系
  范例：

  ```java
  快捷操作方式@RequestMapping("/headApi")
  public String headApi(@RequestHeader("Accept-Language") String headMsg){
      System.out.println(headMsg);
      return "page";
  }  
  ```

* Cookie 数据获取快捷操作方式
  名称：@CookieValue
  类型：形参注解
  位置：处理器类中的方法形参前方
  作用：绑定请求 Cookie 数据与对应处理方法形参间的关系
  范例：

  ```java
  @RequestMapping("/cookieApi")
  public String cookieApi(@CookieValue("JSESSIONID") String jsessionid){
      System.out.println(jsessionid);
      return "page";
  }  
  ```

* Session 数据获取
  名称：@SessionAttribute
  类型：形参注解
  位置：处理器类中的方法形参前方
  作用：绑定请求Session数据与对应处理方法形参间的关系
  范例：

  ```java
  @RequestMapping("/sessionApi")
  public String sessionApi(@SessionAttribute("name") String name){
      System.out.println(name);
      return "page.jsp";
  }
  //用于在session中放入数据
  @RequestMapping("/setSessionData")
  public String setSessionData(HttpSession session){
      session.setAttribute("name","seazean");
      return "page";
  }
  ```

* Session 数据设置
  名称：@SessionAttributes
  类型：类注解
  位置：处理器类上方
  作用：声明放入session范围的变量名称，适用于Model类型数据传参
  范例：

  ```java
  @Controller
  //设定当前类中名称为age和gender的变量放入session范围，不常用
  @SessionAttributes(names = {"age","gender"})
  public class ServletController {
  	//将数据放入session存储范围，Model对象实现数据set，@SessionAttributes注解实现范围设定
      @RequestMapping("/setSessionData2")
      public String setSessionDate2(Model model) {
          model.addAttribute("age",39);
          model.addAttribute("gender","男");
          return "page";
      }
      
      @RequestMapping("/sessionApi")
      public String sessionApi(@SessionAttribute("age") int age,
                               @SessionAttribute("gender") String gender){
          System.out.println(name);
          System.out.println(age);
          return "page";
      }
  }  
  ```


## 3.5 路径问题

### 3.5.2 /问题

1. 加不加斜杠都是相对路径
2. 对于前端路径：
   1. 不加斜杠，结果为 当前路径的url + 你所给的路径
   2. 加上斜杠，结果为 web服务器的根路径(**http:ip:port**) + 你说给的路径
3. 对于后端路径：
   1. 不加斜杠，结果为 当前路径的url + 你所给的路径
   2. 加上斜杠，结果为 web应用的根路径 + 你所给的路径

> 前台路径：出现在html文件，及jsp文件的静态部分中一斜杠开头的相对路径。前台路径的解析者是浏览器。
>
> 后台路径：出现在java代码、xml、jsp文件中动态部分等。后台路径解析者是服务器。
>
> 例如：http://localhost:8081/SpringMVC/xxx/some.do
>
> http://localhost:8081当前web服务器的根
>
> http://localhost:8081/SpringMVC当前web应用的根
>
> http://localhost:8081/SpringMVC/xxx是资源路径

### 3.5.1 base

对于不加/的相对路径 可能会存在问题，所以使用base标签比较稳妥。

表示当前页面中访问地址的基地址

你的页面中所有 **没用  / 开头的** 地址，都是以base标签中的地址为参考地址

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>
<%
    String path = request.getContextPath();
    //basePath值为 http://localhost:8080/bookshop/
    String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path+"/";
%>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
    <!-- 在head标签中添加base标签 -->
    <!-- 使用网站的完整URL作为相对路径的参考基准 -->
    <base href="<%=basePath%>">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>jsp页面</title>
</head>
<body>
    
</body>
</html>
```

# 4. 运行原理

## 4.1 技术架构

### 4.1.1 组件介绍

1. DispatcherServlet：核心控制器， 是 SpringMVC 的核心，整体流程控制的中心，所有的请求第一步都先到达这里，由其调用其它组件处理用户的请求，它就是在 web.xml 配置的核心 Servlet，有效的降低了组件间的耦合性
2. HandlerMapping：处理器映射器， 负责根据请求找到对应具体的 Handler 处理器，SpringMVC 中针对配置文件方式、注解方式等提供了不同的映射器来处理，总共有5个，常见的有`RequestMappingHandlerMapping`.
3. Handler：处理器，其实就是 Controller，业务处理的核心类，通常由开发者编写，并且必须遵守 Controller 开发的规则，这样适配器才能正确的执行。例如实现 Controller 接口，将 Controller 注册到 IOC 容器中等
4. HandlAdapter：处理器适配器，根据映射器中找到的 Handler，通过 HandlerAdapter 去执行 Handler，这是适配器模式的应用
5. View Resolver：视图解析器， 将 Handler 中返回的逻辑视图（ModelAndView）解析为一个具体的视图（View）对象
6. View：视图， View 最后对页面进行渲染将结果返回给用户。SpringMVC 框架提供了很多的 View 视图类型，包括：jstlView、freemarkerView、pdfView 等

![image-20211127105221899](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/image-20211127105221899.png)

### 4.1.2 工作原理

在 Spring 容器初始化时会建立所有的 URL 和 Controller 的对应关系，保存到 Map<URL, Controller> 中，这样 request 就能快速根据 URL 定位到 Controller：

* 在 Spring IOC 容器初始化完所有单例 bean 后
* SpringMVC 会遍历所有的 bean，获取 controller 中对应的 URL（这里获取 URL 的实现类有多个，用于处理不同形式配置的 Controller）
* 将每一个 URL 对应一个 controller 存入 Map<URL, Controller> 中(也就是对应的 HandlerMapping 中)

**一个 Request 来了：**

* 监听端口，获得请求：Tomcat 监听 8080 端口的请求处理，根据路径调用了 web.xml 中配置的核心控制器 DispatcherServlet，`DispatcherServlet#doDispatch` 是**核心调度方法**
* **首先根据 URI 获取 HandlerMapping 处理器映射器**，RequestMappingHandlerMapping 用来处理 @RequestMapping 注解的映射规则，`其中保存了所有url 和 被@RequestMapping注解的handler 的映射规则`，最后包装成一个`拦截器链`返回，拦截器链对象持有 HandlerMapping。如果没有合适的处理请求的 HandlerMapping，说明请求处理失败，设置响应码 404 返回
* 根据映射器获取当前 handler，**处理器适配器执行处理方法**，适配器根据请求的 URL 去 handler 中寻找对应的处理方法：
  * 创建 ModelAndViewContainer (mav) 对象，用来填充数据，然后通过不同的**参数**解析器去解析 URL 中的参数，完成数据解析绑定，然后执行真正的 Controller 方法，完成 handle 处理
  * 方法执行完对**返回值**进行处理，没添加 @ResponseBody 注解的返回值使用视图处理器处理，把视图名称设置进入 mav 中
  * 对添加了 @ResponseBody 注解的 Controller 的按照普通的返回值进行处理，首先进行内容协商，找到一种浏览器可以接受（请求头 Accept）的并且服务器可以生成的数据类型，选择合适数据转换器，设置响应头中的数据类型，然后写出数据.
  * 最后把 ModelAndViewContainer 和 ModelMap 中的数据**封装到 ModelAndView 对象**返回
* **视图解析**，根据返回值创建视图，请求转发 View 实例为 InternalResourceView，重定向 View 实例为 RedirectView。最后调用 view.render 进行页面渲染，结果派发
  * 请求转发时请求域中的数据不丢失，会把 ModelAndView 的数据设置到请求域中，获取 Servlet 原生的 RequestDispatcher，调用 `RequestDispatcher#forward` 实现转发
  * 重定向会造成请求域中的数据丢失，使用 Servlet 原生方式实现重定向 `HttpServletResponse#sendRedirect`

## 4.2 调度函数

请求进入原生的 HttpServlet 的 doGet() 方法处理，调用子类 FrameworkServlet 的 doGet() 方法，最终调用 DispatcherServlet 的 doService() 方法，为请求设置相关属性后调用 doDispatch()，请求和响应的以参数的形式传入

![](https://gitee.com/seazean/images/raw/master/Frame/SpringMVC-请求相应的原理.png)

```java
// request 和 response 为 Java 原生的类
protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {
    HttpServletRequest processedRequest = request;
    HandlerExecutionChain mappedHandler = null;
    // 文件上传请求
    boolean multipartRequestParsed = false;
    // 异步管理器
    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);

    try {
        ModelAndView mv = null;
        Exception dispatchException = null;

        try {
            // 文件上传相关请求
            processedRequest = checkMultipart(request);
            multipartRequestParsed = (processedRequest != request);

            // 找到当前请求使用哪个 HandlerMapping （Controller 的方法）处理，返回执行链
            mappedHandler = getHandler(processedRequest);
            // 没有合适的处理请求的方式 HandlerMapping，请求失败，直接返回 404
            if (mappedHandler == null) {
                noHandlerFound(processedRequest, response);
                return;
            }

            // 根据映射器获取当前 handler 处理器适配器，用来【处理当前的请求】
            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());
            // 获取发出此次请求的方式
            String method = request.getMethod();
            // 判断请求是不是 GET 方法
            boolean isGet = HttpMethod.GET.matches(method);
            if (isGet || HttpMethod.HEAD.matches(method)) {
                long lastModified = ha.getLastModified(request, mappedHandler.getHandler());
                if (new ServletWebRequest(request, response).checkNotModified(lastModified) && isGet) {
                    return;
                }
            }
			// 拦截器链的前置处理
            if (!mappedHandler.applyPreHandle(processedRequest, response)) {
                return;
            }
            // 执行处理方法，返回的是 ModelAndView 对象，封装了所有的返回值数据
            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());

            if (asyncManager.isConcurrentHandlingStarted()) {
                return;
            }
			// 设置视图名字
            applyDefaultViewName(processedRequest, mv);
            // 执行拦截器链中的后置处理方法
            mappedHandler.applyPostHandle(processedRequest, response, mv);
        } catch (Exception ex) {
            dispatchException = ex;
        }
        
        // 处理程序调用的结果，进行结果派发
        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);
    }
    //....
}
```

## 4.3 请求映射

### 4.3.1 映射器

doDispatch() 中调用 getHandler 方法获取`HandlerExecutionChain`（处理器链）.

总体流程：

* 所有的请求映射都在 HandlerMapping 中，**RequestMappingHandlerMapping 处理 @RequestMapping 注解的映射规则**

* 遍历所有的 HandlerMapping 看是否可以匹配当前请求，匹配成功后返回然后handler被包装为一个拦截链，匹配失败设置 HTTP 404 响应码
* 用户可以自定义的映射处理，也可以给容器中放入自定义 HandlerMapping

访问 URL：http://localhost:8080/user

```java
@GetMapping("/user")
public String getUser(){
    return "GET";
}
@PostMapping("/user")
public String postUser(){
    return "POST";
}
//。。。。。
```

会调用doDispatcher的getHandler方法

```java
//HandlerMapping 处理器映射器，**保存了所有 `@RequestMapping`  和 `handler` 的映射规则**
protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {
    if (this.handlerMappings != null) {
        // 遍历所有的 HandlerMapping
        for (HandlerMapping mapping : this.handlerMappings) {
            // 尝试去每个 HandlerMapping 中匹配当前请求的处理
            HandlerExecutionChain handler = mapping.getHandler(request);
            if (handler != null) {
                return handler;
            }
        }
    }
    return null;
}
```

`mapping.getHandler(request)`：调用 AbstractHandlerMapping#getHandler

* `Object handler = getHandlerInternal(request)`：获取映射器，底层调用 RequestMappingInfoHandlerMapping 类的方法，又调用 AbstractHandlerMethodMapping#getHandlerInternal
* `executionChain = getHandlerExecutionChain(handler, request)`：**为当前请求和映射器的构建一个拦截器链**
  * `for (HandlerInterceptor interceptor : this.adaptedInterceptors)`：遍历所有的拦截器
  * `chain.addInterceptor(interceptor)`：把所有的拦截器添加到 HandlerExecutionChain 中，形成拦截器链
* `return executionChain`：**返回拦截器链，HandlerMapping 是链的成员属性**

```java
@Nullable
protected HandlerMethod getHandlerInternal(HttpServletRequest request) throws Exception {
    //地址栏的 uri，这里的 lookupPath 为 /user
    String lookupPath = this.initLookupPath(request);
    //加读锁防止并发
    this.mappingRegistry.acquireReadLock();

    HandlerMethod var4;
    try {
        //获取当前 HandlerMapping 中的映射规则
        HandlerMethod handlerMethod = this.lookupHandlerMethod(lookupPath, request);
        var4 = handlerMethod != null ? handlerMethod.createWithResolvedBean() : null;
    } finally {
        this.mappingRegistry.releaseReadLock();
    }

    return var4;
}
```

```java
@Nullable
protected HandlerMethod lookupHandlerMethod(String lookupPath, HttpServletRequest request) throws Exception {
    List<AbstractHandlerMethodMapping<T>.Match> matches = new ArrayList();
    //获取当前的映射器与当前请求的 URI 有关的所有映射规则，
    List<T> directPathMatches = this.mappingRegistry.getMappingsByDirectPath(lookupPath);
    if (directPathMatches != null) {
        //将匹配的结果放入到mathces中
        this.addMatchingMappings(directPathMatches, matches, request);
    }

    if (matches.isEmpty()) {
        this.addMatchingMappings(this.mappingRegistry.getRegistrations().keySet(), matches, request);
    }

    if (matches.isEmpty()) {
        return this.handleNoMatch(this.mappingRegistry.getRegistrations().keySet(), lookupPath, request);
    } else {
        AbstractHandlerMethodMapping<T>.Match bestMatch = (AbstractHandlerMethodMapping.Match)matches.get(0);
        //当有多个映射规则符合请求时，报错
        if (matches.size() > 1) {

            Comparator<AbstractHandlerMethodMapping<T>.Match> comparator = new AbstractHandlerMethodMapping.MatchComparator(this.getMappingComparator(request));
 		    //匹配集合进行排序
            matches.sort(comparator);
            bestMatch = (AbstractHandlerMethodMapping.Match)matches.get(0);
            if (this.logger.isTraceEnabled()) {
                this.logger.trace(matches.size() + " matching mappings: " + matches);
            }

            if (CorsUtils.isPreFlightRequest(request)) {
                Iterator var7 = matches.iterator();

                while(var7.hasNext()) {
                    AbstractHandlerMethodMapping<T>.Match match = (AbstractHandlerMethodMapping.Match)var7.next();
                    if (match.hasCorsConfig()) {
                        return PREFLIGHT_AMBIGUOUS_MATCH;
                    }
                }
            } else {
                AbstractHandlerMethodMapping<T>.Match secondBestMatch = (AbstractHandlerMethodMapping.Match)matches.get(1);
                if (comparator.compare(bestMatch, secondBestMatch) == 0) {
                    Method m1 = bestMatch.getHandlerMethod().getMethod();
                    Method m2 = secondBestMatch.getHandlerMethod().getMethod();
                    String uri = request.getRequestURI();
                    throw new IllegalStateException("Ambiguous handler methods mapped for '" + uri + "': {" + m1 + ", " + m2 + "}");
                }
            }
        }

        request.setAttribute(BEST_MATCHING_HANDLER_ATTRIBUTE, bestMatch.getHandlerMethod());
        this.handleMatch(bestMatch.mapping, lookupPath, request);
        //返回匹配器中的处理方法
        return bestMatch.getHandlerMethod();
    }
}
```

### 4.3.2 适配器

doDispatch() 中调用 `HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler())`

```java
protected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException {
    if (this.handlerAdapters != null) {
        // 遍历所有的 HandlerAdapter
        for (HandlerAdapter adapter : this.handlerAdapters) {
            // 判断当前适配器是否支持当前 handle
            // 这里返回的是True，
            if (adapter.supports(handler)) {
                // 返回的是 【RequestMappingHandlerAdapter】
                return adapter;
            }
        }
    }
    throw new ServletException();
}
```

### 4.3.3 方法执行

1. 参数解析
2. 执行方法
3. 返回值处理(这个见响应处理章节)

#### I 执行流程

实例代码：

```java
@GetMapping("/params")
public String param(Map<String, Object> map, Model model, HttpServletRequest request) {
    map.put("k1", "v1");			// 都可以向请求域中添加数据
    model.addAttribute("k2", "v2");	// 它们两个都在数据封装在 【BindingAwareModelMap】，继承自 LinkedHashMap
    request.setAttribute("m", "HelloWorld");
    return "forward:/success";
}
```

![](https://gitee.com/seazean/images/raw/master/Frame/SpringMVC-Model和Map的数据解析.png)

doDispatch() 中调用 `mv = ha.handle(processedRequest, response, mappedHandler.getHandler())` **使用适配器执行方法**。

`AbstractHandlerMethodAdapter#handle` → `RequestMappingHandlerAdapter#handleInternal` → `invokeHandlerMethod`：

```java
protected ModelAndView invokeHandlerMethod(HttpServletRequest request,
                                           HttpServletResponse response, 
                                           HandlerMethod handlerMethod) throws Exception {
	// 封装成 SpringMVC 的接口，用于通用 Web 请求拦截器，使能够访问通用请求元数据，而不是用于实际处理请求
    ServletWebRequest webRequest = new ServletWebRequest(request, response);
    try {
        // WebDataBinder 用于【从 Web 请求参数到 JavaBean 对象的数据绑定】，获取创建该实例的工厂
        WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);
        // 创建 Model 实例，用于向模型添加属性
        ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);
		// 方法执行器
        ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);
        
        // 参数解析器，有很多
        if (this.argumentResolvers != null) {
            invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);
        }
        // 返回值处理器，也有很多
        if (this.returnValueHandlers != null) {
            invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);
        }
        // 设置数据绑定器
        invocableMethod.setDataBinderFactory(binderFactory);
        // 设置参数检查器
		invocableMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer);
   
        // 新建一个 ModelAndViewContainer 并进行初始化和一些属性的填充
        ModelAndViewContainer mavContainer = new ModelAndViewContainer();
            
        // 设置一些属性
        
        // 【执行目标方法】
        invocableMethod.invokeAndHandle(webRequest, mavContainer);
        // 异步请求
        if (asyncManager.isConcurrentHandlingStarted()) {
            return null;
        }
		// 【获取 ModelAndView 对象，封装了 ModelAndViewContainer】
        return getModelAndView(mavContainer, modelFactory, webRequest);
    }
    finally {
        webRequest.requestCompleted();
    }
}
```

##### a 执行目标方法

ServletInvocableHandlerMethod#invokeAndHandle：执行目标方法

1. `returnValue = invokeForRequest(webRequest, mavContainer, providedArgs)`：**执行自己写的 controller 方法，返回的就是自定义方法中 return 的值**。

- 第一步是获取所有参数的值`Object[] args = this.getMethodArgumentValues(request, mavContainer, providedArgs);`

- 第二步是真正的执行方法`return this.doInvoke(args);`

```java
//获取参数的值
protected Object[] getMethodArgumentValues(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception {
    //获取此处理程序方法的方法参数的详细信息
    MethodParameter[] parameters = this.getMethodParameters();
    if (ObjectUtils.isEmpty(parameters)) {
        return EMPTY_ARGS;
    } else {
        //存放所有的参数的值
        Object[] args = new Object[parameters.length];

        for(int i = 0; i < parameters.length; ++i) {
            MethodParameter parameter = parameters[i];
            parameter.initParameterNameDiscovery(this.parameterNameDiscoverer);
            //获取调用方法时提供的参数，一般是空
            args[i] = findProvidedArgument(parameter, providedArgs);
            if (args[i] == null) {
                //判断此参数是否可以解析，过程是遍历所有的参数解析器，调用其中的supportsParameter，将解析器放入result
                if (!this.resolvers.supportsParameter(parameter)) {
                    throw new IllegalStateException(formatArgumentError(parameter, "No suitable resolver"));
                }

                try {
                    //开始解析参数
                    args[i] = this.resolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory);
                } catch (Exception var10) {
                    if (logger.isDebugEnabled()) {
                        String exMsg = var10.getMessage();
                        if (exMsg != null && !exMsg.contains(parameter.getExecutable().toGenericString())) {
                            logger.debug(formatArgumentError(parameter, exMsg));
                        }
                    }

                    throw var10;
                }
            }
        }
		//返回参数
        return args;
    }
}

```

#### II 参数解析举例

解析自定义的 JavaBean 为例，调用 ModelAttributeMethodProcessor#resolveArgument 处理参数的方法，通过合适的类型转换器把 URL 中的参数转换以后，利用反射获取 set 方法，注入到 JavaBean

* Person.java：

  ```java
  @Data
  @Component	//加入到容器中
  public class Person {
      private String userName;
      private Integer age;
      private Date birth;
  }
  ```

* Controller：

  ```java
  @RestController	//返回的数据不是页面
  public class ParameterController {
      // 数据绑定：页面提交的请求数据（GET、POST）都可以和对象属性进行绑定
      @GetMapping("/saveuser")
      public Person saveuser(Person person){
          return person;
      }
  }
  ```

* 访问 URL：http://localhost:8080/saveuser?userName=zhangsan&age=20

进入源码：ModelAttributeMethodProcessor#resolveArgument

* `name = ModelFactory.getNameForParameter(parameter)`：获取名字，此例就是 person

* `ann = parameter.getParameterAnnotation(ModelAttribute.class)`：是否有 ModelAttribute 注解

* `if (mavContainer.containsAttribute(name))`：ModelAndViewContainer 中是否包含 person 对象

* `attribute = createAttribute()`：**创建一个实例，空的 Person 对象**

* `binder = binderFactory.createBinder(webRequest, attribute, name)`：Web 数据绑定器，可以利用 Converters 将请求数据转成指定的数据类型，绑定到 JavaBean 中

* `bindRequestParameters(binder, webRequest)`：**利用反射向目标对象填充数据**

  `servletBinder = (ServletRequestDataBinder) binder`：类型强转

  `servletBinder.bind(servletRequest)`：绑定数据

  * `mpvs = new MutablePropertyValues(request.getParameterMap())`：获取请求 URI 参数中的 k-v 键值对

  * `addBindValues(mpvs, request)`：子类可以用来为请求添加额外绑定值

  * `doBind(mpvs)`：真正的绑定的方法，调用 `applyPropertyValues` 应用参数值，然后调用 `setPropertyValues` 方法

    `AbstractPropertyAccessor#setPropertyValues()`：

    * `List<PropertyValue> propertyValues`：获取到所有的参数的值，就是 URI 上的所有的参数值

    * `for (PropertyValue pv : propertyValues)`：遍历所有的参数值

    * `setPropertyValue(pv)`：**填充到空的 Person 实例中**

      * `nestedPa = getPropertyAccessorForPropertyPath(propertyName)`：获取属性访问器

      * `tokens = getPropertyNameTokens()`：获取元数据的信息

      * `nestedPa.setPropertyValue(tokens, pv)`：填充数据

      * `processLocalProperty(tokens, pv)`：处理属性

        * `if (!Boolean.FALSE.equals(pv.conversionNecessary))`：数据是否需要转换了

        * `if (pv.isConverted())`：数据已经转换过了，转换了直接赋值，没转换进行转换

        * `oldValue = ph.getValue()`：获取未转换的数据

        * `valueToApply = convertForProperty()`：进行数据转换

          `TypeConverterDelegate#convertIfNecessary`：进入该方法的逻辑

          * `if (conversionService.canConvert(sourceTypeDesc, typeDescriptor))`：判断能不能转换

            `GenericConverter converter = getConverter(sourceType, targetType)`：**获取类型转换器**

            * `converter = this.converters.find(sourceType, targetType)`：寻找合适的转换器

              * `sourceCandidates = getClassHierarchy(sourceType.getType())`：原数据类型

              * `targetCandidates = getClassHierarchy(targetType.getType())`：目标数据类型

                ```java
                for (Class<?> sourceCandidate : sourceCandidates) {
                    //双重循环遍历，寻找合适的转换器
                 	for (Class<?> targetCandidate : targetCandidates) {
                ```

              * `GenericConverter converter = getRegisteredConverter(..)`：匹配类型转换器

              * `return converter`：返回转换器

          * `conversionService.convert(newValue, sourceTypeDesc, typeDescriptor)`：开始转换

            * `converter = getConverter(sourceType, targetType)`：**获取可用的转换器**
            * `result = ConversionUtils.invokeConverter()`：执行转换方法
              * `converter.convert()`：**调用转换器的转换方法**（GenericConverter#convert）
            * `return handleResult(sourceType, targetType, result)`：返回结果

        * `ph.setValue(valueToApply)`：**设置 JavaBean 属性**（BeanWrapperImpl.BeanPropertyHandler）

          * `Method writeMethod`：获取 set 方法
            * `Class<?> cls = getClass0()`：获取 Class 对象
            * `writeMethodName = Introspector.SET_PREFIX + getBaseName()`：**set 前缀 + 属性名**
            * `writeMethod = Introspector.findMethod(cls, writeMethodName, 1, args)`：获取只包含一个参数的 set 方法
            * `setWriteMethod(writeMethod)`：加入缓存
          * `ReflectionUtils.makeAccessible(writeMethod)`：设置访问权限
          * `writeMethod.invoke(getWrappedInstance(), value)`：执行方法

* `bindingResult = binder.getBindingResult()`：获取绑定的结果

* `mavContainer.addAllAttributes(bindingResultModel)`：**把所有填充的参数放入 ModelAndViewContainer**

* `return attribute`：返回填充后的 Person 对象

## 4.4 响应处理

### 4.4.1 响应数据

以 Person 为例：

```java
@ResponseBody  		// 利用返回值处理器里面的消息转换器进行处理，而不是视图
@GetMapping(value = "/person")
public Person getPerson(){
    Person person = new Person();
    person.setAge(28);
    person.setBirth(new Date());
    person.setUserName("zhangsan");
    return person;
}
```

直接进入方法执行完后的逻辑 ServletInvocableHandlerMethod#invokeAndHandle：

```java
public void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,
                            Object... providedArgs) throws Exception {
	// 【执行目标方法】，return person 对象
    Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);
    // 设置状态码
    setResponseStatus(webRequest);

    // 判断方法是否有返回值
    if (returnValue == null) {
        if (isRequestNotModified(webRequest) || getResponseStatus() != null || mavContainer.isRequestHandled()) {
            disableContentCachingIfNecessary(webRequest);
            mavContainer.setRequestHandled(true);
            return;
        }
    }	
    // 返回值是字符串
    else if (StringUtils.hasText(getResponseStatusReason())) {
        // 设置请求处理完成
        mavContainer.setRequestHandled(true);
        return;
	// 设置请求没有处理完成，还需要进行返回值的逻辑
    mavContainer.setRequestHandled(false);
    Assert.state(this.returnValueHandlers != null, "No return value handlers");
    try {
        // 【返回值的处理】
        this.returnValueHandlers.handleReturnValue(
            returnValue, getReturnValueType(returnValue), mavContainer, webRequest);
    }
    catch (Exception ex) {}
}
```

* **没有加 @ResponseBody 注解的返回数据按照视图（页面）处理的逻辑**，ViewNameMethodReturnValueHandler（视图详解）
* 此例是加了注解的，返回的数据不是视图，HandlerMethodReturnValueHandlerComposite#handleReturnValue：

```java
public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,
                              ModelAndViewContainer mavContainer, NativeWebRequest webRequest)  {
	// 获取合适的返回值处理器
    HandlerMethodReturnValueHandler handler = selectHandler(returnValue, returnType);
    if (handler == null) {
        throw new IllegalArgumentException();
    }
    // 使用处理器处理返回值（详解源码中的这两个函数）
    handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);
}
```

HandlerMethodReturnValueHandlerComposite#selectHandler：获取合适的返回值处理器

```java
@Nullable
private HandlerMethodReturnValueHandler selectHandler(@Nullable Object value, MethodParameter returnType) {
    //是否是异步请求
    boolean isAsyncValue = isAsyncReturnValue(value, returnType);
    //遍历所有的返回值处理器
    for (HandlerMethodReturnValueHandler handler : this.returnValueHandlers) {
        if (isAsyncValue && !(handler instanceof AsyncHandlerMethodReturnValueHandler)) {
            continue;
        }
        if (handler.supportsReturnType(returnType)) {
            return handler;
        }
    }
    return null;
}
```

RequestResponseBodyMethodProcessor#handleReturnValue：处理返回值，要进行内容协商

```java
@Override
public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,
                              ModelAndViewContainer mavContainer, NativeWebRequest webRequest)
    throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {
	//设置请求处理完成
    mavContainer.setRequestHandled(true);
    //获取输入的数据,也就是封装request
    ServletServerHttpRequest inputMessage = createInputMessage(webRequest);
    //获取输出的数据，也就是封装response 
    ServletServerHttpResponse outputMessage = createOutputMessage(webRequest);

    // 使用消息转换器进行写出，将数据转换为json，写入到响应体中去(这个是我自己猜的)
    writeWithMessageConverters(returnValue, returnType, inputMessage, outputMessage);
}
```

```java
	@SuppressWarnings({"rawtypes", "unchecked"})
	protected <T> void writeWithMessageConverters(@Nullable T value, MethodParameter returnType,
			ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage)
			throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {

		Object body;
		Class<?> valueType;
		Type targetType;
		//判断返回的数据是不是字符类型
		if (value instanceof CharSequence) {
			body = value.toString();
			valueType = String.class;
			targetType = String.class;
		}
		else {
			body = value;
			valueType = getReturnValueType(body, returnType);
			targetType = GenericTypeResolver.resolveType(getGenericType(returnType), returnType.getContainingClass());
		}
		//当前数据是不是流数据，如果是则进行相应处理
		if (isResourceType(value, returnType)) {
			//
		}

        //===========内容协商处理===============
        //目的：内容协商后选择使用的类型，浏览器和服务器都支持的媒体（数据）类型
        //1. 判断当前响应头中是否已经有确定的媒体类型。MediaType,如果有则直接用有的
        //2. 获取浏览器支持的媒体类型，请求头字段
        //3. 获取服务器能生成的媒体类型
        //4. 存储最佳匹配的集合
        //5. 遍历所有的 HTTP 数据转换器,看谁能处理,选择最合适的那一个,如GenericHttpMessageConverter genericConverter
        //6. 判断转换器是否可以写出给定的类型
        //7. 调用消息转换器的 write 方法 如genericConverter.write
        //===========内容协商处理===============
		
	}

```

### 4.4.2 协商策略(ToDo)

开启基于请求参数的内容协商模式：（SpringBoot 方式）

```yaml
spring.mvc.contentnegotiation:favor-parameter: true  # 开启请求参数内容协商模式
```

发请求： http://localhost:8080/person?format=json，解析 format

策略类为 ParameterContentNegotiationStrategy，运行流程如下：

* `acceptableTypes = getAcceptableMediaTypes(request)`：获取浏览器支持的媒体类型

  `mediaTypes = strategy.resolveMediaTypes(request)`：解析请求 URL 参数中的数据

  * `return resolveMediaTypeKey(webRequest, getMediaTypeKey(webRequest))`：

    `getMediaTypeKey(webRequest)`：

    * `request.getParameter(getParameterName())`：获取 URL 中指定的需求的数据类型
      * `getParameterName()`：获取参数的属性名 format
      * `getParameter()`：**获取 URL 中 format 对应的数据**

    `resolveMediaTypeKey()`：解析媒体类型，封装成集合

自定义内容协商策略：

```java
public class WebConfig implements WebMvcConfigurer {
    @Bean
    public WebMvcConfigurer webMvcConfigurer() {
        return new WebMvcConfigurer() {
            @Override	//自定义内容协商策略
            public void configureContentNegotiation(ContentNegotiationConfigurer configurer) {
                Map<String, MediaType> mediaTypes = new HashMap<>();
                mediaTypes.put("json", MediaType.APPLICATION_JSON);
                mediaTypes.put("xml",MediaType.APPLICATION_XML);
                mediaTypes.put("person",MediaType.parseMediaType("application/x-person"));
                // 指定支持解析哪些参数对应的哪些媒体类型
                ParameterContentNegotiationStrategy parameterStrategy = new ParameterContentNegotiationStrategy(mediaTypes);

                // 请求头解析
                HeaderContentNegotiationStrategy headStrategy = new HeaderContentNegotiationStrategy();

                // 添加到容器中，即可以解析请求头 又可以解析请求参数
                configurer.strategies(Arrays.asList(parameterStrategy,headStrategy));
            }
            
            @Override 	// 自定义消息转换器
            public void extendMessageConverters(List<HttpMessageConverter<?>> converters) {
                converters.add(new GuiguMessageConverter());
            }
        }
    }
}
```

也可以自定义 HttpMessageConverter，实现 HttpMessageConverter<T> 接口重写方法即可

## 4.5 视图解析

请求处理：

```java
@GetMapping("/params")
public String param(){
	return "forward:/success";
    //return "redirect:/success";
}
```

进入执行方法逻辑 ServletInvocableHandlerMethod#invokeAndHandle，进入 `this.returnValueHandlers.handleReturnValue`：

```java
public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,
                              ModelAndViewContainer mavContainer, NativeWebRequest webRequest)  {
	// 获取合适的返回值处理器：调用 if (handler.supportsReturnType(returnType))判断是否支持
    HandlerMethodReturnValueHandler handler = selectHandler(returnValue, returnType);
    if (handler == null) {
        throw new IllegalArgumentException();
    }
    // 使用处理器处理返回值
    handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);
}
```

* ViewNameMethodReturnValueHandler#handleReturnValue：

  ```java
  public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,
                                ModelAndViewContainer mavContainer, 
                                NativeWebRequest webRequest) throws Exception {
  	// 返回值是字符串，是 return "forward:/success"
      if (returnValue instanceof CharSequence) {
          String viewName = returnValue.toString();
          // 【把视图名称设置进入 ModelAndViewContainer 中】
          mavContainer.setViewName(viewName);
          // 判断是否是重定向数据 `viewName.startsWith("redirect:")`
          if (isRedirectViewName(viewName)) {
              // 如果是重定向，设置是重定向指令
              mavContainer.setRedirectModelScenario(true);
          }
      }
      else if (returnValue != null) {
          // should not happen
          throw new UnsupportedOperationException();
      }
  }
  ```


## 4.6 得到ModelAndView

> 1. 执行完方法并且处理完返回值以后，将所有的数据都放在ModelAndViewContanier中，包括View和Model
> 2. 所以后续的关键就是获取mv对象

RequestMappingHandlerAdapter#getModelAndView：获取 ModelAndView 对象

```java
@Nullable
private ModelAndView getModelAndView(ModelAndViewContainer mavContainer,
                                     ModelFactory modelFactory, NativeWebRequest webRequest) throws Exception {
    modelFactory.updateModel(webRequest, mavContainer);
    //判断请求是否已经处理完成了
    if (mavContainer.isRequestHandled()) {
        return null;
    }
    //获取 包含 Controller 方法参数的 BindingAwareModelMap（本节开头），也就是mav中的model(数据部分)
    ModelMap model = mavContainer.getModel();
    //把 ModelAndViewContainer 和 ModelMap 中的数据封装到 ModelAndView** 
    ModelAndView mav = new ModelAndView(mavContainer.getViewName(), model, mavContainer.getStatus());
    //是否是通过名称指定视图引用
    if (!mavContainer.isViewReference()) {
        mav.setView((View) mavContainer.getView());
    }
    //判断 model 是否是重定向数据，如果是进行重定向逻辑
    if (model instanceof RedirectAttributes) {
        Map<String, ?> flashAttributes = ((RedirectAttributes) model).getFlashAttributes();
        HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);
        if (request != null) {
            RequestContextUtils.getOutputFlashMap(request).putAll(flashAttributes);
        }
    }
    //返回 ModelAndView 对象
    return mav;
}
```

## 4.7 结果派发

doDispatch()中的 processDispatchResult：处理派发结果，绝对页面如何响应

```java
private void processDispatchResult(HttpServletRequest request, HttpServletResponse response,
                                   @Nullable HandlerExecutionChain mappedHandler, 
                                   @Nullable ModelAndView mv,
                                   @Nullable Exception exception) throws Exception {
    boolean errorView = false;
    if (exception != null) {
    }
    // mv 是 ModelAndValue
    if (mv != null && !mv.wasCleared()) {
        // 渲染视图
        render(mv, request, response);
        if (errorView) {
            WebUtils.clearErrorRequestAttributes(request);
        }
    }
    else {}  
}
```

DispatcherServlet#render：

* `Locale locale = this.localeResolver.resolveLocale(request)`：国际化相关

* `String viewName = mv.getViewName()`：视图名字，是请求转发 forward:/success（响应数据解析并存入 ModelAndView）

* `view = resolveViewName(viewName, mv.getModelInternal(), locale, request)`：解析视图

  * `for (ViewResolver viewResolver : this.viewResolvers)`：遍历所有的视图解析器

    `view = viewResolver.resolveViewName(viewName, locale)`：根据视图名字解析视图，调用内容协商视图处理器 ContentNegotiatingViewResolver 的方法

    * `attrs = RequestContextHolder.getRequestAttributes()`：获取请求的相关属性信息

    * `requestedMediaTypes = getMediaTypes(((ServletRequestAttributes) attrs).getRequest())`：获取最佳匹配的媒体类型，函数内进行了匹配的逻辑

    * `candidateViews = getCandidateViews(viewName, locale, requestedMediaTypes)`：获取候选的视图对象

      * `for (ViewResolver viewResolver : this.viewResolvers)`：遍历所有的视图解析器

      * `View view = viewResolver.resolveViewName(viewName, locale)`：**解析视图**

        `AbstractCachingViewResolver#resolveViewName`：

        * `returnview = createView(viewName, locale)`：UrlBasedViewResolver#createView

          **请求转发**：实例为 InternalResourceView

          * `if (viewName.startsWith(FORWARD_URL_PREFIX))`：视图名字是否是 **`forward:`** 的前缀
          * `forwardUrl = viewName.substring(FORWARD_URL_PREFIX.length())`：名字截取前缀
          * `view = new InternalResourceView(forwardUrl)`：新建 InternalResourceView  对象并返回

          * `return applyLifecycleMethods(FORWARD_URL_PREFIX, view)`：Spring 中的初始化操作

          **重定向**：实例为 RedirectView 

          * `if (viewName.startsWith(REDIRECT_URL_PREFIX))`：视图名字是否是 **`redirect:`** 的前缀
          * `redirectUrl = viewName.substring(REDIRECT_URL_PREFIX.length())`：名字截取前缀
          * `RedirectView view = new RedirectView()`：新建 RedirectView 对象并返回

    * `bestView = getBestView(candidateViews, requestedMediaTypes, attrs)`：选出最佳匹配的视图对象

* `view.render(mv.getModelInternal(), request, response)`：**页面渲染**

  * `mergedModel = createMergedOutputModel(model, request, response)`：把请求域中的数据封装到 model

  * `prepareResponse(request, response)`：响应前的准备工作，设置一些响应头

  * `renderMergedOutputModel(mergedModel, getRequestToExpose(request), response)`：渲染输出的数据

    `getRequestToExpose(request)`：获取 Servlet 原生的方式

    **请求转发 InternalResourceView 的逻辑：请求域中的数据不丢失**

    * `exposeModelAsRequestAttributes(model, request)`：暴露 model 作为请求域的属性
      * `model.forEach()`：遍历 Model 中的数据
      * `request.setAttribute(name, value)`：**设置到请求域中**
    * `exposeHelpers(request)`：自定义接口
    * `dispatcherPath = prepareForRendering(request, response)`：确定调度分派的路径，此例是 /success
    * `rd = getRequestDispatcher(request, dispatcherPath)`：**获取 Servlet 原生的 RequestDispatcher 实现转发**
    * `rd.forward(request, response)`：实现请求转发

    **重定向 RedirectView 的逻辑：请求域中的数据会丢失**

    * `targetUrl = createTargetUrl(model, request)`：获取目标 URL
      * `enc = request.getCharacterEncoding()`：设置编码 UTF-8
      * `appendQueryProperties(targetUrl, model, enc)`：添加一些属性，比如 `url + ?name=123&&age=324`
    * `sendRedirect(request, response, targetUrl, this.http10Compatible)`：重定向

* `response.sendRedirect(encodedURL)`：**使用 Servlet 原生方法实现重定向**

# 5. 异步调用

## 5.1 请求参数

### 5.1.1 介绍

1. 名称：@RequestBody

2. 类型：形参注解

3. 位置：处理器类中的方法形参前方

作用：将异步提交数据**转换**成标准请求参数格式，并赋值给形参

### 5.1.2 代码

```java
@Controller //控制层
public class AjaxController {
    @RequestMapping("/ajaxController")
    public String ajaxController(@RequestBody String message){
        System.out.println(message);
        return "page.jsp";
    }  
}
```

* 注解添加到 POJO  参数前方时，封装的异步提交数据按照 POJO  的属性格式进行关系映射
  * POJO 中的属性如果请求数据中没有，属性值为 null
  * POJO 中没有的属性如果请求数据中有，不进行映射
* 注解添加到集合参数前方时，封装的异步提交数据按照集合的存储结构进行关系映射 

```java
@RequestMapping("/ajaxPojoToController")
//如果处理参数是POJO，且页面发送的请求数据格式与POJO中的属性对应，@RequestBody注解可以自动映射对应请求数据到POJO中
public String  ajaxPojoToController(@RequestBody User user){
    System.out.println("controller pojo :"+user);
    return "page.jsp";
}

@RequestMapping("/ajaxListToController")
//如果处理参数是List集合且封装了POJO，且页面发送的数据是JSON格式，数据将自动映射到集合参数
public String  ajaxListToController(@RequestBody List<User> userList){
    System.out.println("controller list :"+userList);
    return "page.jsp";
}
```

ajax.jsp

```html
<%@page pageEncoding="UTF-8" language="java" contentType="text/html;UTF-8" %>

<a href="javascript:void(0);" id="testAjax">访问springmvc后台controller</a><br/>
<a href="javascript:void(0);" id="testAjaxPojo">传递Json格式POJO</a><br/>
<a href="javascript:void(0);" id="testAjaxList">传递Json格式List</a><br/>
    
<script type="text/javascript" src="${pageContext.request.contextPath}/js/jquery-3.3.1.min.js"></script>
<script type="text/javascript">
    $(function () {
        //为id="testAjax"的组件绑定点击事件
        $("#testAjax").click(function(){
            //发送异步调用
            $.ajax({
               //请求方式：POST请求
               type:"POST",
               //请求的地址
               url:"ajaxController",
               //请求参数（也就是请求内容）
               data:'ajax message',
               //响应正文类型
               dataType:"text",
               //请求正文的MIME类型
               contentType:"application/text",
            });
        });
        
         //为id="testAjaxPojo"的组件绑定点击事件
        $("#testAjaxPojo").click(function(){
            $.ajax({
               type:"POST",
               url:"ajaxPojoToController",
               data:'{"name":"Jock","age":39}',
               dataType:"text",
               contentType:"application/json",
            });
        });
        
        //为id="testAjaxList"的组件绑定点击事件
        $("#testAjaxList").click(function(){
            $.ajax({//.....
               data:'[{"name":"Jock","age":39},{"name":"Jockme","age":40}]'})}
    }
</script>
```

web.xml配置：请求响应章节请求中的web.xml配置

```xml
CharacterEncodingFilter + DispatcherServlet
```

spring-mvc.xml：

```xml
<context:component-scan base-package="controller,domain"/>
<mvc:resources mapping="/js/**" location="/js/"/>
<mvc:annotation-driven/>
```

## 5.2 响应数据

注解：@ResponseBody

作用：将 java 对象转为 json 格式的数据

方法返回值为 POJO 时，自动封装数据成 Json 对象数据：

```java
@RequestMapping("/ajaxReturnJson")
@ResponseBody
public User ajaxReturnJson(){
    System.out.println("controller return json pojo...");
    User user = new User("Jockme",40);
    return user;
}  
```

方法返回值为 List 时，自动封装数据成 json 对象数组数据：

```java
@RequestMapping("/ajaxReturnJsonList")
@ResponseBody
//基于jackon技术，使用@ResponseBody注解可以将返回的保存POJO对象的集合转成json数组格式数据
public List ajaxReturnJsonList(){
    System.out.println("controller return json list...");
    User user1 = new User("Tom",3);
    User user2 = new User("Jerry",5);

    ArrayList al = new ArrayList();
    al.add(user1);
    al.add(user2);
    return al;
}
```

AJAX 文件：

```js
//为id="testAjaxReturnString"的组件绑定点击事件
$("#testAjaxReturnString").click(function(){
    //发送异步调用
    $.ajax({
        type:"POST",
        url:"ajaxReturnString",
        //回调函数
        success:function(data){
            //打印返回结果
            alert(data);
        }
    });
});

//为id="testAjaxReturnJson"的组件绑定点击事件
$("#testAjaxReturnJson").click(function(){
    $.ajax({
        type:"POST",
        url:"ajaxReturnJson",
        success:function(data){
            alert(data['name']+" ,  "+data['age']);
        }
    });
});

//为id="testAjaxReturnJsonList"的组件绑定点击事件
$("#testAjaxReturnJsonList").click(function(){
    $.ajax({
        type:"POST",
        url:"ajaxReturnJsonList",
        success:function(data){
            alert(data);
            alert(data[0]["name"]);
            alert(data[1]["age"]);
        }
    });
});
```

## 5.3 跨域访问

跨域访问：当通过域名 A 下的操作访问域名 B 下的资源时，称为跨域访问。跨域访问时，会出现无法访问的现象。

环境搭建：

* 为当前主机添加备用域名
  * 修改 windows 安装目录中的 host 文件
  * 格式： ip 域名
* 动态刷新 DNS
  *  命令： ipconfig /displaydns
  *  命令： ipconfig /flushdns   

跨域访问支持：

* 名称：@CrossOrigin
* 类型：方法注解 、 类注解
* 位置：处理器类中的方法上方 或 类上方
* 作用：设置当前处理器方法 / 处理器类中所有方法支持跨域访问
* 范例：  

```java
@RequestMapping("/cross")
@ResponseBody
//使用@CrossOrigin开启跨域访问
//标注在处理器方法上方表示该方法支持跨域访问
//标注在处理器类上方表示该处理器类中的所有处理器方法均支持跨域访问
@CrossOrigin
public User cross(HttpServletRequest request){
    System.out.println("controller cross..." + request.getRequestURL());
    User user = new User("Jockme",36);
    return user;
}
```

* jsp 文件

```html
<a href="javascript:void(0);" id="testCross">跨域访问</a><br/>
<script type="text/javascript" src="${pageContext.request.contextPath}/js/jquery-3.3.1.min.js"></script>
<script type="text/javascript">
    $(function () {
        //为id="testCross"的组件绑定点击事件
        $("#testCross").click(function(){
            //发送异步调用
            $.ajax({
               type:"POST",
               url:"http://127.0.0.1/cross",
               //回调函数
               success:function(data){
                   alert("跨域调用信息反馈:" + data['name'] + "," + data['age']);
               }
            });
        });
    });
</script>
```

# 6. 拦截器

## 6.1 基本介绍

拦截器（Interceptor）是一种动态拦截方法调用的机制

作用：

1. 在指定的方法调用前后执行预先设定后的的代码
2. 阻止原始方法的执行

核心原理：AOP 思想

拦截器链：多个拦截器按照一定的顺序，对原始被调用功能进行增强  

拦截器和过滤器对比：

1. 归属不同： Filter 属于 Servlet 技术， Interceptor 属于 SpringMVC 技术

2. 拦截内容不同： Filter 对所有访问进行增强， Interceptor 仅针对 SpringMVC 的访问进行增强  

   <img src="https://gitee.com/seazean/images/raw/master/Frame/SpringMVC-过滤器和拦截器的运行机制.png" style="zoom:67%;" />

## 6.2 处理方法

### 6.2.1 前置处理

原始方法之前运行：doDispathcher的适配器执行handler之前

```java
public boolean preHandle(HttpServletRequest request,
                         HttpServletResponse response,
                         Object handler) throws Exception {
    System.out.println("preHandle");
    return true;
}
```

* 参数：
  * request：请求对象
  * response：响应对象
  * handler：被调用的处理器对象，本质上是一个方法对象，对反射中的Method对象进行了再包装
    * handler：public String controller.InterceptorController.handleRun
    * handler.getClass()：org.springframework.web.method.HandlerMethod
* 返回值：
  * 返回值为 false，被拦截的处理器将不执行  

### 6.2.2 后置处理

原始方法运行后运行，如果原始方法被拦截，则不执行：doDispathcher的适配器执行handler之后

```java
public void postHandle(HttpServletRequest request,
                       HttpServletResponse response,
                       Object handler,
                       ModelAndView modelAndView) throws Exception {
    System.out.println("postHandle");
}
```

参数：

* modelAndView：如果处理器执行完成具有返回结果，可以读取到对应数据与页面信息，并进行调整  

### 6.2.3 异常处理

拦截器最后执行的方法，无论原始方法是否执行：

- 如果有异常，则直接跳转到该拦截器链
- 如果没有，则在页面渲染完以后执行该拦截器链

```java
public void afterCompletion(HttpServletRequest request,
                            HttpServletResponse response,
                            Object handler,
                            Exception ex) throws Exception {
    System.out.println("afterCompletion");
}
```

参数：

* ex：如果处理器执行过程中出现异常对象，可以针对异常情况进行单独处理  

## 6.3 拦截配置

拦截路径：

* `/**`：表示拦截所有映射
* `/* `：表示拦截所有/开头的映射
* `/user/*`：表示拦截所有 /user/ 开头的映射
* `/user/add*`：表示拦截所有 /user/ 开头，且具体映射名称以 add 开头的映射
* `/user/*All`：表示拦截所有 /user/ 开头，且具体映射名称以 All 结尾的映射

```xml
<mvc:interceptors>
    <!--开启具体的拦截器的使用，可以配置多个-->
    <mvc:interceptor>
        <!--设置拦截器的拦截路径，支持*通配-->       
        <mvc:mapping path="/handleRun*"/>
        <!--设置拦截排除的路径，配置/**或/*，达到快速配置的目的-->
        <mvc:exclude-mapping path="/b*"/>
        <!--指定具体的拦截器类-->
        <bean class="MyInterceptor"/>
    </mvc:interceptor>
</mvc:interceptors>
```

## 6.4 拦截器链

**责任链模式**：责任链模式是一种行为模式

特点：沿着一条预先设定的任务链顺序执行，每个节点具有独立的工作任务
优势：

* 独立性：只关注当前节点的任务，对其他任务直接放行到下一节点
* 隔离性：具备链式传递特征，无需知晓整体链路结构，只需等待请求到达后进行处理即可
* 灵活性：可以任意修改链路结构动态新增或删减整体链路责任
* 解耦：将动态任务与原始任务解耦

缺点：

* 链路过长时，处理效率低下
* 可能存在节点上的循环引用现象，造成死循环，导致系统崩溃  

<img src="https://gitee.com/seazean/images/raw/master/Frame/SpringMVC-多拦截器配置.png" style="zoom:67%;" />

## 6.5 源码解析

DispatcherServlet#doDispatch 方法中：

```java
//简化源码
protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {
	try {
        // 获取映射器以及映射器的所有拦截器（运行原理部分详解了源码）
        mappedHandler = getHandler(processedRequest);
        // 前置处理，返回 false 代表条件成立
        if (!mappedHandler.applyPreHandle(processedRequest, response)) {
            //请求从这里直接结束
            return;
        }
        //所有拦截器都返回 true，执行目标方法
        mv = ha.handle(processedRequest, response, mappedHandler.getHandler())
        // 倒序执行所有拦截器的后置处理方法
        mappedHandler.applyPostHandle(processedRequest, response, mv);
    } catch (Exception ex) {
        //异常处理机制
        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);
    }
    //页面渲染,并且在页面渲染完以后进行afterCompletion拦截器链
    processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);
}
```

HandlerExecutionChain#applyPreHandle：前置处理

```java
boolean applyPreHandle(HttpServletRequest request, HttpServletResponse response) throws Exception {
    //遍历所有的拦截器
    for (int i = 0; i < this.interceptorList.size(); i++) {
        HandlerInterceptor interceptor = this.interceptorList.get(i);
        //执行前置处理，如果拦截器返回 false，则条件成立，不在执行其他的拦截器，直接返回 false，请求直接结束
        if (!interceptor.preHandle(request, response, this.handler)) {
            triggerAfterCompletion(request, response, null);
            return false;
        }
        this.interceptorIndex = i;
    }
    return true;
}
```

HandlerExecutionChain#applyPostHandle：后置处理

```java
void applyPostHandle(HttpServletRequest request, HttpServletResponse response, @Nullable ModelAndView mv)
    throws Exception {
	//倒序遍历
    for (int i = this.interceptorList.size() - 1; i >= 0; i--) {
        HandlerInterceptor interceptor = this.interceptorList.get(i);
        interceptor.postHandle(request, response, this.handler, mv);
    }
}
```

DispatcherServlet#triggerAfterCompletion 底层调用 HandlerExecutionChain#triggerAfterCompletion：

* 前面的步骤有任何异常都会直接倒序触发 afterCompletion

* 页面成功渲染有异常，也会倒序触发 afterCompletion

```java
void triggerAfterCompletion(HttpServletRequest request, HttpServletResponse response, @Nullable Exception ex) {
    //倒序遍历
    for (int i = this.interceptorIndex; i >= 0; i--) {
        HandlerInterceptor interceptor = this.interceptorList.get(i);
        try {
            //执行异常处理的方法
            interceptor.afterCompletion(request, response, this.handler, ex);
        }
        catch (Throwable ex2) {
            logger.error("HandlerInterceptor.afterCompletion threw exception", ex2);
        }
    }
}
```

拦截器的执行流程：

<img src="https://gitee.com/seazean/images/raw/master/Frame/SpringMVC-拦截器工作流程.png" style="zoom: 50%;" />



参考文章：https://www.yuque.com/atguigu/springboot/vgzmgh#wtPLU

## 6.6 自定义

* Contoller层

  ```java
  @Controller
  public class InterceptorController {
      @RequestMapping("/handleRun")
      public String handleRun() {
          System.out.println("业务处理器运行------------main");
          return "page.jsp";
      }
  }
  ```

* 自定义拦截器需要实现 HandleInterceptor 接口

  ```java
  //自定义拦截器需要实现HandleInterceptor接口
  public class MyInterceptor implements HandlerInterceptor {
      //处理器运行之前执行
      @Override
      public boolean preHandle(HttpServletRequest request,
                               HttpServletResponse response,
                               Object handler) throws Exception {
          System.out.println("前置运行----a1");
          //返回值为false将拦截原始处理器的运行
          //如果配置多拦截器，返回值为false将终止当前拦截器后面配置的拦截器的运行
          return true;
      }
  
      //处理器运行之后执行
      @Override
      public void postHandle(HttpServletRequest request,
                             HttpServletResponse response,
                             Object handler,
                             ModelAndView modelAndView) throws Exception {
          System.out.println("后置运行----b1");
      }
  
      //所有拦截器的后置执行全部结束后，执行该操作
      @Override
      public void afterCompletion(HttpServletRequest request,
                                  HttpServletResponse response,
                                  Object handler,
                                  Exception ex) throws Exception {
          System.out.println("完成运行----c1");
      }
  }
  ```

  说明：三个方法的运行顺序为    preHandle → postHandle → afterCompletion，如果 preHandle 返回值为 false，三个方法仅运行preHandle

* web.xml：

  ```xml
  CharacterEncodingFilter + DispatcherServlet
  ```

* 配置拦截器：spring-mvc.xml

  ```xml
  <mvc:annotation-driven/>
  <context:component-scan base-package="interceptor,controller"/>
  <mvc:interceptors>
      <mvc:interceptor>
          <mvc:mapping path="/handleRun"/>
          <bean class="interceptor.MyInterceptor"/>
      </mvc:interceptor>
  </mvc:interceptors>
  ```

  注意：配置顺序为**先配置执行位置，后配置执行类**

# 7. 异常处理

## 7.1 异常使用

### 7.1.1 处理器方法

异常处理器： **HandlerExceptionResolver** 接口

类继承该接口的以后，当开发出现异常后会执行指定的功能

```java
@Component
public class ExceptionResolver implements HandlerExceptionResolver {
    @Override
    public ModelAndView resolveException(HttpServletRequest request,
                                         HttpServletResponse response,
                                         Object handler,
                                         Exception ex) {
        System.out.println("异常处理器正在执行中");
        ModelAndView modelAndView = new ModelAndView();
        //定义异常现象出现后，反馈给用户查看的信息
        modelAndView.addObject("msg","出错啦！ ");
        //定义异常现象出现后，反馈给用户查看的页面
        modelAndView.setViewName("error.jsp");
        return modelAndView;
    }
}
```

根据异常的种类不同，进行分门别类的管理，返回不同的信息：

```java
public class ExceptionResolver implements HandlerExceptionResolver {
    @Override
    public ModelAndView resolveException(HttpServletRequest request,
                                         HttpServletResponse response,
                                         Object handler,
                                         Exception ex) {
        System.out.println("my exception is running ...." + ex);
        ModelAndView modelAndView = new ModelAndView();
        if( ex instanceof NullPointerException){
            modelAndView.addObject("msg","空指针异常");
        }else if ( ex instanceof  ArithmeticException){
            modelAndView.addObject("msg","算数运算异常");
        }else{
            modelAndView.addObject("msg","未知的异常");
        }
        modelAndView.setViewName("error.jsp");
        return modelAndView;
    }
}
```

### 7.1.2 注解方式

使用注解实现异常分类管理，开发异常处理器

@ControllerAdvice 注解：

* 类型：类注解

* 位置：异常处理器类上方

* 作用：设置当前类为异常处理器类

* 格式：

  ```java
  @Component
  //声明该类是一个Controller的通知类，声明后该类就会被加载成异常处理器
  @ControllerAdvice
  public class ExceptionAdvice {
  }  
  ```

@ExceptionHandler 注解：

* 类型：方法注解

* 位置：异常处理器类中针对指定异常进行处理的方法上方

* 作用：设置指定异常的处理方式

* 说明：处理器方法可以设定多个

* 格式：

  ```java
  @Component
  @ControllerAdvice
  public class ExceptionAdvice {
      //类中定义的方法携带@ExceptionHandler注解的会被作为异常处理器，后面添加实际处理的异常类型
      @ExceptionHandler(NullPointerException.class)
      @ResponseBody
      public String doNullException(Exception ex){
          return "空指针异常";
      }
  
      @ExceptionHandler(Exception.class)
      @ResponseBody
      public String doException(Exception ex){
          return "all Exception";
      }
  }
  ```


@ResponseStatus 注解：

* 类型：类注解、方法注解

* 位置：异常处理器类、方法上方

* 参数：

  value：出现错误指定返回状态码

  reason：出现错误返回的错误信息

### 7.1.3 统一异常处理

#### I 异常处理器

在包中建立包handler

在handler包中创建统一异常处理类GlobalExceptionHandler.java：

```java
@ControllerAdvice
public class GlobalExceptionHandler {
    @ExceptionHandler(Exception.class)
    @ResponseBody
    public R error(Exception e){
        e.printStackTrace();
        return R.error();
    }

    @ExceptionHandler(ArithmeticException.class)
    @ResponseBody
    public R error(ArithmeticException e){
        e.printStackTrace();
        return R.error().message("执行了自定义异常");
    }
    @ExceptionHandler(GuliException.class)
    @ResponseBody
    public R error(GuliException e){
        e.printStackTrace();
        return R.error().message(e.getMsg()).code(e.getCode());
    }
}
```

#### II 自定义异常

在exception包中创建自定义异常类

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class GuliException extends RuntimeException {
	@ApiModelProperty(value = "状态码")
	private Integer code;
	
	private String msg;
}
```

#### III 使用异常

业务中需要的位置抛出GuliException

```java
try {
	int a = 10/0;
}catch(Exception e) {
	throw new GuliException(20001,"出现自定义异常");
}
```

## 7.2 异常原理

1. 执行目标方法，目标方法运行期间有任何异常都会被catch、而且标志当前请求结束；并且用 dispatchException封装异常对象

```java
catch (Exception ex) {
    dispatchException = ex;
}
catch (Throwable err) {
    dispatchException = new NestedServletException("Handler dispatch failed", err);
}
```

2. 进入视图解析流程`processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);`

```java
private void processDispatchResult(HttpServletRequest request, HttpServletResponse response,
                                   @Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv,
                                   @Nullable Exception exception) throws Exception {

    boolean errorView = false;

    if (exception != null) {
        if (exception instanceof ModelAndViewDefiningException) {
            logger.debug("ModelAndViewDefiningException encountered", exception);
            mv = ((ModelAndViewDefiningException) exception).getModelAndView();
        }
        else {
            Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null);
            //进行异常处理
            mv = processHandlerException(request, response, handler, exception);
            errorView = (mv != null);
        }
    }

   //接下来进行视图解析
}
```

3. 处理异常：`processHandlerException(request, response, handler, exception);`，处理完返回mv

```java
@Nullable
protected ModelAndView processHandlerException(HttpServletRequest request, HttpServletResponse response,
                                               @Nullable Object handler, Exception ex) throws Exception {

    
    // Check registered HandlerExceptionResolvers...
    ModelAndView exMv = null;
    if (this.handlerExceptionResolvers != null) {
        //遍历异常解析器，找到能解析的解析器进行解析，返回mv。
        //默认没有任何人能处理异常，所以异常会被抛出
        for (HandlerExceptionResolver resolver : this.handlerExceptionResolvers) {
            exMv = resolver.resolveException(request, response, handler, ex);
            if (exMv != null) {
                break;
            }
        }
    }
    if (exMv != null) {
        if (exMv.isEmpty()) {
            request.setAttribute(EXCEPTION_ATTRIBUTE, ex);
            return null;
        }
        // We might still need view name translation for a plain error model...
        if (!exMv.hasView()) {
            String defaultViewName = getDefaultViewName(request);
            if (defaultViewName != null) {
                exMv.setViewName(defaultViewName);
            }
        }
        if (logger.isTraceEnabled()) {
            logger.trace("Using resolved error view: " + exMv, ex);
        }
        else if (logger.isDebugEnabled()) {
            logger.debug("Using resolved error view: " + exMv);
        }
        WebUtils.exposeErrorRequestAttributes(request, ex, getServletName());
        return exMv;
    }

    throw ex;
}
```

1. 如果没有任何人能处理最终底层就会发送 /error 请求。会被底层的BasicErrorController处理
2. 解析错误视图；遍历所有的  ErrorViewResolver  看谁能解析。
3. 默认的 DefaultErrorViewResolver ,作用是把响应状态码作为错误页的地址，error/500.html 
4. 模板引擎最终响应这个页面 error/500.html 

# 8 文件传输

## 8.1 上传下载

上传文件过程：

![](https://gitee.com/seazean/images/raw/master/Frame/SpringMVC-上传文件过程分析.png)

MultipartResolver接口：

*  MultipartResolver 接口定义了文件上传过程中的相关操作，并对通用性操作进行了封装
*  MultipartResolver 接口底层实现类 CommonsMultipartResovler
*  CommonsMultipartResovler 并未自主实现文件上传下载对应的功能，而是调用了 apache 文件上传下载组件  

文件上传下载实现：

* 导入坐标

  ```xml
  <dependency>
      <groupId>commons-fileupload</groupId>
      <artifactId>commons-fileupload</artifactId>
      <version>1.4</version>
  </dependency>
  ```

* 页面表单 fileupload.jsp

  ```html
  <form method="post" action="/upload" enctype="multipart/form-data">
      <input type="file" name="file"><br>
      <input type="submit" value="提交">
  </form>
  ```

* web.xml

  ```xml
  DispatcherServlet + CharacterEncodingFilter
  ```

* 控制器

  ```java
  @PostMapping("/upload")
  public String upload(@RequestParam("email") String email,
                       @RequestParam("username") String username,
                       @RequestPart("headerImg") MultipartFile headerImg) throws IOException {
  
      if(!headerImg.isEmpty()){
          //保存到文件服务器，OSS服务器
          String originalFilename = headerImg.getOriginalFilename();
          headerImg.transferTo(new File("H:\\cache\\" + originalFilename));
      }
      return "main";
  }
  ```

## 8.2 名称问题

MultipartFile 参数中封装了上传的文件的相关信息。

1. 文件命名问题， 获取上传文件名，并解析文件名与扩展名

   ```java
   file.getOriginalFilename();
   ```

2. 文件名过长问题

3. 文件保存路径

   ```java
   ServletContext context = request.getServletContext();
   String realPath = context.getRealPath("/uploads");
   File file = new File(realPath + "/");
   if(!file.exists()) file.mkdirs();
   ```

4. 重名问题

   ```java
   String uuid = UUID.randomUUID.toString().replace("-", "").toUpperCase();
   ```

```java
@Controller
public class FileUploadController {
    @RequestMapping(value = "/fileupload")
	//参数中定义MultipartFile参数，用于接收页面提交的type=file类型的表单，表单名称与参数名相同
    public String fileupload(MultipartFile file,MultipartFile file1,MultipartFile file2, HttpServletRequest request) throws IOException {
        System.out.println("file upload is running ..."+file);
//        MultipartFile参数中封装了上传的文件的相关信息
//        System.out.println(file.getSize());
//        System.out.println(file.getBytes().length);
//        System.out.println(file.getContentType());
//        System.out.println(file.getName());
//        System.out.println(file.getOriginalFilename());
//        System.out.println(file.isEmpty());
        //首先判断是否是空文件，也就是存储空间占用为0的文件
        if(!file.isEmpty()){
            //如果大小在范围要求内正常处理，否则抛出自定义异常告知用户（未实现）
            //获取原始上传的文件名，可以作为当前文件的真实名称保存到数据库中备用
            String fileName = file.getOriginalFilename();
            //设置保存的路径
            String realPath = request.getServletContext().getRealPath("/images");
            //保存文件的方法，通常文件名使用随机生成策略产生，避免文件名冲突问题
            file.transferTo(new File(realPath,file.getOriginalFilename()));
        }
        //测试一次性上传多个文件
        if(!file1.isEmpty()){
            String fileName = file1.getOriginalFilename();
            //可以根据需要，对不同种类的文件做不同的存储路径的区分，修改对应的保存位置即可
            String realPath = request.getServletContext().getRealPath("/images");
            file1.transferTo(new File(realPath,file1.getOriginalFilename()));
        }
        if(!file2.isEmpty()){
            String fileName = file2.getOriginalFilename();
            String realPath = request.getServletContext().getRealPath("/images");
            file2.transferTo(new File(realPath,file2.getOriginalFilename()));
        }
        return "page.jsp";
    }
}
```

## 8.3 源码解析

**StandardServletMultipartResolver** 文件上传解析器

DispatcherServlet#doDispatch：

```java
protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {
    // 判断当前请求是不是文件上传请求
    processedRequest = checkMultipart(request);
    // 文件上传请求会对 request 进行包装，导致两者不相等，此处赋值为 true，代表已经被解析
    multipartRequestParsed = (processedRequest != request);
}
```

DispatcherServlet#checkMultipart：

* `if (this.multipartResolver != null && this.multipartResolver.isMultipart(request))`：判断是否是文件请求
  * `StandardServletMultipartResolver#isMultipart`：根据开头是否符合 multipart/form-data 或者 multipart/
* `return this.multipartResolver.resolveMultipart(request)`：把请求封装成 StandardMultipartHttpServletRequest 对象

开始执行 ha.handle() 目标方法进行数据的解析

* RequestPartMethodArgumentResolver#supportsParameter：支持解析文件上传数据

  ```java
  public boolean supportsParameter(MethodParameter parameter) {
      // 参数上有 @RequestPart 注解
      if (parameter.hasParameterAnnotation(RequestPart.class)) {
          return true;
      }
  }
  ```

* RequestPartMethodArgumentResolver#resolveArgument：解析参数数据，封装成 MultipartFile 对象

  * `RequestPart requestPart = parameter.getParameterAnnotation(RequestPart.class)`：获取注解的相关信息
  * `String name = getPartName(parameter, requestPart)`：获取上传文件的名字
  * `Object mpArg = MultipartResolutionDelegate.resolveMultipartArgument()`：解析参数
    * `List<MultipartFile> files = multipartRequest.getFiles(name)`：获取文件的所有数据

* `return doInvoke(args)`：解析完成执行自定义的方法，完成上传功能



# 9. 校验框架

## 9.1 概述

表单校验保障了数据有效性、安全性  

校验分类：客户端校验和服务端校验

* 格式校验
  * 客户端：使用Js技术，利用正则表达式校验
  * 服务端：使用校验框架 
* 逻辑校验
  * 客户端：使用ajax发送要校验的数据，在服务端完成逻辑校验，返回校验结果
  * 服务端：接收到完整的请求后，在执行业务操作前，完成逻辑校验

表单校验框架：

* JSR（Java Specification Requests）：Java 规范提案 

* 303：提供bean属性相关校验规则

* JCP（Java Community Process）：Java社区

* Hibernate框架中包含一套独立的校验框架hibernate-validator 

* 导入坐标：

  ```xml
  <!--导入校验的jsr303规范-->
  <dependency>
      <groupId>javax.validation</groupId>
      <artifactId>validation-api</artifactId>
      <version>2.0.1.Final</version>
  </dependency>
  <!--导入校验框架实现技术-->
  <dependency>
      <groupId>org.hibernate</groupId>
      <artifactId>hibernate-validator</artifactId>
      <version>6.1.0.Final</version>
  </dependency>
  ```

**注意：**
tomcat7：搭配hibernate-validator版本5.*.*.Final
tomcat8.5↑：搭配hibernate-validator版本6.*.*.Final  

## 9.2 基本使用

### 9.2.1 开启校验

名称：@Valid、@Validated
类型：形参注解
位置：处理器类中的实体类类型的方法形参前方
作用：设定对当前实体类类型参数进行校验
范例：  

```java
@RequestMapping(value = "/addemployee")
public String addEmployee(@Valid Employee employee) {
    System.out.println(employee);
}
```

### 9.2.2 设置校验规则

名称：@NotNull
类型：属性注解等
位置：实体类属性上方
作用：设定当前属性校验规则
范例：每个校验规则所携带的参数不同，根据校验规则进行相应的调整，具体的校验规则查看对应的校验框架进行获取

```java
public class Employee{
    @NotNull(message = "姓名不能为空")
    private String name;//员工姓名
}  
```

### 9.2.3 获取错误信息

```java
@RequestMapping(value = "/addemployee")
//Errors对象用于封装校验结果，如果不满足校验规则，对应的校验结果封装到该对象中，包含校验的属性名和校验不通过返回的消息
public String addEmployee(@Valid Employee employee, Errors errors, Model model){
    System.out.println(employee);
    //判定Errors对象中是否存在未通过校验的字段
    if(errors.hasErrors()){
        for(FieldError error : errors.getFieldErrors()){
        	//将校验结果添加到Model对象中，用于页面显示，返回json数据即可
            model.addAttribute(error.getField(),error.getDefaultMessage());
        }
        //当出现未通过校验的字段时，跳转页面到原始页面，进行数据回显
        return "addemployee.jsp";
    }
    return "success.jsp";
}  
```

通过形参Errors获取校验结果数据，通过Model接口将数据封装后传递到页面显示，页面获取后台封装的校验结果信息  

```html
<form action="/addemployee" method="post">
    员工姓名：<input type="text" name="name"><span style="color:red">${name}</span><br/>
    员工年龄：<input type="text" name="age"><span style="color:red">${age}</span><br/>
    <input type="submit" value="提交">
</form>
```

## 9.3 多规则校验

* 同一个属性可以添加多个校验器  

  ```java
  public class Employee{
      @NotBlank(message = "姓名不能为空")
      private String name;//员工姓名
  
      @NotNull(message = "请输入年龄")
      @Max(value = 60,message = "年龄最大值60")
      @Min(value = 19,message = "年龄最小值18")
      private Integer age;//员工年龄
  }
  ```

* 三种判定空校验器的区别 
  ![](https://gitee.com/seazean/images/raw/master/Frame/SpringMVC-三种判定空检验器的区别.png)

## 9.4 嵌套校验

名称：@Valid
类型：属性注解
位置：实体类中的引用类型属性上方
作用：设定当前应用类型属性中的属性开启校验
范例：

```java
public class Employee {
    //实体类中的引用类型通过标注@Valid注解，设定开启当前引用类型字段中的属性参与校验
    @Valid
    private Address address;
}
```

注意：开启嵌套校验后，被校验对象内部需要添加对应的校验规则  

```java
//嵌套校验的实体中，对每个属性正常添加校验规则即可
public class Address implements Serializable {
    @NotBlank(message = "请输入省份名称")
    private String provinceName;//省份名称

    @NotBlank(message = "请输入邮政编码")
    @Size(max = 6,min = 6,message = "邮政编码由6位组成")
    private String zipCode;//邮政编码
}
```

## 9.5 分组校验

分组校验的介绍

* 同一个模块，根据执行的业务不同，需要校验的属性会有不同
  * 新增用户
  * 修改用户
* 对不同种类的属性进行分组，在校验时可以指定参与校验的字段所属的组类别
  * 定义组（通用）
  * 为属性设置所属组，可以设置多个
  * 开启组校验

domain：

```java
//用于设定分组校验中的组名，当前接口仅提供字节码，用于识别
public interface GroupOne {
}
```

```java
public class Employee{
    @NotBlank(message = "姓名不能为空",groups = {GroupA.class})
    private String name;//员工姓名

    @NotNull(message = "请输入年龄",groups = {GroupA.class})
    @Max(value = 60,message = "年龄最大值60")//不加Group的校验不生效
    @Min(value = 18,message = "年龄最小值18")
    private Integer age;//员工年龄

    @Valid
    private Address address;
    //......
}
```

controller：

```java
@Controller
public class EmployeeController {
    @RequestMapping(value = "/addemployee")
    public String addEmployee(@Validated({GroupA.class}) Employee employee, Errors errors, Model m){
        if(errors.hasErrors()){
            List<FieldError> fieldErrors = errors.getFieldErrors();
            System.out.println(fieldErrors.size());
            for(FieldError error : fieldErrors){
                m.addAttribute(error.getField(),error.getDefaultMessage());
            }
            return "addemployee.jsp";
        }
        return "success.jsp";
    }
}
```

jsp：

```html
<form action="/addemployee" method="post"><%--页面使用${}获取后台传递的校验信息--%>
    员工姓名：<input type="text" name="name"><span style="color:red">${name}</span><br/>
    员工年龄：<input type="text" name="age"><span style="color:red">${age}</span><br/>
    <%--注意，引用类型的校验未通过信息不是通过对象进行封装的，直接使用对象名.属性名的格式作为整体属性字符串进行保存的，和使用者的属性传递方式有关，不具有通用性，仅适用于本案例--%>
    省：<input type="text" name="address.provinceName"><span style="color:red">${requestScope['address.provinceName']}</span><br/>
        <input type="submit" value="提交">
/form>
```
