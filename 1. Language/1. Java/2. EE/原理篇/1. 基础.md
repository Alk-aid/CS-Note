# 1. IOC

## 1.1 IOC基础

1. 依赖注入的方式

- setter注入: xml配置

```java
public class UserServiceImpl implents UserService{
     private UserDao userDao;
 
     @Autowired
     public setUserDao(UserDao userDao){
         this.userDao = userDao;
     }
 }
```

- 构造函数: `<constructor-arg>`是通过构造函数参数注入, 本质上是new UserServiceImpl(userDao)创建对象

```java
public class UserServiceImpl implents UserService{
    private UserDao userDao;
 
    @Autowired
    public UserServiceImpl(UserDao userDao){
        this.userDao = userDao;
    }
}
```

- 字段注入: 使用java反射来实现

```java
public class UserServiceImpl implents UserService{
     @Autowired
     private UserDao userDao;
 }
```

2. 构造器方式的好处

- **依赖不可变**：其他两种对于不支持final修饰的变量, 因为调用set方法前 已经完成了属性注入
- **完全初始化(无NPE)**: setter方式支持找不到就返回NULL; 而构造器对于参数字段 要求必须存在, 否则报错
- **单一职责原则**: 使用setter和field可能无法意识到注入的依赖过多, 而构造器方式可以很快发现

- **容器外部可复用**: field方式在外部环境下无法进行复用
- **提前暴露循环依赖**: 构造器方式的话在项目启动时就会发现循环依赖问题, 字段注入的话是得等到使用那个bean才可以
- **测试方便**: field注入不好测试, 且会有NPE问题(new的对象不会对其属性进行注入)

# 2. AOP

## 2.1 AOP基础

1. 术语:

- Joinpoint（连接点）：Spring只支持方法执行连接点, 在AOP中表示 **在哪干**

- Pointcut（切入点）：连接点的集合

- Advice（通知）：连接点上执行的行为

- Introduction（引入/引介）：就是对原始对象无中生有的添加成员变量或成员方法

- Aspect（切面）：通知、引入和切入点的组合

- Target（目标对象）：Spring AOP 通过代理模式实现，从而这个对象永远是被代理对象，在AOP中表示为**对谁干**

- Weaving（织入）：就是将挖掉的功能回填的动态过程

- Proxy（代理）：把切面连接到其它的应用程序类型或者对象上，并创建一个被通知的对象, 在AOP中表示为**怎么实现的**

  

# 3. MVC

