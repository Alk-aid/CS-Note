

# TODO

1. 方法引用: System.out::println 中`::`的用法



# 1. Stream 流

## 1.1 设计思想

- `函数式编程思想`: 将要处理的元素集合看作是一种流, 流中的元素不可变且只会被消费一次
- `操作对象`: 用来对集合进行链状流式的操作
- `操作流程`: 大多数中间操作都是垂直执行的, 但是和sorted 这样的是水平执行的
- `操作类型`: 中间操作 和 终端操作:
  - 中间操作: 会再次返回一个流, 所以可以执行链式操作, 如 filter过滤, map转换, sorted排序
  - 终端操作: 对流操作的一个结束动作，一般返回 `void` 或者一个非流的结果 
  - 中间操作的特性: 当且仅当存在终端操作时，中间操作操作才会被执行;

## 1.2 创建流

1. 适用对象: Collection 集合, 数组

2. 创建流的方式: Stream.of(), stream()

```java
// 1. 对于数组
Integer[] arr = new Integer[]{1, 2, 3, 4, 5, 6, 7};
Stream<Integer> stream1 = Stream.of(arr);
// 2. 对于 Colletion 集合
List<Integer> list = new ArrayList<>();
Stream<Integer> stream2 = list.stream();
```

## 1.3 中间操作

1. `filter`: 过滤操作, 从流中筛选出我们想要的元素

- 接收的是一个 Predicate: 接受一个输入参数返回一个布尔值结果

2. `map`: 把一个流中的元素转化成新的流中的元素

- 接收的是一个 Function: 接受一个输入参数 T，返回一个结果 R

## 1.4 终端操作

1. forEach:  循环遍历

- 接收的是一个 Consumer: 接受一个输入参数并且无返回的操作

2. collect: 将流中的元素转变成另外一个不同的对象

- 

3. reduce: 组合

- 

4. match:

- `anyMatch()`，只要有一个元素匹配传入的条件，就返回 true
- `allMatch()`，只有有一个元素不匹配传入的条件，就返回 false；如果全部匹配，则返回 true
- `noneMatch()`，只要有一个元素匹配传入的条件，就返回 false；如果全部匹配，则返回 true



1. collect: 将流中的元素转变成另外一个不同的对象; 

```java
.collect(Collectors.toList()); // 生成一个新的 List

Map<Integer, List<Person>> personsByAge = persons
    .stream()
    .collect(Collectors.groupingBy(p -> p.age)); // 以年龄为 key,进行分组

personsByAge
    .forEach((age, p) -> System.out.format("age %s: %s\n", age, p));

// age 18: [Max]
// age 23: [Peter, Pamela]
// age 12: [David]

Double averageAge = persons
    .stream()
    .collect(Collectors.averagingInt(p -> p.age)); // 聚合出平均年龄

System.out.println(averageAge);     // 19.0
```

# 2. 函数式接口

- Predicate
- Consumer
- Function
- Optional

