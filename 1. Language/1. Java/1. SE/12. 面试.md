# 1. 已完成的面经

# 2. 面经

boolean类型是否占固定数量字节

- JVM没有提供booolean类型专用的字节码指令，而是使用int相关指令来代替。boolean单独使用占据4个字节
- 对boolean数组的访问与修改，会共用byte数组的baload和bastore指令。所以boolean数组中boolean占据1个字节

1. &和&&的区别

- & 可以用于位运算和不断路的逻辑运算
- && 是会短路的逻辑与

2. String的hash问什么选择31这个数（ToDo）

- 31 * x 可以优化为 (1 << 5 - x)
- 偶数在乘法运算中会溢出

3. equals的条件

- 自反性，对称性，传递性，一致性（当x 和y 引用的对象信息没有被修改时，多次调用x.equals(y)应该得到同样的返回值）

4. 有字节流的情况下为什么还要有字符流

- JVM中使用的编码是Unicode,但是当数据从JVM存入到磁盘中时，需要进行转化；这个过程耗时，而且不知道编码类型容易乱码
- 所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。

5. 抽象类和接口

- 相同点：都不能被实例化
- 不同点：
  - 接口关键字用implement，继承关键字extends；Java是单继承，但是可以实现多个接口
  - 接口字段默认是public static final类型的；接口方法是public abstract的，只有定义没有实现，但是JDK8有default方法
  - 接口强调特定功能的实现（Like-A），而抽象类强调所属关系（IS-A）

6. abstract方法是否能被static，native，sychronized修饰

- abstract是只有定义没有实现的，所以必须被子类重写
- 而static是不能被子类重写，所以必须要有实现，矛盾
- native是由本地方法实现的，也有实现，矛盾
- synchronized和方法的实现细节有关，抽象方法不涉及实现细节，矛盾

8. 面向对象和面向过程的区别

- 面向对象有封装，继承，多态三大特性，可以设计出低耦合的系统；但是因为类调用要实例化，开销大，消耗资源
- 面向过程性能好，适用于单片机

9. 在 Java 中定义⼀个不做事且没有参数的构造⽅法的作⽤

- 子类执行构造方法时，如果没有显示调用父类构造器，第一行默认执行的是super()；
- 调用父类构造器的目的是帮助子类做初始化工作

# 优雅下线

