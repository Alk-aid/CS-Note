# 	1. 垃圾回收算法

## 1.1 标记阶段

标记阶段的目的：判断对象是否存活

标记阶段的算法：引用计数算法 和 可达性分析算法

引用计数算法：

- 给对象添加一个引用计数器，有引用指向他就+1，一个引用失效就-1；计数器为0标识对象死亡
- 存在无法解决循环引用的问题

可达性分析算法：

- 思想：以**GC Roots”**为起点，向下进行搜索，节点走过的路径称之为引用链；如果一个对象不在任何一个引用链上，则称为不可达

- 可以解决循环引用的问题；但是根节点枚举必须STW，因为分析工作必须在一个一致性的快照中进行

- 常见的GC ROOTS: 特点就是这些对象是正在被使用的，一定是存活对象

  - 虚拟机栈中引用的对象。

  - 本地方法栈内引用的对象

  - 方法区中类静态属性引用的对象

  - 方法区中常量引用的对象

  - 所有被同步锁持有的对象

## 1.2 清除阶段

标记清除算法：

- 通过可达性分析算法，标记哪些是存活的对象
- 垃圾回收器从头到尾进行线性的遍历，如果发现对象不可达就进行回收
- 空闲列表：这里的清除不是真的清除，而是将要清除的对象保存在空闲列表中；下次要new 一个新的对象时，可以直接覆盖空闲列表中的地址

复制算法：

- 把内存分为大小相同的两块，每次只用其中一块；GC时将存活的对象赋值到未被使用的内存块中，之后清除正在使用内存块中的所有对象
- 交换两个内存的角色，完成垃圾回收
- 新生代就使用了复制算法，Eden区和S0区存活对象整体复制到S1区

标记整理算法：

- 可达性分析算法标记所有被可达对象
- 所有的存活对象压缩到内存的一端，按顺序排放。之后，清理边界外所有的空间。

|              | 标记清除           | 标记整理         | 复制                                  |
| ------------ | ------------------ | ---------------- | ------------------------------------- |
| **速率**     | 中等               | 最慢             | 最快                                  |
| **空间开销** | 少（但会堆积碎片） | 少（不堆积碎片） | 通常需要活对象的2倍空间（不堆积碎片） |
| **移动对象** | 否                 | 是               | 是                                    |

# 2. 算法细节

## 2.1 根节点枚举

目的：找出所有的GC Roots

前提：需要STW，因为必须在一个能保持一致性的快照中，否则如果分析过程中引用关系发生了改变，会导致分析结果不准确

过程：

- 虚拟机能直接得到哪些地方存放着对象引用，因为目前主流的虚拟机使用的是准确式内存管理，可以知道内存中某个位置的数据具体是什么类型。比如内存中有一个32bit的整数，JVM能分辨出这是一个数值为123456的整型还是指向了123456的内存地址。
- 在HotSpot中是用了一种叫**OopMap的结构来存放一个对象内什么偏移量上是什么类型的数据**。
- 这样，GC在扫描时就可以直接得知这些信息了。

## 2.2 安全点/ 安全区域

安全点：

- 通过OopMap可以很快的完成GC Roots的枚举，但是导致引用关系发生变化的指令很多，不可能为每个指令都生成一个对应的OopMap，那样非常消耗内存。
- 所以JVM设置只有到达了安全点才能停下来进行根节点枚举，安全点的选定既不能太少以至于让GC等待时间过长，也不能过于频繁以至于过分增大运行时的负荷。
- 所以，“安全点”的选择基本上是以程序“是否具有让程序长时间执行的特征”为标准来选定的。因为每条执行指令执行的时间都非常地短暂，所以这个标准是实际上就是指令序列的一个复用。例如方法调用、循环跳转、异常跳转等。

找到安全点以后，如何在GC的时候让所有线程都跑到安全点呢。

1. 抢先式中断（不采用了）：系统中断所有用户线程，如果有线程不在安全点，就恢复线程，让线程跑到安全点
2. 主动式中断：设置一个标志位，需要GC的时候，就将标志位置为真，线程发现标志为真以后，就会在最近的安全点主动中断挂起

---

安全区域

- 安全点保证了程序在执行时能跑到安全点，但是如果程序不在执行，如sleep或者blocked时，线程就无法走到安全点了。因此引入了安全区域的概念
- 安全区域是指在一段代码片中，引用关系不会发生改变，实际上就是一个安全点的拓展。
- 当线程执行到安全区域时，首先标识自己已进入安全区域，那样，当在这段时间里JVM要发起GC时，就不用管标识自己为“安全区域”状态的线程了；当线程要离开安全区域时，就要检查是否完成了根节点枚举，没完成就必须一直等，直到收到可以离开的信号为止。

## 2.3 记忆集与卡表

出现原因：为了解决跨代引用问题

- 因为在收集新生代的时候，可能存在老年代指向新生代的引用。但是我们又不想把整个老年代作为GC ROOTS的扫描范围，所以引入了记忆集来解决跨代引用问题
- 将记忆集放在新生代中，存放着老年代对于新生代的引用，这样就可以不用遍历老年代就知道哪些对象被老年代对象所引用
- 记忆集根据记录的精度分三类：
  - 字长精度：记录的是老年代指向新生代地址。
  - 对象精度：记录的是老年代引用的新生代对象。
  - 卡精度：记录的是新生代一段地址是否存在被老年代引用的记录。

---

卡表：就是记忆集卡精度的一种实现

- 卡表就是一个字节数组，每一个元素都对应着一块内存区域，称之为卡页，在Hotspot里面，一个卡页占据512字节
- 如果卡页里面有对象存在跨代引用的话，就标记为1，就可以把它们加入到GC Roots里面一起扫描

---

写屏障：

- 记忆集卡页解决GC roots扫描范围的问题，但是没有解决卡表元素如何维护的问题；在JVM里面，卡表是通过写屏障维护的
- 可以看成是虚拟机层面在”引用类型字段赋值“这个动作的AOP切面，引用对象赋值的时候产生一个环形通知，进行一些额外的处理，这样就是引用对象赋值这个操作都在写屏障的覆盖范围内，赋值前的写屏障叫写前屏障，复制后的写屏障叫写后屏障。
- 这样我们就可以通过写屏障，一旦发生赋值操作就可以把引用的更新写进卡表。

## 2.4 并发的可达性分析

### 2.4.1 三色标记算法

在遍历对象图的过程中，把访问都的对象**按照"是否访问过"这个条件**标记成以下三种颜色：

**白色：表示对象尚未被垃圾回收器访问过**。显然，在可达性分析刚刚开始的阶段，所有的对象都是白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达。

**黑色：表示对象已经被垃圾回收器访问过，且这个对象的所有引用都已经扫描过**。黑色的对象代表已经扫描过，它是安全存活的，如果有其它的对象引用指向了黑色对象，无须重新扫描一遍。黑色对象不可能直接（不经过灰色对象）指向某个白色对象。

**灰色：表示对象已经被垃圾回收器访问过，但这个对象至少存在一个引用还没有被扫描过**。

可以看到，灰色对象是黑色对象与白色对象之间的中间态。当标记过程结束后，只会有黑色和白色的对象，而白色的对象就是需要被回收的对象。

### 2.4.2 并发标识的问题

如果标识的过程中用户线程是冻结的，那就不会有任何问题。

**但是垃圾回收器和用户线程同时运行呢？这个时候就有点意思了。**

垃圾回收器在对象图上面标记颜色，而同时用户线程在修改引用关系，引用关系修改了，那么对象图就变化了，这样就有可能出现两种后果：

**一种是把原本消亡的对象错误的标记为存活，这不是好事，但是其实是可以容忍的，只不过产生了一点逃过本次回收的浮动垃圾而已，下次清理就可以。**（浮动垃圾）

- 第一次初始标记不是垃圾，在并发标记过程中变成了垃圾的那些对象。因为重新标记是只针对 第一次初始标记的那些GCRoots

**一种是把原本存活的对象错误的标记为已消亡，这就是非常严重的后果了，一个程序还需要使用的对象被回收了，那程序肯定会因此发生错误。**

怎么消亡的--需要满足的条件

> - 赋值器插入了一条或多条从黑色对象到白色对象的新引用
> - 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用

解决方案

> 由于两个条件之间是当且仅当的关系。所以，我们要解决并发标记时对象消失的问题，只需要破坏两个条件中的任意一个就行。
>
> 于是产生了两种解决方案：**增量更新（Incremental Update）和原始快照（Snapshot At The Beginning，SATB）。**
>
> 在HotSpot虚拟机中，**CMS是基于增量更新来做并发标记的，G1则采用的是原始快照的方式。**

- 增量更新（`Incremental Update`）

  > 破坏的是第一个条件。当黑色对象插入新的指向白色对象的引用关系时，记录这个引用，等并发扫描结束后重新扫描一遍这个黑色对象，相当于他变回了灰色对象。
  >
  > ![img](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/170726cb3673541b~tplv-t2oaga2asx-watermark.awebp)
  
- 原始快照（`Shapshot At The Begining，SATB`）

  > 破坏的是第二个条件。
  >
  > 当有灰色对象需要删除指向白色的对象的引用关系的时候,将这个删除的引用记录下来,再并发结束之后,再将这些记录过的关系中以灰色对象为根,重新扫描一次,这样就能扫描到的白色对象,然后将这些对象标记成黑色(目的就是让这种对象在本轮gc清理中能存活下来，待下一轮gc的时候重新扫描，这个对象也有可能是浮动垃圾)
  >
  > 根重新扫描一次。
  >
  > ![img](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/170726d12a19361a~tplv-t2oaga2asx-watermark.awebp)

> 需要注意的是，上面的介绍中无论是对引用关系记录的插入还是删除，**虚拟机的记录操作都是通过写屏障实现的**。
>
> **增量更新用的是写后屏障(Post-Write Barrier)，记录了所有新增的引用关系。**
>
> **原始快照用的是写前屏障(Pre-Write Barrier)，将所有即将被删除的引用关系的旧引用记录下来。**

增量更新：黑色对象新增一条指向白色对象的引用，那么要进行深入扫描白色对象及它的引用对象。

原始快照：灰色对象删除了一条指向白色对象的引用，实际上就产生了浮动垃圾，好处是不需要像 CMS 那样 remark，再走一遍 root trace 这种相当耗时的流程。

我的理解：SATB相对增量更新效率会高(当然SATB可能造成更多的浮动垃圾)，因为不需要在重新标记阶段再次深度扫描被删除引用对象，而CMS对增量引用的根对象会做深度扫描，G1因为很多对象都位于不同的region，CMS就一块老年代区域，重新深度扫描对象的话G1的代价会比CMS高，所以G1选择SATB不深度扫描对象，只是简单标记，等到下一轮GC再深度扫描。

# 3. 垃圾回收器

串行和并行之分：串行是只有一个CPU进行GC；并行是同时有多个CPU进行GC

独占 和 并发 ： 独占是指GC一旦运行，就停止所有的应用程序；并发是指垃圾回收器与应用程序线程可以交替工作

## 3.1 垃圾回收器分类

- 串行回收器：Serial、Serial old
- 并行回收器：ParNew、Parallel Scavenge、Parallel old
- 并发回收器：CMS、G1

![image-20200713094745366](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/image-20200713094745366-1624753881325.png)

## 3.2 Serial回收器：串行回收

Serial回收器

- 串行回收--也就是单线程
- 独占式
- 采用复制算法，用于新生代

Serial Old回收器

- 串行回收--也就是单线程
- 独占式
- 采用标记-压缩算法，用于老年代
- 用途：与新生代的Parallel scavenge配合使用； 作为老年代CMS收集器的后备垃圾收集方案

![image-20200713100703799](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/image-20200713100703799.png)

## 3.3 ParNew回收器：并行回收

- ParNew收集器则是Serial收集器的多线程版本。除了采用**并行回收**的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别
- 并行式(多线程)，独占式，采用复制算法

![image-20200713102030127](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/image-20200713102030127.png)

## 3.4 Parallel回收器：吞吐量优先

Parallel

- 多线程，独占式，采用复制算法
- ParNew关注的是缩短STW，而Parallel关注的是提高吞吐量（CPU 用于运行用户代码的时间占总时间的比值）
- 低STW有利于交互式，而高吞吐量有利于后台运算完成大量任务

Parallel Old

- 多线程的，独占式的，标记-压缩算法
- Parallel Scavenge + Parallel Old,**在Java8中，是默认垃圾收集器。**

![image-20200713110359441](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/image-20200713110359441.png)

## 3.5 CMS回收器：低延迟

特点

- 多线程，并发(垃圾线程和用户线程并发运行)

- 作用于老年代，采用标记-清除算法，分配空间使用空闲列表法
- 目的：缩短STW，而不是没有STW

工作过程

- **初始标记**: 仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。（根节点枚举）
- **并发标记**: 从Gc Roots的直接关联对象开始遍历整个对象图的过程，它在整个回收过程中耗时最长，不需要停顿。（三色标记）
- **重新标记**: 为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿
- **并发清除**: 此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的

![image-20200713205154007](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/image-20200713205154007.png)

Serial Old作为备用：

- 因为在垃圾收集阶段用户线程没有中断，所以在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用。
- 因此，CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，**而是当堆内存使用率达到某一阈值时，便开始进行回收**，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。
- 要是CMS运行期间预留的内存无法满足程序需要，就会出现一次**“Concurrent Mode Failure”** 失败，这时虚拟机将启动后备预案：临时启用Serial old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。

## 3.6 G1回收器： 区域化分代式

1. G1采用内存分区(Region)的思路，将内存划分为一个个相等大小的内存分区，回收时则以分区为单位进行回收
2. 通过记录每个 Region 垃圾回收时间以及回收所获得的空间(这两个值是通过过去回收的经验获得)，并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。
3. 回收时则以分区为单位进行回收，存活的对象复制到另一个空闲分区中。由于都是以相等大小的分区为单位进行操作，因此G1天然就是一种压缩方案(局部压缩)；

被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备一下特点：

- **并行与并发**：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。
- **分代收集**：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。
- **空间整合**：与 CMS 的“标记-清理”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。
- **可预测的停顿**：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。

G1 收集器的运作大致分为以下几个步骤：

- **初始标记**：Stop The World，仅使用一条初始标记线程对所有与 GC Roots 直接关联的对象进行标记。
- **并发标记**：使用**一条**标记线程与用户线程并发执行。此过程进行可达性分析，速度很慢。
- **最终标记**：Stop The World，使用多条标记线程并发执行。
- **筛选回收**：回收废弃对象，此时也要 Stop The World，并使用多条筛选回收线程并发执行。

![image](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/f99ee771-c56f-47fb-9148-c0036695b5fe.jpg)

## 3.7 如何挑选垃圾回收器

- 优先调整堆的大小让JVM自适应完成。
- 如果内存小于100M，使用串行收集器
- 如果是单核、单机程序，并且没有停顿时间的要求，串行收集器
- 如果是多CPU、需要高吞吐量、允许停顿时间超过1秒，选择并行或者JVM自己选择
- 如果是多CPU、追求低停顿时间，需快速响应（比如延迟不能超过1秒，如互联网应用），使用并发收集器
- 官方推荐G1，性能高。现在互联网的项目，基本都是使用G1。

最后需要明确一个观点：

- 没有最好的收集器，更没有万能的收集
- 调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器

# 4. 其他

## 4.1 引用

- 强引用：只有有强引用关系，那么即使报OOM也不会回收被引用的对象
- 软引用：在要报OOM以前，会把弱引用指向的对象进行回收；软引用适合用于缓存，当内存不足的时候把它删除掉，使用的时候再加载进来

```java
Object obj = new Object();
SoftReference<Object> sf = new SoftReference<Object>(obj);
obj = null;  // 使对象只被软引用关联
```

- 弱引用（WeakReference）：发现即回收，被被弱引用关联的对象只能生存到下一次垃圾收集之前。弱引用适合解决某些地方的内存泄漏的问题

```java
Object obj = new Object();
WeakReference<Object> wf = new WeakReference<Object>(obj);
obj = null;
```

- 虚引用（PhantomReference）：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。主要作用是跟踪对象被垃圾回收的状态。仅仅是提供了一种确保对象被 finalize 以后, 做某些事情的机制。（管理堆外内存）

```java
Object obj = new Object();
PhantomReference<Object> pf = new PhantomReference<Object>(obj);
obj = null;
```

## 4.2 STW

- Stop-the-World，简称STW,暂停所有的应用程序的线程。
- 被STW中断的应用程序线程会在完成GC之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所以我们需要减少STW的发生。
- STW事件和采用哪款GC无关，所有的GC都有这个事件。
- 可达性分析算法中枚举根节点（GC Roots）会导致所有Java执行线程停顿，为什么需要停顿所有 Java 执行线程呢？
- 开发中不要用System.gc() ，这会导致Stop-the-World的发生。

## 4.3 finalize

由于finalize()方法的存在，**虚拟机中的对象一般处于三种可能的状态。**

- 可触及的：从根节点开始，可以到达这个对象。
- 可复活的：对象的所有引用都被释放，但是对象有可能在finalize()中复活。
- 不可触及的：对象的finalize()被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，**因为finalize()只会被调用一次**。

具体过程

- 如果对象objA到GC Roots没有引用链，则进行第一次标记。
- 如果对象没有重写finalize方法，或者finalize已经被调用了，则对象被判定为不可达
- 如果对象重写了finalize方法，并且没有被调用，则对象为可复活状态，可能在执行finalize阶段重新和引用链上的对象建立链接，成功复活

特点

- finalize() 方法允许在子类中被重写，**用于在对象被回收时进行资源释放**。
- 但是 try-finally 等方式可以做的更好，并且该方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。

## 4.4 内存溢出

没有空闲内存，并且垃圾收集器也无法提供更多内存。

没有足够的空闲内容，并且GC以后也无法提供足够的内存

造成的主要原因有

- 内存泄露问题
- 堆内存设置不够
- 存在大量对象，但是长时间不能被垃圾收集器收集

## 4.5 内存泄漏

概念：对象不会再被使用，但是仍有引用指向它，导致不能被回收的情况

危害：一旦发生内存泄漏，可用内存就会被逐步蚕食，最终导致OOM

常见例子：

- 单例模式
- 资源未被close，如数据库连接，socket连接，IO连接必须要被手动close，不然不会被回收
- static集合类，会导致容器中的对象在程序结束之前都不能被释放(是一种长生命周期对象持有它的引用而导致不能被回收)
- 缓存泄露，可以使用WeakHashMap来解决

解决方式:(TODO)

- 

## 4.6 内存分配策略

1. **对象优先在 Eden 分配**

大多数情况下，对象在新生代 Eden 区分配，当 Eden 区空间不够时，发起 Minor GC。

2. **大对象直接进入老年代**

大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。

经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。

-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 区和 Survivor 区之间的大量内存复制。

3. **长期存活的对象进入老年代**

为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。

-XX:MaxTenuringThreshold 用来定义年龄的阈值。

4. **动态对象年龄判定**

虚拟机并不是永远地要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。

5. **空间分配担保**

在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。

如果不成立的话虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那么就要进行一次 Full GC。

## 4.7 Full GC 的触发条件

对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件:

1. 调用 System.gc()

> 只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。

2. 老年代空间不足

> 老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。
>
> 为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。

3. 空间分配担保失败

> 使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。具体内容请参考上面的第五小节。

4. JDK 1.7 及以前的永久代空间不足

> 在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。
>
> 当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。
>
> 为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。

5. Concurrent Mode Failure

> 执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足(可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足)，便会报 Concurrent Mode Failure 错误，并触发 Full GC。

## 4.8 分代收集算法

**为什么要使用分代收集算法**: 主要基于两个思想

- 一是大多数对象都是朝生夕死的；二是熬过越多次GC越难以消亡
- 因此对于存活时间短的对象应该频繁进行GC；对于存活时间长的对象可以以较低频率进行GC。所以可以将生命周期少的放到新生代生命周期长的放到老年代
- 同时垃圾回收算法也是各有优劣的，对于新生代和老年代可以使用不同的垃圾回收算法，来提高垃圾回收效率

新生代适用于复制算法，速度快，而且内存规整

老年代

- 区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。
- 适用于标记-清除或者是标记-清除与标记-整理；



以HotSpot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。对于碎片问题，CMS采用基于Mark-Compact算法的Serial Old回收器作为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用Serial Old执行Full GC以达到对老年代内存的整理。

## 4.9 增量收集算法

思想：

- 每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。
- 总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过**对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作**

优缺点

- 线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，**造成系统吞吐量的下降**。
- 使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。

# 5. 面试



1. System.gc()和Runtime.gc()会做什么事情？

   

   

   
