> https://github.com/rbmonster/learning-note#%E8%AE%BE%E8%AE%A1%E6%A1%88%E4%BE%8B

# 1.  High Concurrnet

<img src="https://aikaid-img.oss-cn-shanghai.aliyuncs.com/img-2022/high-concurrency-system-design.png" alt="high-concurrency-system-design" style="zoom:33%;" />

1. 系统拆分:

- 将一个系统拆分为多个子系统, 用 dubbo 来搞
- 然后每个系统连一个数据库，将一个数据库扩展为多个数据库

2. 缓存: 

- 大部分的高并发场景，都是**读多写少**
- 比如使用 redis, 轻轻松松单机几万的并发

3. MQ: **高并发写情况**

- 使用 MQ 进行流量削峰, 大量的写请求灌入 MQ 里
- **后边系统消费后慢慢写**，控制在 mysql 承载范围之内

4. 分库分表: 

- 可能到了最后数据库层面还是免不了抗高并发的要求
- 将一个数据库拆分为多个库，多个库来扛更高的并发；
- 然后将一个表**拆分为多个表**，每个表的数据量保持少一点，提高 sql 跑的性能

5. 读写分离:

- 搞个主从架构，**主库写**入，**从库读**取，搞一个读写分离。**读流量太多**的时候，还可以**加更多的从库**

6. ES



# 2. High Available

1. 注重代码质量
2. 使用集群, 减少单点故障
3. 限流: 监控应用流量的 QPS 或并发线程数等指标，当达到指定的阈值时对流量进行控制，以避免被瞬时的流量高峰冲垮，从而保障应用的高可用性
4. 超时 和 重试机制
5. 熔断机制: 当所依赖的服务恶化或者调用失败次数达到某个阈值的时候就迅速失败，让当前系统立即切换依赖其他备用服务
6. 异步调用: 减少耦合
7. 使用缓存

# 3. High 