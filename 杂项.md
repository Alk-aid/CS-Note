# 1. 看门狗

> redlock工业上有争议

看门狗解决的问题:



- 假如有一个业务,它需要分布式锁,但是它的执行时间可能是一分钟，也可能是八分钟, 这个时候怎么设置过期时间

  

  

  

# 2. 线上排查

# 3. 写库 & 发消息

1. 前端点一下, 服务端耗时很长, 所以希望在5s内只处理一次

>使用分布式锁实现
>
>- 把前端的请求参数作为key, 然后使用redis分布式锁 设置超时时间为5s
>- 其他请求没拿到锁就直接返回, 因为redis分布式锁 不阻塞(set if not exist, 也就是**只有不存在的时候才设置, 设置成功时返回1**)

2. 写库, 然后发消息, 写完库, 发消息前机器挂掉了怎么办

> 1. 保证这两步的原子性
> 2. 定时对账, 对不上就回滚

3. 保证幂等

> 情况: 消息队列会有重复投递的问题, 这时候后端需要保证幂等
>
> - 使用messageid作为key，过期时间为5分钟
> - 然后再去做业务
> - 业务做完以后将messigeid放到redis中

# 4. 优雅下线

# 5. CountDownLatch

> **让一个或者多个线程等待，直到其他线程的一系列操作完成**
>
> CountDownLatch初始化的时候，需要提供一个整形数字，数字代表着线程需要调用countDown()方法的次数，当计数为0时，线程才会继续执行await()方法后的其他内容

- 将一个程序分为n个互相独立的可解决任务，并创建值为n的CountDownLatch
- 当每一个任务完成时，都会在这个锁存器上调用countDown，等待问题被解决的任务调用这个锁存器的await，将他们自己拦住，直至锁存器计数结束



大量数据插到数据库里，它把数据拆开，任务放到线程池里，然后调用countdown，主线程在外面用await实现异步转同步



# 6. 公平锁 和 非公平锁

1. 公平锁: 不会出现饿死, 但是性能开销大
2. 非公平锁: 会出现饿死, 但是性能开销小, 因为线程有可能少一次排队, 阻塞 和 唤醒

# 7. 获取技术最新动向

1. Github Trending
2. https://www.reddit.com/r/java/
3. https://github.com/CodingDocs/awesome-java



- 面向 b 端采购平台的搭建, 拉齐供应商的履约能力, 客户采购上的诉求, 把双方的需求匹配起来
- 智能决策履约, 实现万仓合一, 万单合一
- b 端 一种解决方案 满足多种需求
