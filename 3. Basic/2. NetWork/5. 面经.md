# 1. 综合篇

## 1.1 在浏览器输入 URL 回车之后发生了什么

1. URL 解析

- 判断是否是一条合法的URL，并且根据内容进行自动补全，ASCII编码
- 检测是否缓存了目标URL页面，如果缓存没过期，则直接展示缓存界面，无需向服务器进行请求

2. DNS 查询： 将域名解析为对应的IP地址

- 客户端发出请求，先在浏览器，本地的hosts文件，路由器查找缓存；没找到就向dns服务器发起请求
- DNS查找缓存；没找到就去询问根DNS服务器，顶级域DNS服务器，权威域DNS服务器，最后得到对应的IP地址返回给客户端

3. 发起 TCP连接：三次握手建立TCP连接，保证通信的可靠性

4. 发起 HTTP/HTTPS 请求：

- TLS在TCP协议上，通过四次握手建立TLS连接保证通信的安全性
- 建立TCP,TLS协议后，通过HTTP进行通信

5. 服务器处理请求，返回对应的HTTP响应

6. 浏览器解析 渲染页面
7. HTTP请求结束，可能断开TCP连接

## 1.2 各层常用协议

应用层：HTTP,DNS,SSH,DHCP,TELENT,FTP(文件传输协议),SMTP(简单邮件传输协议)

- TCP对应协议：HTTP,FTP,SMTP,TELNET
- UDP对应协议：DNS

传输层：TCP,UDP

网络层：IP,ARP,RARP,ICMP,IGMP,RIP,OSPF,BGP

数据链路层：ARQ,CSMA/CD,PPP

物理层：中继器，集线器，网线，HUB

## 1.4 DNS劫持

- 概念：将原域名对应的IP地址进行替换从而使得用户无法访问到正确的网址
- 范围：域名劫持只能在特定的网络范围，范围外的DNS服务器能够返回正常的IP地址
- 步骤：
  - 获取要劫持的域名信息
  - 控制窃取域名对应的E-mail账号，然后修改注册信息(DNS服务器信息)；
- 预防手段：
  - 直接使用IP地址
  - 通过网络设置让 DNS 指向正常的域名服务器，如8.8.8.8

---

DNS为什么使用UDP

- 因为通过DNS查询IP，请求和返回的内容不多，一般不超过UDP报文的最大长度
- 使用UDP，没有三次握手，提高响应效率；但是要求域名服务器自己处理超时重传等可靠性措施

---

Forward 和 Redirect

- Forward：只发起一次请求，
- Redirect：会发起两次请求，第一次请求会返回状态码301，302；第二次访问的地址在第一次响应的Location字段里面

## 1.5 CSRF与XSS攻击与防护

XSS: 跨站脚本攻击（Cross Site Scripting）

- 攻击：攻击者往Web页面中插入恶意Script代码，当用户浏览该页时，嵌入Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。类似于SQL注入。
- 预防：
  - 对数据进行编码，比如把 > 替换成 &gt
  - innerHTML改成innerText：innerText会去除掉html标签，而innerHtml不会去除掉html标签  
  - **字符过滤**: 过滤掉特殊的HTML标签，例如<script>、<iframe>等；

**跨站点请求伪造（Cross-Site Request Forgery）**

- 攻击：用户访问正常网站A，A产生cookie返回到浏览器；同时在相同浏览器访问B，B返回攻击性代码请求访问A；从而在用户不知情的情况下携带cookie信息访问A; A不知道请求是B发出来的，会根据Cookie信息以及用户的权限处理该请求，从而导致B的恶意代码被执行
- 预防： 
  - **将cookie设置为HttpOnly。**从而js等无法读取到cookie
  - 验证Http **Referer** 字段。
  - 在请求中加入Token验证；如果token没有或者不正确则拒绝访问。
  - 使用验证码，强制用户和应用程序进行交互

## 1.6 DNS为什么使用UDP

因为如果使用TCP的话，域名解析时间变为了: TCP连接时间 + DNS交易时间

使用UDP的话,	    域名解析时间变为了: DNS交易时间

因为很多时候DNS解析要去请求根DNS，顶级域DNS，权威域DNS等涉及到了多次查询，如果使用TCP的话就会建立多次连接，十分浪费时间

---

UDP的弱点，因为物理链路的最小MTU = 576，所以DNS将报文限制在512字节，一旦超过512字节就会将超过的进行抛弃

为了克服这种问题，使用TCP进行DNS查询

## 1.7 IPV6

IPV4 和 IPV6的区别

- IPV4的IP地址长度为32位，IPV6为128位
- IPV6可自动装配，即使没有DHCP服务器也可以实现自动分配IP地址
- IPV6有应对伪造IP地址的网络安全功能以及防止线路窃听的功能，提高了安全性
- IPV6包首部长度固定40字节，去掉了包头检验和，简化了首部结构，减轻了路由表符负荷，提高了传输效率

# 2. TCP篇

## 2.1 TCP的最大连接数

> https://blog.csdn.net/coderising/article/details/116077502?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-116077502-blog-102783937.pc_relevant_multi_platform_whitelistv4&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-116077502-blog-102783937.pc_relevant_multi_platform_whitelistv4&utm_relevant_index=3

客户端最大连接数：端口的大小是16位，其中0是预留端口(在TCP/UDP传输中不会被使用)；所以客户端最大tcp连接数为65535

服务器最大连接数：

- 确定一个连接是由源IP,目标IP,源端口，目标端口；其中目标IP和目标端口是不变的，变的是源IP和源端口
- IP32位，端口16位；因此理论上最大TCP连接数 = 客户端的IP数 ✖ 客户端的端口数 = 2^32 ✖ 2^16 = 2^48
- 实际上远远达不到理论上线；主要受到文件描述个数的限制 和 内存的限制
- ulimit配置文件描述符的数目，所以文件描述符的个数是有限的
- 每一个连接都对应着一个socket文件，每个socket文件占用15~20k；而操作系统的内存是有限的
- 同时前1024个端口是预留的，不一定能被使用
- 考虑C10K问题，也就是单机1万个并发连接问题，解法方法IO多路复用。

fd上限：http://www.ideabuffer.cn/2016/11/20/Linux%E9%85%8D%E7%BD%AE%E8%B0%83%E4%BC%98%EF%BC%9A%E6%9C%80%E5%A4%A7%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%AA%E6%95%B0/

## 2.2 UDP实现可靠传输

- 添加seq/ack机制，确保数据发送到对端
- 添加发送和接收缓冲区，主要是用户超时重传。
- 添加超时重传机制。

## 2.3 TIME_WAIT 和 CLOASE_WAIT过多

首先出现TIME_WAIT的一方是主动关闭的一方，出现CLOASE_WAIT的一方是被动关闭的一方

出现TIMEWAIT过多

- 原因：高并发的爬虫服务器或者WEB服务器在访问量大时出现这种情况
- 危害：linux给一个用户的文件描述符和端口号是有限的，如果出现大量TIME_WAIT占据文件描述符和端口的话，会导致文件描述符和端口不够用，使得无法处理新的请求；同时文件描述符和端口也是占据空间的，浪费内存
- 解决：
  - 修改配置：允许将TIME-WAIT sockets重新用于新的TCP连接，开启快速回收
  - 使用长连接，从根本上减少关闭连接的次数

服务器存在大量CLOSEWAIT是因为什么，怎么解决

- 出现原因：在对方关闭连接之后，服务器程序进入CLOSE_WAIT状态，但是程序没有检测到或者忘记关闭自己到对方的连接了
- 危害：同上
- 解决：检查代码，看哪里逻辑上出现了问题

## 2.4 检验和如何计算

伪首部：伪首部包含IP首部一些字段，目的是为了检查数据是否到达正确的目的地

计算过程：

- 把伪首部添加到UDP上
- 计算初始时是需要将检验和字段添零的；
- 把所有位划分为16位（2字节）的字，把所有16位的字相加，如果遇到进位，则将高于16字节的进位部分的值加到最低位上
- 将所有字相加得到的结果应该为一个16位的数，将该数取反则可以得到检验和checksum。      

## 2.5 TCP如何最大化利用现有网络带宽

- nagle: 
- 延迟ack: 

## 其他

客户端connect 和 服务器accept

- 客户端connect成功返回是在第二次握手
- 服务器accept成功返回是三次握手后

从上面的描述过程，我们可以得知客户端connect成功返回是在第二次握手，服务端accept成功返回是在三次握手成功之后。

---

客户端调用close流程

- 客户端调用close，向服务器发送FIN报文
- 服务器收到FIN报文，TCP协议栈会在FIN包插入一个EOF到接收缓冲区中，这样当服务器的程序调用read来读这个FIN包时。就知道客户端要关闭连接；

---

第三次握手可以带数据吗

- 可以，因为第三次握手时已经建立了从客户端到服务器的连接
- 前面不可以是因为，假如第一次握手可以携带数据的话，有人可以通过发送大量无用数据来攻击服务器

# 3. Http篇

## 3.1 Get和Post

1. 作用：GET 用于获取资源，而 POST 用于传输实体主体。
2. 参数：GET把参数包含在URL中，POST通过request body传递参数。
3. 安全/幂等：GET是安全和幂等的，POST不是安全和幂等的。（所有的安全方法也都是幂等的。）
4. 可缓存：如果要对响应进行缓存，需要满足以下条件：
   - 请求方法是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。
   - 响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501。
   - 响应报文的 Cache-Control 首部字段没有指定不进行缓存。
5. 有的浏览器对于POST请求是先发送Header，在发送Data

> 安全和幂等
>
> 安全：指的是请求方式不会破坏服务器上面的资源
>
> 幂等：多次执行相同的操作，结果都是相同的
>

## 3.2 Cookie和Session

1. Cookie和Session都是由服务器产生的，用来存储特定的值（是一种key-value结构）
2. 其中Cookie通过`响应头中的set-cookie`交给客户端，并存储在客户端当中。至于Session会将SessionID以`set-cookie: JSESSIONID=xxx`的形式交给客户端，从而使得同一次会话可以访问到相同的Session。Session本身是存储在服务器的。



Cookie 和 Session 有什么不同？

- 作用范围不同：Cookie 保存在客户端（浏览器），Session 保存在服务器端。

- 存取方式的不同：Cookie 只能保存 ASCII，Session 可以存任意数据类型，一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等。

- 有效期不同：Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效。

- 隐私策略不同：Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些。

- 存储大小不同：单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie。



为什么需要 Cookie 和 Session

- 因为HTTP是无状态的，而有时候我们需要知道本次操作用户是否登录，是哪个用户在执行的操作。所以需要借助于Cookie和Session

- 用户第一次请求服务器，服务器根据用户提交的相关信息，创建创建对应的 Session，请求返回时将SeesionID返回给浏览器，浏览器接收到SessionID 后将其存入到Cookie中。

- 当用户第二次访问服务器，请求会带上对应域名的Cookie，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息；

- 如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。

- 所以，SessionID 是连接 Cookie 和 Session 的一道桥梁，大部分系统也是根据此原理来验证用户登录状态。



如果浏览器中禁止了 Cookie，如何保障整个机制的正常运转。

- 每次请求中都携带一个 SessionID 的参数，可以拼接在URL后面，也可以通过POST提交
- Token 机制：当用户第一次登录后，服务器根据提交的用户信息生成一个 Token，响应时将 Token 返回给客户端，以后客户端只需带上这个 Token 前来请求数据即可，无需再次登录验证。

如何考虑分布式 Session 问题：在互联网公司为了可以支撑更大的流量，后端往往需要多台服务器共同来支撑前端用户请求，那如果用户在 A 服务器登录了，第二次请求跑到服务 B 就会出现登录失效问题。

- 共享 Session，将用户的 Session 等信息使用缓存中间件来统一管理，保障分发到每一个服务器的响应结果都一致。
- Session 复制。任何一个服务器上的 Session 发生改变（增删改），该节点会把这个 Session 的所有内容序列化，然后广播给所有其它节点。
- Nginx ip_hash 策略，服务端使用 Nginx 代理，每个请求按访问 IP 的 hash 分配，这样来自同一 IP 固定访问一个后台服务器，避免了在服务器 A 创建 Session，第二次分发到服务器 B 的现象。

如何解决跨域请求？

> 所谓同源是指"协议+域名+端口"三者相同，即便两个不同的域名指向同一个 ip 地址，也非同源。
>
> 1. 通过代理来避免，比如使用 Nginx 在后端转发请求，避免了前端出现跨域的问题。
> 2. 通过 Jsonp 跨域。
>

## 3.3 注入/ 攻击

SQL注入

- 把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。
- 应对方法：使用预编译手段，进行参数绑定；使用# 或者 $ 来获取参数值。其中 \$是拼接，会有SQL注入风险

 XSS攻击

- 在数据中插入一些符号以及javascript代码，那么这些数据将会成为应用代码中的一部分了，那么攻击者就可以肆无忌惮地展开攻击

## 3.5 状态码

301 和 302

- 301 是永久重定向，比如域名更改了
- 302 是临时重定向，资源还在只是暂时不能访问了，可以用于访问某个资源需要权限，需要用户登录才能访问

# 4. 强缓存，协商缓存

https://segmentfault.com/a/1190000021661656

缓存指的是：浏览器在本地保存对访问过的资源的副本

缓存的优点

- 降低服务器的压力，加快客户端加载页面的速度
- 减少重复数据的请求，节省流量

强缓存 和 协商缓存

- 读取缓存，判断缓存是否过期，如果没有过期则是强缓存；直接返回缓存中的数据，状态码是200
- 如果过期了，就要向服务器发送一个请求(请求首部字段会带有etag 和 last-modified)，如果经过验证，发现资源仍然有效，则返回一个304的状态码，让客户端从本地缓存中读取

客户端判断缓存是否过期的方式：`Expires` 和 `Cache - Control`字段

服务器判断缓存是否过期的方式: `ETag` 和 ` If-Modified-Since`

