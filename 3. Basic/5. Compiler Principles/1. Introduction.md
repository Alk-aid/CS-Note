# 1. Language Processors

## 1.1 Compiler And Interperter

- `Compiler`: 
  
  - 编译器是一个将一种语言翻译为另一种语言的程序
  - 编译器的一个重要作用是报告翻译阶段的错误
  
  ![image-20220308104251857](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/image-20220308104251857.png)
  
- `Interpreter`:
  
  - 直接利用用户提供的input执行源程序中的指定的操作
  - source program 和 input 通过 interpreter 产生 output
  
  ![image-20220308104311597](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/image-20220308104311597.png)
  
- `Comparison`
  - 解释程序不产生目标代码
  - 在将input转化为output中，编译器比解释器快
  - 解释器的错误诊断效果比编译器好

## 1.2 The life Cycle Of A program

将源文件转化为`可执行目标文件`的命令

```shell
gcc -o <target_file_name> <source_file_name>
gcc -o hello hello.c
```

1. 预处理，Using `preprocessor`

- .c文件 -> .i文件
- 宏的展开，删除注释，引入头文件(#include),处理所有的条件编译指令(#if,#iddef)
- 源文件可能会被分割为多个模块，预处理器负责整合这些模块成一个文件

2. 编译，Using `Compiler`

- .i文件 -> .s文件；
- 主要处理是： 词法分析，语法分析，语义分析，以及进行优化后生成相应的汇编代码

3. 汇编，Using `Assembler`

- .s 文件 -> .o文件；从汇编文件转化为二进制机器码文件（`可重定位目标程序`,relocatable object program）

4. 链接，Using `Linker`

- 在程序中可能调用了某个库文件中的函数等问题需要链接来解决, 将有关的目标文件彼此相连接，使得所有的这些目标文件成为一个能够被操作系统装入执行的统一整体, 也就是`可执行文件`

![image-20220109133520360](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/image-20220109133520360.png)

# 2. The Structure Of a Compiler

编译过程的前端部分：主要依赖于源程序 和 目标机无关

- `词法分析`：将字符流识别为一个个单词；输出一个 `token stream`
- `语法分析`：在词法分析的基础上，将单词序列分解成各类语法单位，如程序，语句，表达式；输出一个`syntax tree`
- `语义分析`：审查程序是否有语义错误，为代码生成阶段收集类型信息;输出一个 `syntax tree`
- `中间代码生成`：常用的如`三地址指令`。目的是为了容易翻译成目标代码;输出一个 `intermeiate representation`
- `优化`：对中间代码进行优化; 输出`intermediate representation`
- 以及每个阶段对应 `表格管理` 和 `出错处理`

编译器的后端部分：不依赖源程序，只和中间代码有关的工作

- `目标代码生成`：把中间代码变成绝对指令代码 或 可重定位的指令代码 或 汇编指令代码;输出`tareget-machine code`
- 以及每个阶段对应 `表格管理` 和 `出错处理`



<img src="http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/image-20220308155025057.png" alt="image-20220308155025057" style="zoom: 25%;" />

# 3. Grammer and Language

基本概念

- `字母表(alphabet)`: 一个有穷的符号集合，如ASCII, UNICODE，{0，1}都是字母表
- `串（string）`：    字母表中符号的一个有穷序列，`句子` 和 `字` 是 串 的同义词
- `语言(language)`:  某个字母表上一个任意的可数的串集合

运算： 其中 * 具有最高优先级，连接其次，| 最低优先级

- Concatenation:   LM = {st| s属于L 且 t属于M}
- Union：  L | M = {s| s属于L 或者 s属于M}
- 指数运算: $$s^i =  s^{i-1}s$$ 
- 闭包运算：L* = $$U_{i=0}^{∞}L^i$$
- $$r^+ = rr^*$$
- $$r? = r | e$$

---

语法 = 词法规则 + 语法规则

- `词法规则`：规定字母表哪些字符是单词。我们使用Regex 和 FA来描述词法结构 和 进行词法分析
- `语法规则`：如何从单词来构成语法单位。使用CFG来描述语法规则。
- `语法单位`：表达式，子句，语句，函数，程序
- 语法定义了程序的形式结构

---

文法是描述语法结构的形式规则

一个context-free grammer由四个元素组成

- `终结符号`：本质上是token的第一分量 也就是 `token-name`
- `非终结符号`: 也称之为`语法变量`，每一个 非终结符号 表示一个 终结符号串 的集合
- `产生式`：由 `产生式头`(非终结符号) ， 一个箭头， 一个 `产生式体`(终结符号以及非终结符号组成的序列)
- `开始符号`：指定一个 非终结符号 为 开始符号; 该文法中最大的语法成分

![image-20220509164923411](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/image-20220509164923411.png)

---

文法的分类：是一个逐级包含的结构

- 0型文法：产生式头至少包含一个非终结符
- 1型文法(上下文有关文法)：a -> b 中 |a| <= |b|
- 2型文法(上下文无关文法)：产生式头是一个非终结符
- 3型文法(正则文法)：右部最多只有一个终结符

---

推导：用产生式的右部替换产生式的左部

- 从开始符号出发，不断将某个非终结符号替换为该非终结符号的某个产生式的体。（自顶向下）
- 有`在最左推导` 和 `在最右推导`两种策略
- `句型`：从开始符号推导得到的一个既可以包含终结符号 又 包含非终结符号 或者 空串
- `句子`：不包含非终结符号的句型
- `短语`：给定一个句型，其分析树中的每一棵子树的边缘称为该句型的`短语`
- 一个文法生成的语言：它的所有句子的集合

规约：推导的逆过程

- 从给定的源语言的句子开始，通过规则的左部取代右部，最终达到开始符号

语言：由文法G的开始符号S推导出的所有句子构成的集合

---

CFG的分析树：是`推导`的图形表示形式

- 根节点的标号表示该文法的开始符号
- 每个内部节点的标号为 一个非终结符号
- 每个叶子节点的标号为 可以是非终结符 也可以是终结符
- 内部节点对应产生式的头，子节点对应产生式的体
- 从左到右排列叶子节点得到的符号串是这棵树的`产出(yield)` 或者 `边缘(frontier)`

---

二义性：

- 定义：一个文法可以为某个句子生成多颗语法分析树；也就是对同一个句子由多个推导的文法
- 举例：id + id * id 
- 可以根据结合性 和 优先级 消除
- 判定：ToDo

# 4. Error Handle

错误：

- `词法错误`: 标识符，关键字，运算符乒拼写错误； 没有在字符串文本上正确的加引号
- `语法错误`：分号放错地方；括号缺失或多余；
- `语义错误`：运算符 和 运算分量之间的类型补匹配（如void返回值 却返回了int类型
- `逻辑错误`： 使用==的地方使用了=

错误恢复的策略：

- `恐慌模式`
- `短语层次恢复`
- `错误产生式`
- `全局纠正`
