# 1. The Role Of Lexical Analysis

主要任务：

- 读入源程序的输入字符，将他们组成一个个`词素`, 生成并输出词法单元(token)序列, 每个token对应一个词素
- 会将一个标识符的词素添加到符号表中去

​							$$ <token-name, attribute-value>$$

> example:
>
> ```java
> position = intitial + rate * 60
> ```
>
> 其中
>
> - postion是一个 lexeme，被映射为 一个 token `<id, 1>`
> - = 是一个lexeme，被映射为 一个token `<=>`
>
> 经过lexical analyzer以后被映射为 the sequence of token
>
> ​			$$ <id, 1> <=> <id,2> <+> <id,3> <*> <60>$$

额外任务：

- 过滤掉注释 和 空白
- 将编译器生成的错误信息 和 源程序的位置联系起来
- 宏的展开

名词解释：

- `token`：由一个token-name 和 可选的attribute-value组成，其中attribute-value是指向symbol table某项的一个指针
- `pattern`: 一个token的词素可能具有的形式
- `词素`：字符系列，和某个token的pattern匹配

# 2. Regex

正则表达式：就是给`集合取名字`，然后使用U，连接，闭包`运算` 来 定义pattern

正则定义：就是给正则表达式取名字

名词

- `字母表(alphabet)`: 一个有限的符号集合，如ASCII, UNICODE，{0，1}都是字母表
- `串（string）`：    字母表中符号的一个有穷序列，句子 和 字 是 串 的同义词
- `语言(language)`:  某个字母表上一个任意的可数的串集合

运算：其中 * 具有最高优先级，连接其次，U最低优先级

- 连接:   LM = {st| s属于L 且 t属于M}
- 并运算：  L U M = {s| s属于L 或者 s属于M}
- 指数运算: $$s^i =  s^{i-1}s$$ 
- 闭包运算：L* = $$U_{i=0}^{∞}L^i$$
- $$r^+ = rr^*$$
- $$r^? = r | e$$

![image-20220330191716936](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/image-20220330191716936.png)

# 3. Finite Automata

名词概念

- `状态(circle)`: 看作是位于lexemeBegin指针 和 forward指针之间的字符的总结
- `边(edge)`: 从图的一个状态指向另一个状态，每条边的标号包含 1个至多个符号
- `不确定的有穷自动机`：对其边上的标号没有任何限制，一个符号标记可以离开同一状态的多条边；e也可以作为`标号`
- `确定的有穷自动机`： 对于每个状态和符号有且只有一条离开该状态，以该符号为标号的边
- 可以将FA表示为一张转换图(`transition graph`), 图中的结点是状态，带有标号的边表示转换函数

## 3.1 Nondeterministic Finite Automata

NFA由以下几个部分组成：

- 一个有穷的状态集合S
- 一个输入符号集合<img src="C:\Users\86191\AppData\Roaming\Typora\typora-user-images\image-20220330204313025.png" alt="image-20220330204313025" style="zoom: 67%;" />，即输入字母表，假设e不是其中的元素
- 一个转换函数，为每个状态和每个符号都给出了相应的 后继状态(next state)集合

## 3.2 Deterministic Finite Automata

DFA由以下几个部分组成：

- 没有输入e之上的转换动作
- 对每个状态s和每个输入符号a，有且只有一条标记为a的边离开s

## 3.3 NFA -> DFA

