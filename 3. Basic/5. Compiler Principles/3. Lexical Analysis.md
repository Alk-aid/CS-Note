# 1. The Role Of Lexical Analysis

主要任务：

- 读入源程序的输入字符，将他们组成一个个`词素`, 生成并输出词法单元(token)序列, 每个token对应一个词素

- 会将一个标识符的词素添加到符号表中去，其中的attribute-value是一个指向符号表对应条目的指针

​							$$ <token-name, attribute-value>$$

额外任务：

- 过滤掉注释 和 空白；通过设计对应的pattern来实现
- 将编译器生成的错误信息 和 源程序的位置联系起来
- 宏的展开

名词解释：

- `token`：由一个token-name 和 可选的attribute-value组成，其中attribute-value是指向symbol table某项的一个指针
- `pattern`: 一个token的词素可能具有的形式
- `词素`：源程序的一个字符序列，和某个token的pattern匹配的 一个实例

<img src="http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/image-20220509211603132.png" alt="image-20220509211603132" style="zoom:50%;" />

# 2. Regex

Regex：

- 用来描述词素模式的一种表示方法
- 给`集合取名字`，然后使用U，连接，闭包`运算` 来 定义pattern

名词

- `字母表(alphabet)`: 一个有限的符号集合，如ASCII, UNICODE，{0，1}都是字母表
- `串（string）`：    字母表中符号的一个有穷序列，`句子` 和 `字` 是 串 的同义词
- `语言(language)`:  某个字母表上一个任意的可数的串集合

运算： 其中 * 具有最高优先级，连接其次，| 最低优先级

- Concatenation:   LM = {st| s属于L 且 t属于M}
- Union：  L | M = {s| s属于L 或者 s属于M}
- 指数运算: $$s^i =  s^{i-1}s$$ 
- 闭包运算：L* = $$U_{i=0}^{∞}L^i$$
- $$r^+ = rr^*$$
- $$r? = r | e$$

![image-20220330191716936](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/image-20220330191716936.png)

为了解决二义性：

- 匹配的时候，遵循选择最长匹配的方式

- 如果最长的可能前缀 与多个 模式 匹配，总是选择在lex程序中先被列出的模式

# 3. Finite Automata

名词概念

- `状态(state)`: 看作是位于lexemeBegin指针 和 forward指针之间的字符的总结
- `边(edge)`: 从图的一个状态指向另一个状态，每条边的标号包含 1个至多个符号
- `不确定的有穷自动机`：对其边上的标号没有任何限制，一个符号标记可以离开同一状态的多条边；e也可以作为`标号`
- `确定的有穷自动机`： 对于每个状态和符号有且只有一条离开该状态，以该符号为标号的边
- `状态转换图`：将一个pattern转化为流程图
- 可以将FA表示为一张转换图(`transition graph`), 图中的结点是`状态` ，带有标号的边表示`转换函数`

> FA是一个Regex的实现模型

## 3.1 Nondeterministic Finite Automata

NFA由以下几个部分组成：

- 一个有穷的状态集合S
- 一个输入符号集合<img src="C:\Users\86191\AppData\Roaming\Typora\typora-user-images\image-20220330204313025.png" alt="image-20220330204313025" style="zoom: 67%;" />，即输入字母表，假设e不是其中的元素
- 一个转换函数集合，为每个状态和每个符号(<img src="http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/image-20220330204313025.png" alt="image-20220330204313025" style="zoom: 67%;" /> U e)都给出了相应的 后继状态(next state)集合
- 同一符号 可以 标记 从 同一状态 出发到多个 目标状态 的多条边

例如一个能识别 $$(a | b)^* abb$$ 的NFA的转换图

- 一个NFA接收输入字符串x，当且仅当对应的转换图中存字一条从 开始状态 到某个接收状态的 路径

![image-20220509224221990](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/image-20220509224221990.png)

## 3.2 Deterministic Finite Automata

DFA由以下几个部分组成：

- No e-moves
- 对每个状态s和每个输入符号a，有且只有一条标记为a的边离开s（One transition per input per state）

![image-20220509224930109](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/image-20220509224930109.png)

> - NFA抽象地表示了用来识别某个语言的串的算法
> - DFA是一个简单具体的识别串的算法
> - 在构造词法分析器的时候，我们真正实现或模拟的是DFA

# 4. Regex -> FA

![image-20220510163416862](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/image-20220510163416862.png)

## 4.1 Regex -> NFA

## 4.2 NFA -> DFA



`子集构造法`：

- 让构造得到的DFA的每个状态 对应于 NFA的一个状态集合

<img src="http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/image-20220510094338353.png" alt="image-20220510094338353" style="zoom:50%;" />

![image-20220510094355222](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/image-20220510094355222.png)

# 5. Lexical Analyzer Generator

## 5.1 Lex

## 5.2 Design of LAG
