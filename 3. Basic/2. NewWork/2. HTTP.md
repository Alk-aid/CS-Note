# 1. Http基本

## 1.1 基本概念

HTTP(超文本传输协议，HyperText Transfer ProtocOl) 是⼀个在计算机世界⾥专⻔在「两点」之间「传输」⽂字、图⽚、⾳频、视频等「超⽂本」数据的「约定和规范」。(是双向的)

## 1.2 HTTP状态码

|      | 类别                           | 原因短语                                         |
| ---- | ------------------------------ | ------------------------------------------------ |
| 1xx  | Informational(信息性状态码)    | 提示信息，表示目前是协议处理的中间状态           |
| 2xx  | Success(成功状态码)            | 成功，报文已经被收到并正确处理                   |
| 3xx  | Redirection(重定向状态码)      | 重定向，资源位置发生变动，需要客户端重写发送请求 |
| 4xx  | Client Error(客户端错误状态码) | 客户端错误，请求报文有误，服务器无法处理         |
| 5xx  | Server Error(服务器错误状态码) | 服务器错误，服务器在处理请求内部发生了错误       |

1. 200 OK
2. 204 No Content：处理成功，但是没有资源可以返回，也就是`响应报文中不包含主体部分`

> 当用户在浏览器窗口window或者frame/iframe框架中导航的时候.
>
> - 如果导航到的URL返回了一个没有响应体的HTTP/200响应,则页面将会显示一个空白文档(就是一片白色).页面的URL地址也会变成新指定的URL.
>- 如果服务器返回的是一个HTTP/204响应,当前页面不会有任何变化,就好像根本没有进行导航操作一样.页面的URL地址也保持不变.

3. 206 Partial Content: 是应用于HTTP分块下载或断点续传，表示响应返回的body数据不是资源的全部，而是其中的一部分。

---

1. 301 Moved Permanently(永久性重定向)：请求的资源不在了，需要改用新的URL再次访问
2. 302 Found(临时性重定向)：请求的资源还在，但暂时需要用另一个URL来访问

> 301和302都会在响应头里使用字段Location,指明后续要跳转的URL，浏览器会自动重新定向新的URL

4. 304 Not Modifies：不具备跳转含义，表示资源未修改，重定向已存在的缓存文件，也称作缓存重定向。

---

1. 400 Bad Request：请求报文中存在语法错误：笼统的错误
2. 401 Unauthorized：发送的请求需要通过HTTP认证的认证信息，如果之前进行过一次请求，则表示认证失败
3. 403 Forbidden：访问被服务器拒绝
4. 404 Not Found：服务器没有这个资源

---

1. 500 Internal Server Error：服务器在执行请求时发送了错误。笼统通用的错误码
2. 501 Not Implemented 表示客户端请求的功能暂时还不支持
3. 502 Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应。
4. 503 Service Unavailable：服务器暂时处于超负载或正在进行停机维护
4. 504 Gateway Time-out：作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器或者辅助服务器（例如DNS）收到响应。

## 1.3 请求方式

1. **GET**:目的是获取资源(我要访问你的资源)
2. **POST**：目的是传输实体主体(我要把这条信息告诉你，响应就是 你接受数据的处理结果)
3. PUT:目的是传输文件(我要把这份文件传给你)，存在安全性问题
3. PATCH: 对资源进行部分修改

5. HEAD：目的是获取响应报文首部（和GET一样，但是不返回报文主体）

6. DELETE:目的是删除文件（按请求URI删除指定资源，和put一样存在安全性问题）

7. OPTIONS：查询指定的URL能够支持的方法，会返回Allow：GET，POST，HEAD这样的内容。

8. TRACE：追踪路径(让web服务亲将之前的请求通信环回给客户端)

9. CONNECT:要求用隧道协议连接代理

## 1.4 HTTP报文

报文由以下部分组成

- 请求行(响应行)
- 首部字段
- 空行
- 请求体(响应体)

### 1.4.1 请求行/响应行

请求行： <请求方法> <请求URI> <协议版本>

响应行： <协议版本> <状态码> <原因短语>

### 1.4.2 首部字段

请求首部字段

|     首部字段名      |                      说明                       |
| :-----------------: | :---------------------------------------------: |
|       Accept        |            用户代理可处理的媒体类型             |
|   Accept-Charset    |                  优先的字符集                   |
|   Accept-Encoding   |         接收的压缩方法，如gzip，deflate         |
|   Accept-Language   |             优先的语言（自然语言）              |
|      If-Match       |              比较实体标记（ETag）               |
|  If-Modified-Since  |               比较资源的更新时间                |
|    If-None-Match    |        比较实体标记（与 If-Match 相反）         |
|      If-Range       |      资源未更新时发送实体 Byte 的范围请求       |
| If-Unmodified-Since | 比较资源的更新时间（与 If-Modified-Since 相反） |
|       Referer       |            对请求中 URI 的原始获取方            |
|     User-Agent      |              HTTP 客户端程序的信息              |
|        Host         |               请求资源所在服务器                |

> 比如我在`www.sojson.com` 里有一个`www.baidu.com` 链接，那么点击这个`www.baidu.com` ，它的`header` 信息里就有：
>
> Referer=https://www.sojson.com

响应首部字段

| 首部字段名 |            说明             |
| :--------: | :-------------------------: |
|    ETag    |       资源的匹配信息        |
|  Location  |  令客户端重定向至指定 URI   |
| Set-Cookie | 服务器端向客户端发送 cookie |

通用首部字段：请求和响应都会用到的首部

|  首部字段名   |          说明           |
| :-----------: | :---------------------: |
| Cache-Control |     控制缓存的行为      |
|  Connection   | 1.1版本默认为Keep-Alive |
|      Via      |  代理服务器的相关信息   |

实体首部字段：实体部分使用的字段

|    首部字段名    |          说明          |
| :--------------: | :--------------------: |
|      Allow       | 资源可支持的 HTTP 方法 |
| Content-Encoding | 数据的压缩方式，如gzip |
| Content-Language |   实体主体的自然语言   |
|  Content-Length  |     实体主体的大小     |
| Content-Location |   替代对应资源的 URI   |
|   Content-Type   |   实体主体的媒体类型   |
|     Expires      | 实体主体过期的日期时间 |
|  Last-Modified   | 资源的最后修改日期时间 |

## 1.5 HTTP优缺点

### 1.5.1 优点

HTTP最突出的优点就是 简单，灵活和易于扩展，应用广泛和跨平台

#### I 简单

HTTP的报文格式都是header + body，头部信息也是key-value的形式，易于理解

#### II 灵活和易于扩展

1. HTTP的各类请求方法，状态码，URI都不是固定死的，可以自定义
2. HTTP是在最上层的，下层可以随意变动（比如HTTPS就是在HTTP和TCP之中加入了SSL/TLS安全传输层）

### 1.5.2 缺点

#### I 无状态

无状态(stateless)协议：对于发送过来的请求和响应都不做持久化处理，并不保留之前一切的请求或响应报文的信息

好处是：不需要额外资源来记录状态信息，减轻服务器的负担，更多的CPU和内存用于提供服务。

缺点是：在进行有关联性的操作时会非常麻烦。比如登录-->添加购物车-->下单--->结算-->支付

**无状态问题的解决：Cookie技术**

#### II 不安全

Http存在以下不足

- 通信使用明文(不加密)，内容可能会被窃听  --> 需要加密
- 不验证通信方的身份，因此有可能遭遇伪装  --> 需要认证
- 无法证明报文的完整性，所以有可能已经遭到篡改 --> 需要完整性保护

HTTP的问题可以通过HTTPS来解决，也就是引入SSL/TLS层

## 1.7 URI和URL

- URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。
- URL(Uniform Resource Locator) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。

URL是URI的子集

URI 的作用像身份证号一样，URL 的作用更像家庭住址一样。URL 是一种具体的 URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。

# 2. HTTPS

## 2.1 http与https的区别

1. HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议
2. http连接建立简单，tcp三次握手之后就可以进行报文传输。而https在tcp三次握手后，还要进行SSL/TLS的握手过程，用来交换会话密钥
3. HTTP是明文传输，而HTTPS会通过密钥对传输的报文进行加密。
4. https使用摘要算法来检验报文是否被篡改。
5. https协议需要向CA申请数字证书，来进行身份验证。
6. HTTP的端口是80，HTTPS的端口是443

## 2.2 https解决了哪些问题

### 2.2.1 混合加密

通过混合加密可以保证信息的机密性，无法被窃听。

混合加密：对称加密和非对称加密的结合方式

- 通信建立前`采用非对称加密的方式` 交换 在稍后的对称密钥加密中要使用的`密钥 `

- 通信过程中全部使用`对称加密`

采用混合加密的原因

- 对称加密只使用一个密钥，运算速度快，密钥必须保密，但是**无法解决密钥交换的安全问题**
- 非对称加密使用两个密钥：公钥和密钥。公钥可以任意分发而密钥保密，**解决了密钥交换问题**，但是速度慢

> 对称加密主要的运算是**位运算**，速度非常快；非对称加密计算涉及到大数乘法、大数模等；

非对称加密的流程如下，这里的消息可以是 **对称加密中的密钥**

<img src="http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/20180622101050714" alt="img" style="zoom:25%;" />

> 对称加密的密钥 即用于 加密 也用于解密
>
> 非对称加密的密钥
>
> 1. 既然是加密，那肯定不希望别人知道我的消息，所以只有我才能解密，所以得出公钥负责加密，私钥负责解密
> 2. 既然是签名，那肯定是不希望有人冒充我发消息，只有我才能发布这个签名，所以得出私钥负责签名，公钥负责验收

### 2.2.2 摘要算法

1. 对明纹通过摘要算法得到一个指纹，发送的时候把[明纹 + 指纹]一起加密，然后发送给服务器
2. 服务器解密后，用相同的摘要算法求出一个指纹，然后和明文自带的进行比较，如果相同则说明数据完整

### 2.2.3 数字证书

客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。

**这就存在些问题，如何保证公钥不被篡改和信任度？**

所以这里就需要借助第三方权威机构 CA（数字证书认证机构），将服务器公钥放在数字证书（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。

**签发流程**

1. 首先CA把持有者的公钥，用途，颁发者，有效时间等信息打包成一个包，然后进行hash计算
2. 然后CA用自己的私钥将该Hash值加密，生成Certificate Signature，也就是CA对证书进行了签名
3. 最后将Certificate Signature添加在文件证书上，形成数字证书

**验证流程**

1. 首先客户端使用同样的hash算法获取该证书的hash值H1
2. 然后用CA的公钥对数字证书进行解密，得到其中的hash值H2
3. 然后对比h1和h2

<img src="C:\Users\86191\AppData\Roaming\Typora\typora-user-images\image-20220101151043873.png" alt="image-20220101151043873" style="zoom: 50%;" />



## 2.3 HTTPS握手

### 2.3.1 基本流程

SSL/TLS 协议基本流程：

-   客户端向服务器索要并验证服务器的公钥。
-   双方协商生产「会话秘钥」。
-   双方采用「会话秘钥」进行加密通信。

前两步也就是 SSL/TLS 的建立过程，也就是`握手阶段`。主要目的就是**协商产生会话密钥**

SSL/TLS 的「握手阶段」涉及四次通信，可见下图：

> 通常经过2个RTT的时延就可以在安全的通信环境里发送HTTP报文

SSL/TLS 协议建立的四次握手：

1. ClientHello

   首先，由客户端向服务器发起加密通信请求，也就是 ClientHello 请求。

   在这一步，客户端主要向服务器发送以下信息：

   1.  客户端支持的 SSL/TLS 协议版本，如 TLS 1.2 版本。
   2.  支持的生成会话密钥的加密算法，如 RSA 加密算法。
   3.  客户端生产的随机数（Client Random），后面用于生产「会话秘钥」。

2. ServerHello，Certificate，ServerHello Done

   服务器收到客户端请求后，向客户端发出响应，也就是 SeverHello。服务器回应的内容有如下内容：

   1.  确认 SSL/ TLS 协议版本，如果浏览器不支持，则关闭加密通信。
   2.  确认生成会话密钥的加密算法，如 RSA 加密算法。
   3.  服务器生产的随机数（Server Random），后面用于生产「会话秘钥」。
   4.  服务器的数字证书。

3. Client Key Exchange,Change Cipher Spec,Finished

   客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。

   如果证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使用它加密报文，向服务器发送如下信息：

   1.  一个随机数（pre-master key）。该随机数会被服务器公钥加密。
   2.  加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。
   3.  客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，然后用会话密钥加密一下。

   > 上面第一项的随机数是整个握手阶段的第三个随机数，这样服务器和客户端就同时有三个随机数，接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」。

4. Change Ciper Spec,Finished

   服务器收到客户端的第三个随机数（pre-master key）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。然后，向客户端发生最后的信息：

   1.  加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。
   2.  服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。

至此，整个 SSL/TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。

## 2..4 RSA算法

最大的问题不支持前向保密。

客户端传递随机数是用公钥加密的，服务器是用私钥解密的。一旦服务器的私钥(这个是非对称加密的私钥)泄露后，所有的TLS通讯密文都被破解了。

## 2.4 ECDHE算法

这个是各大服务器常用的。

是非对称加密算法，因此它可以用来密钥交换。其核心思想是离散对数。

### 2.4.1 离散对数

$$
a^i (\ mod\ p) = b
$$

a是底数，模数p，b是真数，i是对数。

知道了对数很容易知道真数，但是反过来知道真数很难推出对数。

所以把真数可以用作公钥，对数用作私钥。

### 2.4.2 DH算法

1. 确定模数P和底数G，这两个是公开的
2. 客户端X和服务器Y各自生成一个随机整数作为**私钥**，A的密钥用a代称，B的密钥用b代称
3. 求出各自的公钥A和B,A和B也是公开的，因为从真数反向计算对数很困难

- X的公钥记作 A = $G^a$ (mod P )；
- Y的公钥记作 B = $G^b$ ( mod P )；

4. 求出会话密钥K

- X执行：$B^a$ ( mod P )
- Y执行：$A^b$ ( mod P )

### 2.4.3 DHE算法

这个E是ephemeral(临时性的)

也就是双方的私钥在每次密钥交换通信时都是随机生成的。这样即使某个黑客破解了某一次通信的私钥，其他通信过程的私钥仍然是安全的，具有前向安全。

### 2.4.4 ECDHE算法

DHE因为计算性能不佳，需要做大量的乘法，为了提高性能就出现了ECDHE。

ECDHE 算法是在 DHE 算法的基础上利用了 ECC 椭圆曲线特性，可以用更少的计算量计算出公钥，以及最终的会话密钥。

- 双方事先确定好使用哪种椭圆曲线，和曲线上的基点 G，这两个参数都是公开的；
- 双方各自随机生成一个随机数作为**私钥d**，并与基点 G相乘得到**公钥Q**（Q = dG），此时小红的公私钥为 Q1 和 d1，小明的公私钥为 Q2 和 d2；
- 双方交换各自的公钥，最后小红计算点（x1，y1） = d1Q2，小明计算点（x2，y2） = d2Q1，由于椭圆曲线上是可以满足乘法交换和结合律，所以 d1Q2 = d1d2G = d2d1G = d2Q1 ，因此**双方的 x 坐标是一样的，所以它是共享密钥，也就是会话密钥**。

这个过程中，双方的私钥都是随机、临时生成的，都是不公开的，即使根据公开的信息（椭圆曲线、公钥、基点 G）也是很难计算出椭圆曲线上的离散对数（私钥）。

### 2.4.5 ECDHE握手过程(ToDo)

1. 在TLS第四次握手前，客户端就发送了加密的HTTP请求，这个和RSA不同
2. 使用RAS，TLS完成四次握手后，才能进行应用数传输。而对于ECDHE算法，可以提前发

# 3. HTTP/1.1 -> HTTP/3演变

## 3.1 HTTP/1.0 -> HTTP/1.1

HTTP/1.1 相比 HTTP/1.0 性能上的改进：

-   使用 TCP 长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。(因为一个页面中，可能会有多个HTTP请求)
-   支持管道（pipeline，流水线）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。但是还是属于`请求/应答`的通信模式，会造成队头阻塞
-   支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206
-   HTTP1.1中新增了24个错误状态响应码

但 HTTP/1.1 还是有性能瓶颈：

-   首部未压缩
-   服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞；
-   没有请求优先级控制；
-   请求只能从客户端开始，服务器只能被动响应。

## 3.2 HTTP/1.1 -> HTTP/2

HTTP/2 协议是基于 HTTPS 的，所以 HTTP/2 的安全性也是有保障的。

1. HTTP/2是基于HTTPS的
2. **头部压缩**：大量的请求有很多重复的首部字段，以及字段的值很多都是重复的，有必要进行压缩

- 使用了HPACK算法，主要由三部分组成：`静态字典`，`动态字典`，`Huffman编码`。
- 客户端和服务都会建立和维护字典，从而用索引号来代表重复的字符串，再用Huffman编码压缩数据
- `静态字典`：为高频出现的字符串和字段建立了`静态表`，共有61组.组成结构为为index + heraderName + headerValue
- `动态字典`：对于同一个连接上，完全重复的字段会添加到动态字典中去，index从62开始

3. **二进制格式**：

- HTTP/1.1是纯文本报文，HTTP/2头信息和数据体都是二进制，并且统称为帧

4. **并发传输(多路复用)**：多个Stream复用一条TCP连接，从而达到并发的效果；不同Sream的帧可以乱序发送，同一个Stream内部的帧必须是严格有序的。（接收端根据Stream ID有序组装成Http消息）

- Stream(流)：连接中的一个虚拟双向信道，每个流都有一个唯一的标识符。一个TCP连接包含一个或多个流
- Meassage(消息)：逻辑上的HTTP消息，对应于HTTP的请求和响应。一个Stream包含1各或多个Message
- Frame(帧)：HTTP 2.0 通信的最小单位，帧的头部会携带Stream ID；一个Meassage包含一个或多个Frame
- 双方都可以建立Steam，客户端建立的Stream是奇数的，服务器建立的Stream是偶数的
- Http2通过Stream实现并发，多个Stream只需要建立一个TCP连接

5. **设置优先级**：

- 可以对每个Stream设置不同的优先级，从而提高用户体验。（在帧头的标志位可以设置优先级）

6. **服务器推送**: 可以主动向客户端发送消息。

- 如浏览器请求 HTML 的时候，服务器把可能会用到的 JS、CSS 文件等静态资源主动发给客户端。

## 3.3 HTTP/2 -> HTTP/3

HTTP3采用了基于QUIC的UDP协议，QUIC有自己的一套机制可以保证传输的可靠性的

- `无队头阻塞`:
  - Http1是一种请求/应答模型，如果传输中有一个请求阻塞住了，那么之后的请求全部都会被阻塞住
  - HTTP/2 多个请求复用一个TCP连接，一旦发生丢包，整个TCP都要等待重传。（即使高序列号的到了，应用层也无法接收）
  - QUIC是基于流传输的，多个流相互独立，某个流丢包时，不会影响其他流
- `建立连接更快`
  -   HTTPS 要建立一个连接，要花费 6 次交互，先是建立三次握手，然后是 TLS/1.3 的三次握手。QUIC 直接把以往的 TCP 和
      TLS/1.3 的 6 次交互合并成了 3 次，减少了交互次数。

所以， QUIC 是一个在 UDP 之上的伪 TCP + TLS + HTTP/2 的多路复用的协议。

# 4. 优化

## 4.1 Http优化

**长连接**

- 将报文首部字段的Connection字段的值改为KeepAlive

---

**避免发送Http请求**

- 使用缓存技术，对于一些具有重复性的HTTP请求，可以把数据缓存到本地，下次直接从本地读取数据。其中URL作为key，响应作为value
- 响应的首部是有过期时间的，一旦缓存过期了，就要重新发送http请求
  - 客户端发起请求时，会在请求的Etag头部带上缓存的摘要；服务器收到请求后，会将本地资源的摘要和请求的摘要对比
  - 如果相同，返回304状态码报文，让客户端从缓存中拿数据；否则重新发送数据

---

**减少HTTP请求的次数**

- `减少重定向请求次数 `： 将重定向的工作交给代理服务器来实现
- `合并请求`：以一个大资源的请求代替多个小资源的请求，从而达到减少请求的目的
  - 比如多个小图片图片合成一个大图片，或者使用打包工具进行打包
  - 存在问题：当大资源发生变化后，客户端就需要重新下载完整的大资源

- `延迟发送请求`：
  - 比如只获取当前用户所看到的页面资源，当页面向下滑动时再获取接下来的资源。


---

**压缩响应体**

- 通常http的响应的数据大小都比较大，我们可以考虑对响应的资源进行压缩，从而减少响应的数据大小，来提高网络的传输效率

## 4.2 Https优化

分析性能损耗，产生性能损耗的环节

- TLS协议握手阶段
- 握手后的对称加密报文传输。

---

**硬件优化**

- HTTPS协议是计算密集型，所以使用更好的计算型CPU，选择更加支持会话密钥的CPU

**软件优化**

- 升级Linux或者OpenSSL版本

**协议优化**：

- 选择ECDHE而不是RSA；

  - ECHDE具有前向安全性，RSA不具有

  - ECDHE是基于椭圆曲线的，所以选择性能良好的椭圆曲线

  - ECDHE可以在第三次握手，第四次握手前就发送加密数据。而RSA必须在四次握手后才能发

- 升级TLS版本
  - TLS1.2 需要四次握手，而TLS1.3只需要两次
  - TLS对与密钥交换算法进行了优化，删除了RSA和DH算法，只支持ECDHE

**会话复用**：

- TLS握手就是为了协商会话密钥，如果把会话密钥缓存起来，下次要建立HTTPS连接，直接复用这个密钥，减少握手带来的损耗
- 比如将会话密钥缓存在Session中，以SessionID为key，会话密钥为value。只要客户端带上Session ID，服务器就可以找到会话密钥从而恢复会话状态。
  - 服务器必须保存每个客户端的会话密钥，服务器内存压力大；因为负载均衡，客户端再次连接的服务器可能不是上次那个
- Session Ticket：
  - 服务器不存储会话密钥。而是把缓存的工作交给客户端；
  - 建立连接时，服务器会加密会话密钥作为Ticket发送给客户端，交给客户端缓存该Ticket；
  - 客户端再次连接服务器时，客户端会发送Ticket，服务器解密后就可以获取上一次的会话密钥，然后验证有效期，如果没问题，就可以恢复会话

# 5. WebSocket

HTTP的缺点

- 通信只能由客户端发起，导致了如果想要获取服务器的状态变化的话，那么只能采取轮询的方式，定期去询问(如聊天室)，导致效率低下

WebSocket的特点

- 全双工通信，服务器可以主动向客户端推送消息，客户端也可以主动向服务器发送消息
- 建立在TCP之上
- 没有同源限制
- 和HTTP有良好的兼容性，默认端口是80 或者443，并且握手阶段采用HTTP协议
- 可以发送文本，也可以发送二进制数据
- 应用于弹幕，媒体聊天等
