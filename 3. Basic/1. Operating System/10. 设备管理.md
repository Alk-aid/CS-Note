# 1. 计算机设备的连接和通信

1. `总线`：设备通过总线(bus) 与CPU相连。
2. `设备寄存器`：CPU通过读写`设备寄存器`与设备进行通信，一个设备通常包含以下寄存器：`控制寄存器`(接收命令)，`状态寄存器`（反馈设备状态），`输入/输出寄存器`（数据交互）
3. CPU访问设备寄存器的方式：`可编程IO` 有两种

- `内存映射`(MMIO): 将设备寄存器映射到内存上并拥有独立的地址，CPU可以用访问物理内存一样的指令（ldr读和str写）来访问设备地址；
- `端口映射`(PMIO)：通过专门的端口操作指令执行

4. DMA(Direct Memory Access): 减少I/O对CPU时间片的占用

- 把数据搬运的工作交给DMA来处理，使得CPU可以处理其他任务。发起者可以处理器也可以是设备
- 处理器向DMA控制器发送DMA请求：缓冲区的位置和长度，以及数据传输的方向，随后放弃总线的控制器。
- DMA将设备中的数据加载进内存当中。
- DNA控制器完成DMA后向处理器发送`中断`通知CPU对数据进行处理。

5. `设备地址翻译（IOMMU）`: 虚拟地址转换为物理地址是通过`MMU`，而总线地址转换为物理地址是通过`IOMMU`

<img src="http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/image-20220107112214991.png" alt="image-20220107112214991" style="zoom:50%;" />

6. I/O控制演进

- `程序直接控制方式`：其实本质上就是`轮询等待`的方式，让CPU一直查 `状态寄存器`的状态，直到状态标记为完成，则从IO模块的数据寄存器中读取数据到内存当中。
- `中断驱动方式`：CPU发出读/写命令后,先切换到别的进程执行,当设备准备完成后，控制器会向CPU发出一个中断信号,然后CPU响应中断程序来进行搬运数据和处理数据。
- `DMA`: 可以在不需要CPU参与的情况下，能够自行把设备IO数据放入到内存中
- `通道`：一种硬件，可以理解为是“弱鸡版的CPU”。通道可以识别并执行一系列通道指令

# 2. 设备的识别	

常见的设备识别机制有：设备树和ACPI

1. 设备树

- 不使用设备树的话，那么我们需要将各种设备的硬件配置硬编码到系统代码中，一旦参数改变需要重新编译，非常不灵活，增大OS的维护成本

- 而设备树(device tree)是描述计算机硬件信息的数据结构，包含了CPU的名称，内存，总线，设备等硬件信息

2. ACPI(Advanced Configuration adn Power Interface): 

- 是设备与操作系统之间的一层抽象，该层抽象统一地向OS汇报硬件设备的情况，同时提供管理设备的接口和方法

# 3. 设备的中断处理

> 中断机制，是用来实现设备通知处理器的一种方案

GIC(Generic Interrupt Controller):ARMv8的中断控制器：

**组成**：两个接口

- 分发器接口(distruibutor interface): 负责汇集收到的中断请求，然后按照优先级排序和分发
- CPU接口(CPU interface): CPU接口与CPU核直接相连，将中断给CPU，触发CPU核上的中断处理程序

**中断类型**

- 软件生成中断(Software Generated Interrupt,SGI):软件写GICD_SGIR寄存器触发，用于发送核间中断
- 私有设备中断(Private Peripheral Interrupt,PPI):CPU上私有的设备触发，如通用定时器
- 共享设备中断(Shared  Peripheral Interrupt,SPI):由所有CPU核心共同连接的设备触发，可以发送给任意核心

**中断优先级**：一般越小优先级越高

**中断号**：为每个中断分配了一个中断号

**中断状态**

- Inactive：无效，此时中断未到来
- Pending：有效状态，中断已发生，CPU未响应中断。
- Active：CPU处于响应并处理中断的过程中。
- Active & Pending：处理中断时，有相同的中断号发生。

**中断响应过程：**

- Generate：中断源产生中断，传递给GIC，状态从Inactive到Pending
- Deliver：GIC将中断给CPU，中断处于Pending状态
- Activate：CPU调用中断处理函数响应并处理中断，中断处于Active状态
- Deactive（中断完成，EOI）：CPU处理完中断，通知GIC中断完成，GIC将中断状态改为Inavtive。

**中断处理**：

- 由于中断随时可能发生，所以必须保证中断处理程序可以快速执行；但是中断处理程序可能又会处理大量的任务，两者之间存在矛盾，所以一般会把中断处理的过程分成两部分：上半部和下半部。
- 上半部也叫硬中断，是通常意义上的`中断处理程序`，用来接收中断，和简单的、有时限的处理工作，例如对中断接收后对中断控制器进行应答。这个过程是关闭中断的
- 下半部(bottom half): 完成剩余的，复杂且时延要求相对较低的操作，下半部属于就有较高优先级的内核任务，执行时间由系统调度来确定。

**下半部机制：**

- `软中断`：
  - 用一种普通内核任务模拟硬中断处理函数的方法。执行时间由调度器决定的
  - 软中断允许被硬中断打断，所以必须是要求可重入的。
  - 可以并发运行在多个CPU上。
- `tasklet`：
  - tasklet是基于软中断的一种封装。
  - 软中断是静态分配的，在内核编译好之后，就不能改变。tasklet可以在运行时改变
  - 一种特定类型的tasklet只能运行在一个CPU上；多个不同类型的tasklet可以并行在多个CPU上。
- `工作队列`：
  - 把推后执行的任务以队列结构组织成工作队列（workqueue），而工作线程就是负责执行工作队列中的工作。
  - 工作队列使用进程上下文，允许阻塞和睡觉;
  - 软中断和tasklet运行在中断上下文中，因此不能阻塞和睡眠（因为中断上下文处于内核态，没有进程切换，一旦阻塞或者睡眠会导致无法退出这个状态）

| 下半部   | 上下文 | 顺序执行保障                               |
| -------- | ------ | ------------------------------------------ |
| 软中断   | 中断   | 随意，同类型都可以在**不同**处理器同时执行 |
| tasklet  | 中断   | 同类型不能同时执行                         |
| 工作队列 | 进程   | 不保障，可能被调度和抢占                   |

# 5. Linux收发网络包

**接收网络包**

1. 用网卡去接收数据包，然后通过DMA技术，把网络包放到Ring Buffer（一个环形缓冲区）
2. 之后DMA向CPU发出一个中断，通知CPU处理数据
3. CPU先执行硬件中断，此时会暂时屏蔽中断，处理完简单，实时性高的任务，比如后对中断控制器进行应答，之后唤醒软中断
4. 软中断来轮询处理数据，直到没有新数据后结束软中断

**发送网络包**

1. 应用系统调用Socket发送数据包的接口，然后内陷到内核中，将数据拷贝到Socket的发送缓冲区
2. 接下来按照TCP/IP协议增加TCP头，IP头，MAC头等，放入到发包队列中
3. 触发软中断告诉网卡驱动程序，这里有新的网络包要发送，驱动程序通过DMA读取数据到网卡的队列中，然后发出



# 6. PageCache

`内核缓冲区`其实就是`PageCache`

使用PageCache的原因

- 因为读写磁盘的速度非常慢，所以如果可以转化为读写内存，那么久可以加快吞吐量。因此DMA会将数据从磁盘搬运到PageCache

PageCache主要有两个优点

- `缓存最近被访问的数据`：根据程序局部性原理
- `预读`：比如读取前32KB的字节，会把后面32KB也加载到PageCache中。减少了读取磁盘的次数

传输大文件不建议使用PageCache

- 文件太大，使得其他热点小文件无法充分利用
- 白白浪费一次DMA的拷贝，消耗性能
- 异步IO + 直接IO（不使用PageCache）
