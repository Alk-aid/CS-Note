# 0. 概述

每个进程的用户地址空间是独立的，一般而言是不能直接访问的，但内核空间是每个进程都共享的，所以进程间通信一般都需要通过内核。

# 1. 管道通信

1. `管道`实际上是一个文件，使用内存作为数据的的缓冲区，内核会为用户提供代表管道的文件描述符，其中pipe[1]是写端，pipe[0]是读端。是单向的IPC。
2. `通信的数据`是字节流，需要应用自己对数据进行解析。
3. `管道有匿名管道和命名管道之分`

- 匿名管道是 父进程通过pipe系统调用创建好对应的管道，然后通过fork创建出子进程，这样父子进程就都有对应的管道描述符了。
- 命名管道：是通过`mkfifo`来创建的，创建的时候指定一个全局的文件名，由这个文件名来代指一个具体的管道。这样任意两个进程就能建立管道的通信连接了

```bash
mkfifo <管道名>  		//创建管道
echo "hello" > myPipe //输入数据
cat < myPipe		 //输出数据
```

4. 问题：虽然简单，效率低，无格式的字节流，不适合进程间频繁的交换数据

# 2. 消息队列

1. `消息队列`实际上是一个保存在内核中的一个用`链表`实现的队列,消息队列会有一个字段来表示队首的消息的指针。
2. `消息`：其中每一个消息由三部分组成：类型，数据，指向下一条消息的指针。
3. `类型`: 是用户指定的，内核不需要知道具体含义，内核只起到保存作用
4. `优劣`：

- 克服了管道通信的数据是无格式的字节流的问题

- 存在用户态和内核态之间的数据拷贝开销。因为进程写入数据到内核中的消息队列，会发生从用户态拷贝到内核态的过程。同理读取也是如此。所以不适合大数据的传输（大数据适合用共享内存机制来传递）

# 3. 信号量

1. `为什么需要信号量`: 管道，消息队列，共享内存主要都是用来传递消息的，而有些场景，多个进程需要依赖于进程间通信来同步彼此的状态。
2. `信号量`是一个由内核维护的整型计数器，主要用于进程间的互斥和同步，对信号量的操作需要经过内核系统调用
3. `信号量的操作`：信号量表示资源的数量，控制信号量的方式有两种原子操作
   - 一个是P操作。他会把信号量减一，相减后如果信号量<0,则表明资源全都被占用了，进程需要阻塞等待。如果>=0,则表示还有可用资源，无需阻塞
   - 一个是V操作。他会把信号量加1，相加后如果信号量<=0,则表明当前有阻塞中的进程，需要唤醒该进程。相加后如果>0，则表示当前没有阻塞中的进程。

3. `信号量的初始化`
   1. 信号量初始化为1，就代表着互斥信号量。
   2. 信号量为0，可以用来实现多进程的同步

# 4. 共享内存

1. `为什么需要共享内存`：管道通信，消息队列，信号量虽然可以用来进程通信，但是因为其中的数据放在内核态，所以会频繁的涉及到数据拷贝，控制流转移等逻辑，性能不好
2. `共享内存`：内核为需要通信的进程建立共享区域，一旦建立成功，就不再需要内核参与进程间通信，通信的双方直接使用共享内存上的数据即可
3. `思想`： 允许一个或多个进程在其所在的虚拟地址空间中映射相同的物理内存页，从而进行通信。

# 5. 信号

1. `为什么需要信号`：管道，消息队列，共享内存主要关注的是数据传输上，信号量主要用于进程同步;而信号主要特点是具有`单向的事件通知能力`。
2. `信号是什么`: 信号是进程间通信机制中唯一的**异步通信机制**，因为可以在任何时候发送信号给某一进程，一旦有信号产生，有以下几种对信号的处理方式

- 内核默认处理：Linux对每种信号都规定了默认操作，例如SIGKILL就是立刻结束进程
  - Ctrl+C 产生SIGINT信号，表示终止该进程
  - Ctrl+Z 产生SIGTSTOP信号，表示停止该进程，但还未结束

  - kill -9 <PID> 给PID发送SIGKILL信号，用来立即结束该进程

- 捕捉信号：我们可以为信号定义一个信号处理函数，当信号发生时，就执行相应的函数
- 忽略信号：当我们不希望处理某些信号时，就可以忽略。（SIGKILL`和`SIGSTOP不能被忽略）

3. `发送信号`: 使用kill或者是tgkill向进程或线程发送信号，其中1～31为常规信号，32～64为实时信号

> Linux内核提供了signal，sigaction等系统调用，允许用户为特定的信号注册一个用户态处理函数。

# 6. Socket

前面的五种都是同一种主机间的进程通信，Socket用于不同主机间的进程通信(同一主机也可以)

针对TCP的socket编程.

- 服务器和客户端初始化socket，得到文件描述符
- 服务器调用bind，绑定IP和端口
- 服务器调用listen进行监听
- 服务器调用accept，等待客户端连接
- 客户端调用connect，向对应IP,PORT发起连接请求
- 服务器accept返回用于传输的socket的文件描述符
- 客户端调用write写入数据；服务器调用read读取数据
- 客户端断开连接时，会调用close，那么服务器read读取数据的时候，就会读取到EOF，待处理完数据后，服务器调用close，表示连接关闭

