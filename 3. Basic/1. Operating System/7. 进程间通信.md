# 0. 概述

每个进程的用户地址空间是独立的，一般而言是不能直接访问的，但内核空间是每个进程都共享的，所以进程间通信一般都需要通过内核。

# 1. 管道通信

1. `管道`实际上是一个文件，使用内存作为数据的的缓冲区，内核会为用户提供代表管道的文件描述符，其中pipe[1]是写端，pipe[0]是读端。是单向的IPC。
2. `通信的数据`是字节流，需要应用自己对数据进行解析。
3. `管道有匿名管道和命名管道之分`

- 匿名管道是 父进程通过pipe系统调用创建好对应的管道，然后通过fork创建出子进程，这样父子进程就都有对应的管道描述符了。
- 命名管道：是通过`mkfifo`来创建的，创建的时候指定一个全局的文件名，由这个文件名来代指一个具体的管道。这样任意两个进程就能建立管道的通信连接了

```bash
mkfifo <管道名>  		//创建管道
echo "hello" > myPipe //输入数据
cat < myPipe		 //输出数据
```

4. 问题：虽然简单，效率低，无格式的字节流，不适合进程间频繁的交换数据

# 2. 消息队列

1. `消息队列`实际上是一个保存在内核中的一个用`链表`实现的队列,消息队列会有一个字段来表示队首的消息的指针。
2. `消息`：其中每一个消息由三部分组成：类型，数据，指向下一条消息的指针。
3. `类型`: 是用户指定的，内核不需要知道具体含义，内核只起到保存作用
4. `优劣`：

- 克服了管道通信的数据是无格式的字节流的问题

- 存在用户态和内核态之间的数据拷贝开销。因为进程写入数据到内核中的消息队列，会发生从用户态拷贝到内核态的过程。同理读取也是如此。所以不适合大数据的传输（大数据适合用共享内存机制来传递）

# 3. 信号量

1. `为什么需要信号量`: 管道，消息队列，共享内存主要都是用来传递消息的，而有些场景，多个进程需要依赖于进程间通信来同步彼此的状态。
2. `信号量`是一个由内核维护的整型计数器，主要用于进程间的互斥和同步，对信号量的操作需要经过内核系统调用
3. `信号量的操作`：信号量表示资源的数量，控制信号量的方式有两种原子操作
   - 一个是P操作。他会把信号量减一，相减后如果信号量<0,则表明资源全都被占用了，进程需要阻塞等待。如果>=0,则表示还有可用资源，无需阻塞
   - 一个是V操作。他会把信号量加1，相加后如果信号量<=0,则表明当前有阻塞中的进程，需要唤醒该进程。相加后如果>0，则表示当前没有阻塞中的进程。

3. `信号量的初始化`
   1. 信号量初始化为1，就代表着互斥信号量。
   2. 信号量为0，可以用来实现多进程的同步

# 4. 共享内存

1. `为什么需要共享内存`：管道通信，消息队列，信号量虽然可以用来进程通信，但是因为其中的数据放在内核态，所以会频繁的涉及到数据拷贝，控制流转移等逻辑，性能不好
2. `共享内存`：内核为需要通信的进程建立共享区域，一旦建立成功，就不再需要内核参与进程间通信，通信的双方直接使用共享内存上的数据即可
3. `思想`： 允许一个或多个进程在其所在的虚拟地址空间中映射相同的物理内存页，从而进行通信。

# 5. 信号

1. `为什么需要信号`：管道，消息队列，共享内存主要关注的是数据传输上，信号量主要用于进程同步;而信号主要特点是具有`单向的事件通知能力`。
2. `信号是什么`: 信号是进程间通信机制中唯一的**异步通信机制**，因为可以在任何时候发送信号给某一进程，一旦有信号产生，有以下几种对信号的处理方式

- 内核默认处理：Linux对每种信号都规定了默认操作，例如SIGKILL就是立刻结束进程
  - Ctrl+C 产生SIGINT信号，表示终止该进程
  - Ctrl+Z 产生SIGTSTOP信号，表示停止该进程，但还未结束

  - kill -9 <PID> 给PID发送SIGKILL信号，用来立即结束该进程

- 捕捉信号：我们可以为信号定义一个信号处理函数，当信号发生时，就执行相应的函数
- 忽略信号：当我们不希望处理某些信号时，就可以忽略。（SIGKILL`和`SIGSTOP不能被忽略）

3. `发送信号`: 使用kill或者是tgkill向进程或线程发送信号，其中1～31为常规信号，32～64为实时信号

> Linux内核提供了signal，sigaction等系统调用，允许用户为特定的信号注册一个用户态处理函数。

# 6. Socket

> 前面的五种都是同一种主机间的进程通信，Socket用于不同主机间的进程通信(同一主机也可以)

流程

- TCP服务器端依次调用socket()、bind()、listen()之后，就会监听指定的socket地址了
- TCP客户端依次调用socket()、 connect()之后就向TCP服务器发送了一个连接请求
- TCP服务器监听到这个请求之后，就会调用accept () 函数取接收请求，这样连接就建立好了
- 客户端调用write写入数据；服务器调用read读取数据
- 客户端断开连接时，会调用close，那么服务器read读取数据的时候，就会读取到EOF，待处理完数据后，服务器调用close，表示连接关闭

socket函数

```c++
# 作用: 创建一个socket, 并指定所用的协议等要素
# 返回值: socket描述符, 唯一标识一个socket
# domain: 协议域, AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合; AF_UNIX决定了要用一个绝对路径名作为地址
# type: 指定socket类型。常用的socket类型有，SOCK_STREAM、SOCK_DGRAM、 SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等
# protocol: 用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、 IPPROTO_TIPC等，它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议
int socket(int domain, int type, int protocol);
```

bind函数

```C++
# 作用: 给socket赋上一个地址
# sockfd：即socket描述字，它是通过socket()函数创建了，唯一标识一个socket。bind()函数就是将给这个描述字绑定一个名字。
# addr：一个const struct sockaddr *指针，指向要绑定给sockfd的协议地址
# addrlen：对应的是地址的长度
# 服务器在启动的时候都会绑定一个众所周知的地址（如ip地址+端口号），用于提供服务，客户就可以通过它来接连服务器
# 而客户端就不用指定，有系统自动分配一个端口号和自身的ip地址组合。这就是为什么通常服务器端在listen之前会调用bind()，而客户端就不会调用，而是在 connect()时由系统随机生成一个
int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
```

listen & connect函数

```C++
# 调用listen()来使得服务器监听这个socket，如果客户端这时调用connect()发出连接请求，服务器端就会接收到这个请求
# 作用: listen函数将socket变为被动类型的，等待客户的连接请求
# sockfd: 要监听的socket描述字
# backlog: 为相应socket可以排队的最大连接个数
int listen(int sockfd, int backlog);

# 作用: 调用connect函数来建立与TCP服务器的连接
# sockfd: 客户端的socket描述字
# addr: 服务器的socket地址
# addrlen: socket地址的长度
int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
```

accept函数

```c++
# sockfd: 服务器的socket描述字
# addr: 指向struct sockaddr *的指针，用于返回客户端的协议地址
# addrlen: 为协议地址的长度
# 作用: 如果accpet成功，那么其返回值是由内核自动生成的一个全新的描述字，代表与返回客户的TCP连接
int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
```

服务端有两种socket, 他们的本质是一样的, 都是用来和客户端进行数据交流

- `监听socket`: 服务器调用socket()生成的socket, 作用是和客户端建立连接; 一个服务器通常通常仅仅只创建一个监听socket描述字，它在该服务器的生命周期内一直存在
- `已连接socket`: 服务端调用accept()生成的socket, 和客户端进行数据交流; 当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭
