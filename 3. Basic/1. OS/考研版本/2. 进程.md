# 1. 进程

## 1.1 进程的概念

### I 为什么引入进程

> 解释这个问题就等效于 解释 只有`程序`这个概念为什么不行。

**没有进程，程序只能串行的执行**

1. 程序本身是一组指令的集合，是一个静态的概念，无法描述程序在内存中的执行情况，即我们无法从程序的字面上看出它何时执行、何时停顿，也无法看出它与其他执行程序的关系
2. 因此，程序这个静态概念已不能如实反映程序并发执行过程的特征。为了深刻描述程序动态执行过程的性质乃至更好地支持和管理多道程序的并发执行，人们引入了进程的概念。



### II 进程的定义

从不同的角度，进程可以有不同的定义，比较典型的定义有：

1. 进程是程序的一次执行过程。

2) 进程是一个程序及其数据在处理机上顺序执行时所发生的活动．
3) 进程是具有独立功能的程序在一个数据集合上运行的过程，它是`系统进行资源分配和调度的一个独立单位`。（这个定义在引入线程以后，有所改变）

引入进程实体的概念后，我们可以把传统操作系统中的进程定义为：**“进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。”**

`进程映像`（进程实体）：由`程序段`、`相关数据段`和`PCB` 三部分

值得注意的是，进程映像是静态的，进程则是动态的。

## 1.2 进程的组成

进程由以下三部分组成

- PCB
- 程序段
- 数据段

### I PCB

 `进程创建时`，操作系统为它新建一个PCB, 该结构之后常驻内存，任意时刻都可以存取，并在进程结束时删除。PCB 是进程实体的一部分，是进程存在的**唯一标志**。

  `进程执行时`， 系统通过其PCB 了解进程的现行状态信息， 以便对其进行控制和管理：

  `进程结束时`，系统收回其PCB, 该进程随之消亡。操作系统通过PCB 表来管理和控制进程。

  `当操作系统欲调度某进程运行时`，要从该进程的PCB 中查出其现行状态及优先级；在调度到某进程后，要根据其PCB 中所保存的处理机状态信息， 设党该进程恢复运行的现场，并根据其PCB 中的程序和数据的内存始址,找到其程序和数据；

  `进程在运行过程中`， 当需要和与之合作的进程实现同步、通信或访问文件时，也需要访问PCB: 

  `当进程由千某种原因而暂停运行时`，又需将其断点的处理机环境保存在PCB 中。

**可见，在进程的整个生命期中，系统总是通过PCB 对进程进行控制的，亦即系统唯有通过进程的PCB 才能感知到该进程的存在。**

![image-20210903102017446](https://gitee.com/aik-aid/picture/raw/master/image-20210903102017446.png)



### II 程序段

程序的代码(指令序列)

### III 数据段

一个进程的数据段，可以是进程对应的程序加工处理的原始数据，也可以是程序执行时产生的中间或最终结果。

## 1.3 进程的特征

  进程是由多道程序的并发执行而引出的，它和程序是两个截然不同的概念。进程的基本特征是对比单个程序的顺序执行提出的，也是对进程管理提出的基本要求。

1. `动态性`。进程是程序的一次执行，它有着创建、活动、暂停、终止等过程，具有一定的生命周期，是动态地产生、变化和消亡的。**动态性是进程最基本的特征。**
2. `井发性`。指多个进程实体同时存于内存中，能在一段时间内同时运行。井发性是进程的重要特征，同时也是操作系统的重要特征。**引入进程的目的就是使程序能与其他进程的程序并发执行，以提高资源利用率。**
3. `独立性`。指进程实体是一个能独立运行、独立获得资源和独立接受调度的基本单位。凡未建立PCB 的程序，都不能作为一个独立的单位参与运行。
4. `异步性`。由于进程的相互制约，使得进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进。异步性会导致执行结果的不可再现性，为此在操作系统中必须配置相应的进程同步机制。
5. `结构性`。每个进程都配置一个PCB 对其进行描述。从结构上看，进程实体是由程序段、数据段和进程控制块三部分组成的。

## 1.3 进程的组织形式

有链接方式 和 索引方式

链接方式

- 按照进程状态将PCB分为多个队列
- 操作系统持有指向各个队列的指针

索引方式

- 按照进程状态的不同，建立几张索引表
- 操作系统持有指向各个索引表的指针

## 1.4 进程的状态与转换

常进程有以下5 种状态，前3 种是进程的基本状态。

1. `运行态`。进程正在处理机上运行。在单处理机环境下，每个时刻最多只有一个进程处于运行态。
2. `就绪态`。**进程获得了除处理机外的一切所需资源**，一旦得到处理机，便可立即运行。系统中处千就绪状态的进程可能有多个，通常将它们排成一个队列，称为就绪队列．
3. `阻塞态`，又称等待态。进程正在等待某一事件而暂停运行，如等待某资源为可用（不包括处理机）或等待输入/输出完成。即使处理机空闲，该进程也不能运行。
4. `创建态`． 进程正在被创建，尚未转到就绪态。创建进程通常需要多个步骤：
   1. 首先申请一个空白的PCB, 井向PCB中填写一些控制和管理进程的信息：
   2. 然后由系统为该进程分配运行时所必需的资源：最后把该进程转入就绪态。
5. `结束态`．进程正从系统中消失，可能是进程正常结束或其他原因中断退出运行。进程需要结束运行时，系统首先必须将该进程置为结束态，然后进一步处理资源释放和回收等工作。

![image-20210903104118902](https://gitee.com/aik-aid/picture/raw/master/image-20210903104118902.png)

## 1.5 进程的控制

### 1.5.1 基本概念

进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有

- 创建新进程
- 撤销已有进程
- 实现进程状态转换等功能

操作系统中，一般把进程控制用的程序段称为`原语`，原语的特点是执行期间不允许中断，它是一个不可分割的基本单位。

---

为什么需要原语这种程序来实现进程控制

> 因为进程的转换至少有两部
>
> 1. 将state改变
> 2. 从一个队列移动到另一个队列
>
> 如果没有原语，在第一步后发生了中断的话，那么此时就会出现问题

---

如何实现原语的原子性

> 通过关中断指令和开中断指令来实现

### 1.5.2 相关原语

无论哪个进程控制原语，要做的无非三类事情：

1. 更新PCB中的信息
   a.所有的进程控制原语一定都会修改进程状态标志
   b.剥夺当前运行进程的CPU使用权必然需要保存其运行环境
   c.某进程开始运行前必然要恢复期运行环境

2. 将PCB插入合适的队列
3. 分配/回收资源

#### I 进程的创建

1. 为新进程分配一个唯一的进程标识号，并`申请一个空白的PCB`
2. `为进程分配资源`。若资源不足，则处于`阻塞态` 而不是创建失败
3. `初始化PCB`。
4. 将PCB插入就绪队列

引起进程创建的事件

> - 用户登录
> - 作业调度：新作业放入内存中，会为其创建一个新的进程
> - 提供服务
> - 应用请求：由用户主动请求创建一个子进程

#### II 进程的终止

1. 从PCB中找到终止进程的PCB
2. 若进程正在运行，立刻剥夺CPU，将CPU分配给其他进程
3. 终止其所有子进程
4. 将该进程所拥有的资源归还给父进程或者操作系统
5. 删除PCB

引起进程终止的事件

> - 正常结束：进程自己请求结束
> - 异常结束：整数除以0，非法使用特权指令等
> - 外界干扰：用户杀掉进程

#### III 进程的阻塞和唤醒

**阻塞**

1. 找到要阻塞的进程对应的PCB
2. 保护`进程运行现场`，将PCB状态设置为 阻塞态，暂停进程的运行
3. 将PCB插入到相应事件的等待队列去

引起进程阻塞的事件

> - 需要等待系统分配某种资源
> - 需要等待相互合作的进程完成工作

**唤醒**

1. 在等待队列中找到PCB
2. 将PCB从等待队列中移除，设置进程为就绪态
3. 将PCB插入就绪队列



注意，这里所讲的运行现场主要指的是 `保存一些必要的寄存器信息到PCB中的处理器相关信息中去`，恢复也是从这之中恢复现场的

进程的上下文切换不仅包含了虚拟内存，栈，全局变量，寄存器等资源。

#### IV 进程的切换

1. 将`运行环境`存入PCB中
2. PCB移入相应队列
3. 选择另一个进程执行，并更新其PCB
4. 根据PCB恢复新进程所需的`运行环境`

引起进程切换的事件

> - 当前进程时间片到
> - 资源不够时，这时候需要阻塞
> - 中断
> - sleep
> - 有更高优先级的进程到达
> - 当前进程终止

![image-20210903144933988](https://gitee.com/aik-aid/picture/raw/master/image-20210903144933988.png)

## 1.6 进程的通信

`进程间通信`（Inter-Process Communication， IPC）是指两个进程之间产生数据交互。

### 1.6.1 为什么进程通信需要OS支持

进程是分配系统资源的单位（包括内存地址空间），因此`各进程`拥有的`内存地址空间相互独立`。

为了保证安全，`一个进程不能直接访问另一个进程的地址空间`。

### 1.6.2 通信的分类

- 共享存储
  - 基于数据结构的共享
  - 基于存储区的共享
- 消息传递
  - 直接通信方式
  - 间接通信方式
- 管道通信

#### I 共享存储

1. 设置一个共享内存区域，并且映射到进程的虚拟地址空间(增加页表项/段表项)。
2. 要求互斥地访问共享空间
   1. 为避免出错，各个进程的访问是互斥的
   2. 且互斥是通信进程自己负责的(使用内核提供的P,V操作)

---

`基于存储区的共享`：操作系统在内存中划出一块共享存储区，数据的形式、存放位置都由通信进程控制，而不是操作系统。这种共享方式速度很快，是一种高级通信方式。

`基于数据结构的共享`：比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种低级通信方式

#### II 消息传递

1. 进程间的数据交换以`格式化的消息`（Message）为单位。
2. 进程通过操作系统提供的“发送消息/接收消息”两个`原语`进行数据交换。
3. 两种方式
   1. 直接通信方式-----消息直接挂到接收进程的消息队列中
      1. 消息发送进程要指明接收进程的ID
      2. 消息队列在PCB中，PCB在操作系统的内核地址空间
   2. 间接通信方式-----消息先发送到中间体(信箱)
      1. 消息发送不要指明接收进程的ID，而是指明信息
      2. 信箱在操作系统的内核地址空间中

#### III 管道通信

1. 设置一个特殊的共享文件(管道),其实就是一个内存缓冲区
2. 一个管道只能实现半双工通信，实现双向同时通信需要建立两个管道。
3. 各进程互斥访问管道(由操作系统负责实现互斥)
4. 管道写满时，写进程阻塞。管道读空时，读进程阻塞
5. 从管道读取数据是一次性的

写进程往管道写数据，即便管道没被写满，`只要管道没空，读进程就可以从管道读数据`
读进程从管道读数据，即便管道没被读空，`只要管道没满，写进程就可以往管道写数据`

---

> 管道通信和共享存储的区别
>
> - 共享存储的话：数据的形式、存放位置都由通信进程控制。比较自由
> - 管道通信的话：可以理解为一个循环队列，只能先进先出的读取

管道可以理解为是共享存储的优化

- 在共享存储中，若有进程在进行写操作，那其他进程就不能访问，会被堵塞
- 管道通信允许一边写入，一边读出

# 2. 线程

线程由线程ID，程序计数器，寄存器集合和堆栈组成。

## 2.1 为什么要引入线程

1. 有时候一个进程可能需要同时执行很多事情。例如QQ视频，聊天，传输文件
2. 传统的进程只能串行的执行这一系列程序。
3. 为此引入了`线程`，来增加并发度，从而一个进程可以并发的执行多段代码块

> 为什么不多进程呢
>
> 1. 维护进程的系统开销大，进程的切换也更消耗资源
> 2. 进程之间的通信更难

## 2.2 引入之后的变化

资源调度方面

> - 传统进程是资源分配和调度的基本单位
> - 引入线程以后，`进程`只作为除CPU之外的系统资源的分配单元(如打印机，内存地址空间都是分配给进程的)
> - 线程作为基本的CPU执行单元，也是程序执行流的最小单位，也就是说`线程成为了调度的基本单位`

并发性

> - 传统进程机制中，只能进程间并发
> - 引入线程以后，线程间也能并发，提高了并发度

系统开销

> - 传统的进程间并发，需要切换进程的运行环境，系统开销很大
> - 线程间并发，如果是同一进程内的切换，不需要切换进程环境，系统开销小
> - 同时，并发所带来的系统开销也减小了

## 2.3 线程的属性

- 线程是`处理机调度`的基本单位
- 多CPU计算机中，各个线程可以占用不同的CPU
- 每个线程有线程ID，线程控制块(TCB)
- 线程也有就绪，堵塞，运行三种基本状态
- 线程基本不拥有系统资源
- 线程也有自己的私有数据，比如栈和寄存器
- 同一进程的不同线程共享进程的资源
- 由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预
- 同一进程中的线程切换，不会引起进程切换
- 不同进程中的线程切换，会引起进程切换
- 不同进程中的线程切换，会引起进程切换
- 切换进程，系统开销较大

## 2.4 线程的实现

### 2.4.1 用户级线程

User-Level Thread（ULT）

![image-20210903165543441](https://gitee.com/aik-aid/picture/raw/master/image-20210903165543441.png)

- 线程的管理工作是 应用程序通过线程库来完成的，并不是操作系统完成的
- 线程切换不需要CPU变态
- 操作系统意识不到用户级线程的存在
- 优点：不需要切换到核心态，系统开销小
- 缺点：一个用户线程堵塞，整个进程都会堵塞，并发度不高。多个线程不可以在多核CPU中并行运行

`用户级线程其实就是一段代码逻辑`

### 2.4.2 内核级线程

Kernel-Level Thread(KLT)

![image-20210903165906665](https://gitee.com/aik-aid/picture/raw/master/image-20210903165906665.png)

### 2.4.3 多线程模型

- 多对一模型：就是ULT

- 一对一模型: 就是KLT
- 多对多模型：将n个用户级线程映射到m个内核级线程上
  - 既克服了多对一模型的并发度不高的缺点
  - 又克服了一对一模型一个用户进程占用太多内核级线程而开销太大的缺点。

## 2.5 线程的上下文切换

1. 当两个线程不属于同一个进程时，则切换的过程和进程上下文切换一样
2. 如果两个线程属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据，寄存器等不共享的数据

# 3. 处理机调度

## 3.1 调度的概念

在多道程序系统中，进程的数量往往多于处理机的个数，因此进程争用处理机的情况在所难免。处理及调度是对处理机进行分配，也就是从就绪队列总按照一定的算法选择一个进程并将处理及分配给它允许，以实现进程并发执行

## 3.2 调度的层次

- 高级调度(作业调度)
- 中级调度(内存调度)
- 低级调度(进程调度)

### I 作业调度

作业：一个具体的任务

用户向系统提交一个作业≈用户让操作系统启动一个程序（来处理一个具体的任务）

`高级调度（作业调度）`。按一定的原则从`外存`的作业后备队列中挑选一个作业调入`内存`，并创建进程。`每个作业只调入一次，调出一次`。作业调入时会建立PCB，调出时才撤销PCB。

### II 内存调度

内存不够时，可将某些进程的`数据`调出外存。等内存空闲或者进程需要运行时再重新调入内存。

暂时调到外存等待的进程状态为`挂起状态`。`被挂起的进程PCB会被组织成挂起队列`

`中级调度（内存调度）`——按照某种策略决定将哪个处于挂起状态的进程重新调入内存。一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高。

![image-20210904094301231](https://gitee.com/aik-aid/picture/raw/master/image-20210904094301231.png)

### III 进程调度

`低级调度（进程调度/处理机调度）`——按照某种策略从就绪队列中选取一个进程，将处理机分配给它。

进程调度是操作系统中`最基本的一种调度`，在一般的操作系统中都必须配置进程调度。进程调度的频率很高，一般几十毫秒一次。

### IV 对比与联系

<img src="https://gitee.com/aik-aid/picture/raw/master/image-20210904094323090.png" alt="image-20210904094323090" style="zoom:150%;" />



## 3.3 调度的时机与方法

“狭义的进程调度”与“进程切换”的区别：

- 狭义的进程调度指的是从就绪队列中选中一个要运行的进程。（这个进程可以是刚刚被暂停执行的进程，也可能是另一个进程，后一种情况就需要进程切换）
- 进程切换是指一个进程让出处理机，由另一个进程占用处理机的过程。

> 我的理解是
>
> - 狭义调度是一种决策，但是没有时机行动，只是绝对要将CPU给哪个进程使用
> - 切换是一种实际动作

**广义的进程调度包含了选择一个进程和进程切换两个步骤。**



进程切换的过程主要完成了：

1. 对原来运行进程各种数据的保存
2. 对新的进程各种数据的恢复（如：程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在`进程控制块`）

### I 什么时候需要调度

1. 当前进程`主动放弃处理机`
   - 进程正常终止
   - 进程过程中发生了异常而终止
   - 进程主动请求阻塞(如等待I/O)
2. 当前进程`被动放弃`处理机
   - 时间片用完了
   - 有更高优先级的进程进入优先队列
   - 有更紧急的事情要处理(如I/O中断)

### II 什么时候不需要调度

1. 处理中断的过程中
2. 原语的过程中
3. 进程在`操作系统内核程序临界区中`

> 临界资源：一个时间段内只允许一个进程使用的资源。各进程需要互斥地访问临界资源。
>
> 临界区：访问临界资源的那段代码。
>
> `内核程序临界区`一般是用来访问某种内核数据结构的，比如进程的就绪队列（由各就绪进程的PCB组成）。所以不能进行调度

### III 调度的方法

1. `非剥夺调度方式，又称非抢占方式`。即，只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。
2. `剥夺调度方式，又称抢占方式`。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。

## 3.4 调度算法的评价指标

1. CPU利用率： 忙碌的时间 / 总时间

2. 系统吞吐量：总共完成了多少道作业  / 总共花了多少时间

3. 周转时间：

   > 从作业被提交给系统开始，到作业完成为止。它包括四个部分：作业在外存后备队列上等待作业调度（高级调度）的时间、进程在就绪队列上等待进程调度（低级调度）的时间、进程在CPU上执行的时间、进程等待I/O操作完成的时间

   1. 周转时间：作业完成时间-作业提交时间
   2. 平均周转时间：  作业完成时间-作业提交时间  / 作业数
   3. 带权周转时间：  作业周转时间 / 作业实际运行时间
   4. 平均带权周转时间：各作业的带权周转时间 / 作业数

4. 等待时间：周转时间 - 运行时间 - [I/O操作时间]

   1. `对于进程来说`，等待时间就是指进程建立后等待被服务的时间之和，在等待I/O完成的期间其实进程也是在被服务的，所以不计入等待时间。
   2. `对于作业来说`，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间。

5. 响应时间:   指从用户提交请求到首次产生响应所用的时间。

## 3.5 调度算法

前三种一般适合于`早期的批处理系统` ,

后3种适合于`交互式系统`

### I 先来先服务(FCFS)

First Come First Serve

![image-20210904104040859](https://gitee.com/aik-aid/picture/raw/master/image-20210904104040859.png)

### II 短作业优先(SJF)

![image-20210904104758586](https://gitee.com/aik-aid/picture/raw/master/image-20210904104758586.png)

### III 高响应比优先(HRRN)

![image-20210904105229740](https://gitee.com/aik-aid/picture/raw/master/image-20210904105229740.png)

### IV 时间片轮转调度算法(RR)

![image-20210904111043661](https://gitee.com/aik-aid/picture/raw/master/image-20210904111043661.png)

如果`时间片太大`，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法退化为FCFS算法，并且会增加进程响应时间

另一方面进程调度、切换是有时间代价的(保存、恢复运行环境)，因此如果`时间片太小`，会导致进程切换过于频繁，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减少。可见时间片也不能太小。

### V 优先级调度算法

![image-20210904111258495](https://gitee.com/aik-aid/picture/raw/master/image-20210904111258495.png)



![image-20210904111314895](https://gitee.com/aik-aid/picture/raw/master/image-20210904111314895.png)

### VI 多级反馈队列调度算法

![image-20210904111347090](https://gitee.com/aik-aid/picture/raw/master/image-20210904111347090.png)

![image-20210904111802020](https://gitee.com/aik-aid/picture/raw/master/image-20210904111802020.png)

# 4. 进程同步

进程具有`异步性`的特征。异步性是指，各并发执行的进程以各自独立的、不可预知的速度向前推进。

操作系统要提供`进程同步`机制来解决异步问题

> 同步亦称**直接制约关系**，是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而等待、传递信息所产生的制约关系。进程间的直接制约关系源于它们之间的相互合作。在某些位置上协调它们的工作次序而等待、传递信息所产生的制约关系。进程间的直接制约关系源于它们之间的相互合作。

互斥

> 互斥也称**间接制约关系。**当一个进程进入临界区使用临界资源时，另- 一个进程必须等待，当占用临界资源的进程退出临界区后，另-进程才允许去访问此临界资源。

## 4.1 临界资源

虽然多个进程可以共享系统中的各种资源，但其中许多`资源一次只能为一个进程所用`，我们将一次仅允许一个进程使用的资源称为`临界资源`。许多物理设备都属于临界资源，如打印机等。比外，还有许多变量、数据等都可以被若干进程共享，也属于临界资源。

`临界区`：访问临界资源的那段代码

对临界资源的访问，必须互斥的进行。可以把临界资源的访问分为4个过程

- 进入区：

  > 负责检查是否可进入临界区，若可进入，则应设置正在访问临界资源的标志（可理解为“上锁”），以阻止其他进程同时进入临界区

- 临界区

- 退出区：负责解除正在访问临界资源的标志（可理解为“解锁”）

- 剩余区：做其他处理

为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则：

1. 空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区；
2. 忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待；
3. 有限等待。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）；
4. 让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。

## 4.2 进程互斥的软件实现方法

### I 单标志法

算法思想：一个进程在`访问完临界区`后会把使用临界区的权限转交给另一个进程。也就是说`每个进程进入临界区的权限只能被另一个进程赋予`

![image-20210904152539409](https://gitee.com/aik-aid/picture/raw/master/image-20210904152539409.png)

只能按P0→P1→P0→P1....这样轮流访问。这种必须“轮流访问”带来的问题是，如果此时允许进入临界区的进程是PO，而PO一直不访问临界区，那么虽然此时临界区空闲，但是并不允许P1访问。因此，单标志法存在的主要问题是:违背`空闲让进`原则。

### II 双标志先检查法

![image-20210904152744919](https://gitee.com/aik-aid/picture/raw/master/image-20210904152744919.png)

若按照①⑤②⑥③⑦….的顺序执行，P0和P1将会同时访问临界区。因此，双标志先检查法的主要问题是：违反`忙则等待`原则。原因在于，进入区的“检查”和“上锁”两个处理不是一气呵成的。“检查”后，“上锁”前可能发生进程切换。

### III 双标志后检查法

![image-20210904152936703](https://gitee.com/aik-aid/picture/raw/master/image-20210904152936703.png)

若按照①⑤②⑥….的顺序执行，P0和P1将都无法进入临界区因此，双标志后检查法虽然解决了`忙则等待`的问题，但是又违背了`空闲让进`和`有限等待`原则，会因各进程都长期无法访问临界资源而产生“饥饿”现象。两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区。

### IV Peterson算法

![image-20210904153040743](https://gitee.com/aik-aid/picture/raw/master/image-20210904153040743.png)

Peterson算法用软件方法解决了进程互斥问题，遵循了空闲让进、忙则等待、有限等待三个原则，但是依然未遵循`让权等待`的原则。

## 4.3 进程互斥的硬件实现方法

### I 中断屏蔽

利用“开/关中断指令”实现（与原语的实现思想相同，即在某进程开始访问临界区到结束访问为止都不允许被中断，也就不能发生进程切换，因此也不可能发生两个同时访问临界区的情况）

**优点**：简单、高效
**缺点**：不适用于多处理机；只适用于操作系统内核进程，不适用于用户进程（因为开/关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险）

### II TestAndSet

简称TS指令，也有地方称为TestAndSetLock指令，或TSL指令
TSL指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成。以下是用C语言描述的逻辑

![image-20210904153900682](https://gitee.com/aik-aid/picture/raw/master/image-20210904153900682.png)

### III Swap

有的地方也叫Exchange指令，或简称XCHG指令。
Swap指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成。以下是用C语言描述的逻辑

![image-20210904154018051](https://gitee.com/aik-aid/picture/raw/master/image-20210904154018051.png)



## 4.4 信号量机制

用户进程可以通过使用操作系统提供的`一对原语`来对`信号量`进行操作，从而很方便的实现了进程互斥、进程同步。

`信号量`其实就是一个变量，可以用一个信号量来表示`系统中某种资源的数量`，比如：系统中只有一台打印机，就可以设置一个初值为1的信号量。

一对原语：wait(S)原语和signal(S)原语

wait、signal原语常简称为P、V操作（来自荷兰语proberen和verhogen）。因此，做题的时候常把wait(S)、signal(S)两个操作分别写为P(S)、V(S)

### 4.4.1 整型信号量

![image-20210904164349787](https://gitee.com/aik-aid/picture/raw/master/image-20210904164349787.png)

### 4.4.2 记录型信号量

![image-20210904164419535](https://gitee.com/aik-aid/picture/raw/master/image-20210904164419535.png)

### 4.4.3 信号量实现进程互斥

![image-20210904164639676](https://gitee.com/aik-aid/picture/raw/master/image-20210904164639676.png)

### 4.4.4 信号量实现进程同步

进程同步：要让各并发进程按要求有序地推进。

若P2的“代码4”要基于P1的“代码1”和“代码2”的运行结果才能执行，那么我们就必须保证“代码4”一定是在“代码2”之后才会执行。

![image-20210904164720656](https://gitee.com/aik-aid/picture/raw/master/image-20210904164720656.png)

### 4.4.5 信号量实现进程的前驱关系

![image-20210904164937430](https://gitee.com/aik-aid/picture/raw/master/image-20210904164937430.png)

## 4.5 经典问题

### 4.5.1 生产者-消费者问题

#### I 问题分析

1. 只有缓冲区没满，生产者才能将产品放入缓冲区 ----> 生产者 和 缓冲区未满 是同步关系

> 用full作为缓冲区中已经使用的数量，初始值为0

2. 只有缓冲区未空，消费者才能从缓冲区取出产品 ----> 消费者 和 缓冲区未空 是同步关系

> 用empty作为缓冲区未使用的数量，初始值为n

3. 由于缓冲区是临界资源，所以只允许一个生产者放入产品，或者一个消费者从中取出产品 --> 生产者和消费者对缓冲区的访问是互斥的

> 用mutex作为互斥信号量，初始值为1 

#### II 代码

![image-20210905092811838](https://gitee.com/aik-aid/picture/raw/master/image-20210905092811838.png)

能否改变 P(empty)和P(mutex)的顺序

> 不能
>
> 会造成死锁

### 4.5.2 多生产者-多消费者问题

多是指 多种类型

![image-20210905100212296](https://gitee.com/aik-aid/picture/raw/master/image-20210905100212296.png)

1. 父亲将苹果放入盘子后，女儿才能取苹果
2. 母亲将橘子放入盘子后，儿子才能取橘子
3. 只有盘子为空时，父亲或母亲才能放入水果（“盘子为空”这个事件可以由儿子或女儿触发，事件发生后才允许父亲或母亲放水果）

![image-20210905100905487](https://gitee.com/aik-aid/picture/raw/master/image-20210905100905487.png)

总结：在生产者-消费者问题中，如果缓冲区大小为1，那么有可能不需要设置互斥信号量就可以实现
互斥访问缓冲区的功能。当然，这不是绝对的，要具体问题具体分析。

> 原因在于：本题中的缓冲区大小为1，在任何时刻，apple、orange、plate三个同步信号量中最多只有一个是1。因此在任何时刻，最多只有一个进程的P操作不会被阻塞，并顺利地进入临界区…

### 4.5.3 吸烟者问题

假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种材料：烟草、纸和胶水。三个抽烟者中，第一个拥有烟草、第二个拥有纸、第三个拥有胶水。供应者进程无限地提供三种材料，供应者每次将两种材料放桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了，供应者就会放另外两种材料再桌上，这个过程一直重复（让三个抽烟者轮流地抽烟）

本质上这题也属于“生产者-消费者”问题，更详细的说应该是“可生产多种产品的单生产者-多消费者”

桌上有组合一 -> 第一个抽烟者取走东西
桌上有组合二 -> 第二个抽烟者取走东西
桌上有组合三 ->第三个抽烟者取走东西
发出完成信号 -> 供应者将下一个组合放到桌上

![image-20210905160909444](https://gitee.com/aik-aid/picture/raw/master/image-20210905160909444.png)



### 4.5.4 读者写者问题

![image-20210905160837003](https://gitee.com/aik-aid/picture/raw/master/image-20210905160837003.png)

但是上述代码可能会导致写进程饿死

![image-20210905161131785](https://gitee.com/aik-aid/picture/raw/master/image-20210905161131785.png)

#### I 重点

读者-写者问题为我们解决复杂的互斥问题提供了一个参考思路。

其核心思想在于设置了一个计数器count用来记录当前正在访问共享文件的读进程数。我们可以用count的值来判断当前进入的进程是否是第一个/最后一个读进程，从而做出不同的处理。

另外，对count变量的检查和赋值不能一气呵成导致了一些错误，如果需要实现“一气呵成”，自然应该想到用互斥信号量。

最后，还要认真体会我们是如何解决“写进程饥饿”问题的。

### 4.5.5 哲学家进餐问题

![image-20210905161525935](https://gitee.com/aik-aid/picture/raw/master/image-20210905161525935.png)

## 4.6 管程

![image-20210905162928768](https://gitee.com/aik-aid/picture/raw/master/image-20210905162928768.png)

相当于Java中的synchronized

# 5. 死锁

## 5.1 死锁产生的原因

1. 系统资源的竞争

2. 进程推进顺序非法
3. 信号量的使用不当

![image-20210905184532012](https://gitee.com/aik-aid/picture/raw/master/image-20210905184532012.png)

![image-20210905184727547](https://gitee.com/aik-aid/picture/raw/master/image-20210905184727547.png)

## 5.2 预防死锁

死锁的产生必须满足四个必要条件，只要其中一个或者几个条件不满足，死锁就不会发生。

所以可以通过破坏

- 互斥条件
- 不剥夺条件
- 请求和等待条件
- 循环等待条件

来预付死锁

### I 互斥条件

如果把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。比如: SPOOLing技术。操作系统可以采用SPOOLing 技术把独占设备在逻辑上改造成共享设备。比如，用SPOOLing技术将打印机改造为共享设备…

该策略的缺点：并不是所有的资源都可以改造成可共享使用的资源。并且为了系统安全，很多地方还必须保护这种互斥性。因此，`很多时候都无法破坏互斥条件。`

### II 不剥夺条件

破坏不剥夺条件：
方案一：当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件。

方案二：当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级（比如：剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用）

该策略的缺点：

1. 实现起来比较复杂。
2. 释放已获得的资源可能造成前一阶段工作的失效。因此这种方法一般只适用于易保存和恢复状态的资源，如CPU。
3. 反复地申请和释放资源会增加系统开销，降低系统吞吐量。
4. 若采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源就都需要放弃，以后再重新申请。如果一直发生这样的情况，就会导致进程饥饿。

### III 请求和等待条件

可以采用`静态分配方法`，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行。一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源了。

该策略实现起来简单，但也有明显的缺点：
有些资源可能只需要用很短的时间，因此如果进程的整个运行期间都一直保持着所有资源，就会造成严重的资源浪费，资源利用率极低。另外，该策略也有可能导致某些进程饥饿。

### IV 循环等待条件

![image-20210905185158340](https://gitee.com/aik-aid/picture/raw/master/image-20210905185158340.png)

## 5.3 避免死锁

![image-20210905185238522](https://gitee.com/aik-aid/picture/raw/master/image-20210905185238522.png)

![image-20210905185311694](https://gitee.com/aik-aid/picture/raw/master/image-20210905185311694.png)

## 5.4 死锁的检测和解除

