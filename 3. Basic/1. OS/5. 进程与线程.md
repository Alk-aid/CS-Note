# 1. 进程

## 1.1 进程的概念

1. **进程的状态**：新生（new）、就绪（ready）、运行（running）、阻塞（blocked）、终止（terminated）
2. **进程的虚拟内存空间布局**：（在/proc/PID/maps查看布局）

- `程序代码和数据`：代码和数据区是直接按照可执行目标文件的内容初始化的，数据主要是指全局变量
- `堆`：调用malloc 和 free时堆可以动态扩展和收缩
- `共享库`：存放标准库和数学库等共享库的代码和数据的区域
- `栈`：调用和返回函数时栈会增长和收缩。
- `内核部分`：空间最顶端的部分，只有进入内核态才可见

![image-20220104150654207](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/image-20220104150654207.png)

3. 进程控制块（PCB）： 主要有PID，进程状态，虚拟内存状态，打开的文件，上下文。

```C++
struct task_struct{
    // 进程信息
    volatile long state;
    // 虚拟内存状态
    struct mm_struct *mm;
    //进程标识符
    pid_t pid;
    // 进程间关系
	struct task_struct __rcu *real_parent;
    struct task_struct __rcu *parent;
    struct list_head children;
    // 打开文件
    struct files_struct *files;
    ....
}
```

4. **进程的上下文(context)**: 包括进程运行时的寄存器状态，能够用于保存和恢复一个进程在处理机上运行的状态。当使用上下文切换机制，会将前一个进程的寄存器状态保存到PCB中，然后将下一个进程的状态从PCB中写入到寄存器中，从而切换到该进程执行

## 1.2 进程创建--fork

### 1.2.1 概念

```C++
// 在父进程中，fork 返回子进程的PID
// 在子进程中，fork 返回 0
// fork 返回一个负值,有两种情况
// 1. 当前的进程数已经达到了系统规定的上限，这时 errno 的值被设置为 EAGAIN
// 2. 系统内存不足，这时 errno 的值被设置为 ENOMEM
pid_t fork(void);
```

### 1.2.2 为什么fork使用cow

1. 早期fork会完整拷贝父进程的物理内存，并映射到子进程的内存空间中。
2. 但是很多内存是只读的状态(共享代码库，代码段)，对他们进行拷贝是一种浪费
3. 其次，由于进程有时会在调用fork之后立即调用exec以载入新的可执行文件，重置地址空间，那么之前的内存拷贝就完全失去了意义。
4. 所以操作系统利用cow来对fork进行优化
5. 刚调用完fork()之后，子进程只是拥有一份和父进程相同的页表
6. 对于本来就是只读虚拟页，父子进程直接共享。
7. 对于容易容易发生变化的虚拟页，一旦出现了写操作，就会触发cow。
7. 这样既提升了fork的性能，又能降低内存占用率。

## 1.3 进程执行--exec

在fork以后，我们得到了一个与父进程几乎完全相同的子进程，但是很多时候子进程需要执行与父进程完全不同的任务。

```C++
#inclue<unistd.h>
// 1. 进程需要载入的可执行文件的路径
// 2. 进程执行所需的参数
// 3. 为进程定义的环境变量，一般以k-v形式传入
int execve(const char *pathname, char *const argv[], char *const envp[]);
```

当execve被调用，OS需要完成以下几个步骤

- 根据pathname，将可执行文件的数据段和代码段载入当前进程的地址空间
- 重新初始化堆和栈，在这里，OS可以进行地址空间随机化操作，改变堆和栈的起始地址，增强进程的安全性
- 将PC寄存器设置到可执行文件代码段定义的入口点，该入口点最终会调用main函数

> fork和exec的组合可以认为是**将进程创建过程进一步解耦**，程序可以在fork调用后，exec调用前对子进程进行各种设定，比如文件重定向

## 1.4 进程管理

1. 每一个进程都会记录自己的父进程和子进程，进程之间因此构成了进程树
2. 内核正是通过这种`进程树`来对进程进行管理
3. `idle`: 由系统自动创建, 运行在内核态,pid = 0。是init进程和kthreadd进程（内核线程）的父进程；最低优先级，且不参与调度，只是在运行队列为空的时候才被调度（空转）。
4. `init`: 是Linux中第一个用户态的进程，PID = 1，是其他用户空间进程的直接或间接父进程；
5. `kthreadd`: 之后由内核创建和管理的进程都是由它fork出来的(pid = 2)

## 1.5 进程监控--wait

使用wait操作来对其子进程进行监控。

```C++
// 1. 第一个参数为需要等待的子进程的id,
// 2. 第二个参数用来保存子进程的状态
// 3. 如果子进程已经退出，那么waitpid会立即返回，并且设置status变量的值
// 4. 如果子进程还没有退出，那么waitpid会阻塞，并且等待子进程退出
pid_t waitpid(pid_t pid, int *wstatus, int optio	ns);
```

僵尸进程

- 子进程调用exec结束时，并没有真正被销毁，而是仍然保存着进程的文件描述符，PID，进程终止状态等内容

处理僵尸进程

- 忽略SIGCHLD信号(该信号是子进程退出的时候向父进程发送的), 把僵尸进程交给init进程去处理
- 父进程调用wait/waitpid函数
- 父进程退出，交由init进程处理

僵尸进程危害

- 内核会设定最大可用PID限制;如果一个进程创建了大量子进程但不调用wait，那么僵尸进程会迅速占据可用的PID;使得后续的fork因为内核资源不足而失败

孤儿进程

- 父进程退出，子进程还在运行，这些子进程将成为孤儿进程。孤儿进程将被init进程(pid为1)所管理

## 1.6 进程组/会话

### 1.6.1 进程组

进程组(process group):是进程的集合。在默认情况下，父进程和子进程属于同一个进程组

1. Linux中，task_struct记录的tgid即为进程对应的进程组标识符
2. 进程组的一大作用体现在`信号`的处理上：应用程序可以killpg发送信号，通知进程组的每个进程。
3. 可用调用setpgid创建一个新的进程或者移入已有的进程组

### 1.6.2 会话

会话（Session）：进程组的集合，根据执行状态，分为前台进程组（foreground thread group），和后台进程组（background group）。

1. 控制终端进程是会话与外界交互的一个入口，她负责接收用户发来的输入。
2. 如果在终端输入Ctrl-C，终端进程就会收到一个SIGINT信号，并将它发送给前台进程组处理，使得前台进程组所有进程退出

## 1.7 clone

Linux支持对clone进行更精密的控制，允许指定进程栈的位置、禁止复制内存等操作。包括隔离namespace等。

clone支持四个参数，从而允许程序对于fork的过程进行控制。

```c
#include<sched.h>
// 1. fb为创建完执行的函数
// 2. stack制定子进程栈的位置，解决了父子进程共享地址空间时栈冲突问题
// 3. flag来指定不需要复制的部分
// 4. 参数
int clone(int (fn*)(void *), void *stack, int flags, void *arg, ...);
```

## 1.8 进程的状态

一个进程在 Linux 源码中存在如下六个枚举状态：

|  值  |         状态         |      代号      |                             说明                             |
| :--: | :------------------: | :------------: | :----------------------------------------------------------: |
|  0   |     TASK_RUNNING     |  R (running)   |                     运行态和就绪态的结合                     |
|  1   |  TASK_INTERRUPTIBLE  |  S (sleeping)  |         阻塞态，等待条件满足或者收到信号会成为R状态          |
|  2   | TASK_UNINTERRUPTIBLE | D (disk sleep) | 阻塞态，只有等待条件满足才会成为R状态(内核态的处理不能被打断) |
|  4   |     TASK_STOPPED     |  T (stopped)   |  SIGSTOP、SIGTSTP、SIGTTIN、SIGTTOUT等信号会将进程暂时停止   |
|  16  |     EXIT_ZOMBIE      |   Z (zombie)   |              进程已死，只是文件描述符还未被回收              |
|  32  |      EXIT_DEAD       |    X (dead)    |                                                              |

# 2. 线程

**线程的分类**

- 用户态线程(User-Level Thread):  应用创建，内核不可见，不受系统调度器管理，更加轻量，开销小。
- 内核态线程(Kernel-Level Thread)：内核创建，受操作系统调度器管理

**多线程模型：**

- 用户态功能受限，与内核态相关的操作（如系统调用）需要内核态线程协助才能完成。这种协作称之为**多线程模型**
- 多线程模型主要有三种：多对一，一对一，多对多。
  - **多对一**：多个用户态线程映射给单一的内核态线程。模型简单，每次只能有一个用户态线程可以进入内核，其他用户态线程会被阻塞。
  - **一对一**：系统开销大
  - **多对多**：解决了内核态线程太少导致的阻塞，也解决了内核态线程过多造成的性能开销过大，但是让内核态线程管理变得复杂。

> Linux使用一对一模型

**线程上下文**：处理器运行一个线程时的所有状态信息

- 程序计数器，当前执行指令的地址
- 通用寄存器，当前处理数据
- 特殊寄存器，硬件状态和配置如页表地址等

OS会将线程的上下文保存在该线程对应的内核态线程的TCB中

# 3. 协程

- 协程又叫做用户态线程，创建协程时，会从进程的堆中分配一段内存作为协程的栈。

- 协程的上下文切换是在用户态完成的，不涉及到内核态和用户态的切换，也不涉及对上一个上下文的保存，性能明显优于线程的上下文切换。因为它的上下文是维护在用户态开辟的一块内存里，而它的任务调度是在代码里显式处理的。

- 协程不具备使用中断抢占其他协程的权限，而是通过yield来暂时放弃CPU以允许其他协程的调用。

# 4. 进程/线程/协程区别

从理论的角度来说

- `本质`：进程是各自拥有独立的虚拟地址空间；线程是通过在进程内部添加的可独立执行的单元。同一个进程的线程共享进程的用户堆，共享数据，代码等，同时又各自保留运行时所需要的状态在内核栈和用户栈中；
- `创建`：创建进程开销大，因为需要创建独立的地址空间，而线程因为共享进程空间，开销要小很多
- `通信`：进程因为拥有独立的地址空间，进行进程间通信比较麻烦，需要通过共享内存，管道，信号量，信号，消息队列等；而线程因为共享进程的地址，所以可以直接进行通信
- `上下文切换`：进程进行上下文切换的性能损耗大，而线程因为共享同一进程的地址，损耗小一些。
- `定位`：引入进程以后，进程成为了资源分配的单位，线程成为了调度的单位

从Linux角度

- 在Linux中，进程和线程没什么区别，都是通过`task_strcut`来表示的。我们可以认为`task_struct`结构体代表一个线程，而进程是一组具有相同进程号`task_struct`的抽象概念。

- 进程通过fork创建，线程通过pthread_create创建，但是他们本质上都是通过clone来创建。

- 进程通过COW开辟属于自己的内存空间，彼此的内存是完全隔离的；而线程会一直共享虚拟内存，文件系统，打开的文件，信号处理等。

  

