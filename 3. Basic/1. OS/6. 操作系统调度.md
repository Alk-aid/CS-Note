# 1. 调度的管理

一般调度器会通过**维护运行队列的方式**来管理任务。例如Linux会用`红黑树`来实现运行队列。任务在执行时若触发一定条件，则会停止执行，如果还需要执行，会被重新加入运行队列。

调度器的决策包括：

- 从运行队列选择下一个运行的任务
- 决定执行该任务的CPU核心
- 决定该任务被允许执行的时间（时间片）

决策完成后系统中的相应机制便会将任务执行在对应的CPU核心上。

# 2. 调度的指标

- **批处理任务**如机器学习的训练、复杂的科学计算，无需与用户交互，尽可能快的完成，需要：**吞吐量尽可能高，周转时间尽可能短**。
- **交互式任务**如程序调试，希望**响应时间足够短**。
- 有截至时间要求的**实时任务**如车载系统中的自动刹车，要求实时任务在截止时间前完成**满足实时性**。
- 移动设备有**待机时间**的要求，即移动设备上的操作系统调度要尽可能**降低能耗**。

# 3. 调度的机制

- `长期调度`：决定是否为一个程序创建对应的进程，`负责增加系统中可被调度的进程的数量`。
- `短期调度`：从运行队列中选取一个任务为他分配CPU时间片,`负责调度进程的执行`
- `中期调度`：将被调度的进程挂起，并将被挂起的进程所使用的内存页替换到磁盘中(页面置换算法),`限制系统中可被调度的进程`

> - 长期和短期是从CPU,I/O资源的角度做出调度决策
> - 中期调度是从内存资源的角度做出决策

![image-20220105110203079](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/image-20220105110203079.png)

# 4. 调度策略一(ToDo)

`经典调度策略`：

- **FIFO/FCFS**（First In First Out/First Come First Serve）：从就绪队列中选择一个最先进入该队列的进程为之分配资源，对短任务和IO密集型任务不友好，`非抢占式的`
- **SJF**（Shortest Job First）：从就绪队列中选出一个估计运行时间最短的进程为之分配资源,表现严重依赖于任务到达的时间点，`非抢占式的`
- **STCF**（Shortest Time-to-Completion First）：最短完成时间优先，SJF的抢占版本，弊端是长任务饥饿
- **RR**（Round Robin）：每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。在任务运行时间相似的情况下周转时间很高。

![image-20220105111631973](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/image-20220105111631973.png)

`优先级调度策略`：为了让操作系统可以区分交互式任务和批处理任务，可以设置一个让交互式任务优先执行的调度策略。引入优先级概念。

- **MLQ**（Multi-Level Queue）：
  - 每个任务会被分配预先设置好的优先级，每个优先级对应一个队列，任务会被储存在对应的优先级队列中。如果优先级不同的任务同时处于就绪状态，那么调度器倾向于调度优先级较高的任务。同优先级的任务采用FCFS（可以被更高优先级抢占）或RR策略。
  - 一般会让I/O密集型任务优先级提高（对CPU资源消耗较少），充分利用空闲的I/O资源。
  - 弊端：低优先级任务饥饿
- **MLFQ**（Multi-Level Feedback Queue）：
  - 同样维护多个优先级队列，任务存储在不同的队列中，高优先级的先于低优先级的执行，同优先级的使用RR策略。此外还有以下策略
  - 短任务拥有更高的优先级，低优先级的采用更长的时间片。
  - 首先进来的任务都分配最高优先级以及为每个任务队列设置一个最大允许时间（非时间片），如果某一任务超过队列允许运行的最大的时间，则优先级降低，
  - 定时将所有任务的优先级提至最高（防止低优先级饥饿）
  - 弊端：需要调整很多调度参数：优先级队列数量、每个优先级队列采用时间片、任务在每个优先级队列的最大运行时间、调度器定时提升优先级的时间间隔。提升优先级的时间间隔过短可能会让MLFQ退化成RR。提升优先级的时间间隔过长可能会导致长任务保持在最低优先级队列中

`公平共享调度策略`：

- Fair-share Scheduling：以份额量化CPU时间
- Lottery Scheduling：以抽彩票数量决定被调度的概率；份额大的任务可以彩票转让（ticket transfer）给小的任务；同时允许给自己的子任务不同的彩票货币（ticket currency）避免频繁修改；任务可以根据CPU需求，通过彩票通胀（ticket inflation）决定自己的调度份额。
- Stride Scheduling：引入虚拟时间（virtual runtime）以步幅来决定调度，任务份额决定步幅的倒数。也可以使用借用虚拟时间（Borrowed Virtual Runtime），保证公平的同时提升实时性。

`多核调度策略`：

- Load Sharing：从全局队列中取任务。后续添加了（Two-level Scheduling）策略，引入了本地队列。
- Energy Aware Scheduling：对每个CPU的容量，功率权衡，划分性能域，找到最合适的核来运行。

# 5. 调度策略二

- **先来先服务(FCFS)：**
  - 从就绪队列中选择一个最先进入该队列的进程为之分配资源，对短任务和IO密集型任务不友好，`非抢占式的`
- **短作业优先调度算法(SJF)**：
  - 是从就绪队列中选出一估计运行时间最短的进程，将处理机分配给它，使它立即执行，`非抢占式的`
- **高响应比优先调度算法(Highest Response Ratio Next)**：
  - 响应比：（等待时间+要求服务时间）/ 要求服务时间 = (响应时间)/ 要求服务时间
  - 即考虑到各个作业的等待时间，也能兼顾运行时间。`非抢占式的`
- **时间片轮转调度(RR)**：
  - 为就绪队列维护一个FIFO的队列，从队头取出任务，让其执行固定时间片的任务；若在时间片内未执行完则插入到队尾。
  - 时间片太大，则退化为FCFS算法；时间片太小则会导致进程切换过于频繁，影响性能

- **优先级调度算法**:  
  - 为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。
  - 具有相同优先级的进程以 FCFS 方式执行。
  - 为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。
- **多级反馈队列调度算法**
  - 设置`多个就绪队列`，并为各个队列赋予不同的`优先级`和不同长度的`时间片`，优先级越高时间片越少
  - 新创建的进程挂到`第一优先级`的队列后，然后按 `FCFS 原则`排队等待调度。当轮到其执行时，如它能在`时间片`内完成，便撤离系统；如果不能完成，便被挂`入第二级队列`后，……，最后一级队列采用`时间片轮转法`；
  - 仅当第一级队列空闲时，调度程序才调度第二级队列中的进程运行，依次类推……；新进程可抢占低级进程的处理机。被抢占处理机的进程重新放回原队列队尾。
- **完全公平调度算法(CFS)**
  - CFS适用于普通任务.实时进程可以采用SCHED_FIFO 和SCHED_RR调度策略。
  - CFS理念是让分配给每个任务的CPU的时间是一样的，实现的方式是为每个任务安排一个vruntime，一个任务运行的越久，vruntime越大。CFS调度算法优先选择vruntime少的任务，来保证公平性。运行完成以后更新vruntime，重新放入运行队列里等待下次被调度
  - vruntime += 实际运行时间(delta_exec) * NICE_0_LOAD / 权重。
  - nice级别越低，权重越大。
  - nice表示的不是优先级，而是优先级的修正数值。 priority(new) = priority(old) + nice
  - 实时任务的优先级0 ~ 99,普通任务是100 ~ 139.
  - nice的取值是-20 ~ 19,提供给普通任务用的 

# 6. CFS相关问题

1. 新进程的vruntime的初始值是不是0？

>   假如新进程的vruntime初值为0的话，比老进程的值小很多，那么它在相当长的时间内都会保持抢占CPU的优势，老进程就要饿死了，这显然是不公平的。所以CFS是这样做的：每个CPU的运行队列cfs_rq都维护一个 min_vruntime 字段，记录该运行队列中所有进程的vruntime最小值，新进程的初始vruntime值就以它所在运行队列的min_vruntime为基础来设置，与老进程保持在合理的差距范围内。

2. 休眠进程的vruntime的值一直保持不变吗？

>   如果休眠进程的 vruntime 保持不变，而其他运行进程的 vruntime 一直在推进，那么等到休眠进程终于唤醒的时候，它的vruntime比别人小很多，会使它获得长时间抢占CPU的优势，其他进程就要饿死了。这显然是另一种形式的不公平。CFS是这样做的：在休眠进程被唤醒时重新设置vruntime值，以min_vruntime值为基础，给予一定的补偿，但不能补偿太多。

3. 进程占用的时间片可以无穷小吗？

>   假设有两个进程，它们的vruntime初值都是一样的，第一个进程只要一运行，它的vruntime马上就比第二个进程更大了，那么它的CPU会立即被第二个进程抢占吗？答案是这样的：为了避免过于短暂的进程切换造成太大的消耗，CFS设定了**进程占用CPU的最小时间值， sched_min_granularity_ns** ，正在CPU上运行的进程如果不足这个时间是不可以被调离CPU的。

4. 进程从一个CPU迁移至另外一个CPU的时候vruntime会变化吗？

>   当进程从一个CPU的运行队列中出来 (dequeue_entity) 的时候，它的vruntime要减去队列的min_vruntime值； 而当进程加入另一个CPU的运行队列 ( enqueue_entiry) 时，它的vruntime要加上该队列的min_vruntime值。 这样，进程从一个CPU迁移到另一个CPU之后，vruntime保持相对公平。
