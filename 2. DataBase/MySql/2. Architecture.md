# Architecture

1. Clients: 连接处理, 身份认证, 权限校验等

- 连接处理: 使用连接池, 为每次请求分配一个线程(一般使用长连接, 超过`wait_timeout`会自动断开)
- 身份认证: 校验username, password, originating host
- 权限校验: 去权限表中查出该连接拥有的权限;之后, 该连接里面的权限判断，都依赖于此时读到的权限

2. Server:  所有跨存储引擎的功能在这一层实现，如存储过程、触发器、视图等

- Parser: 解析请求, 从而创建一个 parse tree
- Optimizer: 确定索引的选取, 确定表的读取顺序, 从而生成执行计划(优化成本取决于 IO + CPU)
- Excutor: 校验权限, 然后调用 Storage Engines API

3. Storage Engines: 存储 和 查询数据

<img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492080503/files/assets/hpm4_0101.png" alt="img" style="zoom:50%;" />

# Storage Engine

## 2.1 基本介绍

1. 存储引擎就是`存储数据`，`建立索引`，`锁`，`外键`等等技术的实现方式 。
2. 存储引擎是基于表的，而不是基于库的。所以存储引擎也可被称为表类型。
3. mysql支持插件式的存储引擎,从而在不同场景选用不同存储引擎，达到更好的效果

MySQL 支持的存储引擎：

- MySQL 支持的引擎包括：InnoDB、MyISAM、MEMORY、Archive、Federate、CSV、BLACKHOLE 等
- MySQL5.5 之前的默认存储引擎是 MyISAM，5.5 之后就改为了 InnoDB

## 2.2 引擎对比

* 事务：InnoDB 支持事务，MyISAM 和 Memory 不支持事务
* 外键：InnoDB 支持外键，MyISAM 和 Memory 不支持外键
* 锁粒度：InnoDB 最小的锁粒度是行锁，MyISAM 和 Memory 最小的锁粒度是表锁
* MVCC: InnoDB 支持 MVCC, 而 MyISAM 不支持 MVCC
* 索引：InnoDB 是聚集（聚簇）索引，MyISAM 是非聚集（非聚簇）索引，Memory使用Hash索引。
* 存储结构：InnoDB数据和索引是一起存储的；MyISAM的数据和索引是分开存储的（.MYD存储数据，.MYI存储索引）。Memory的表数据存储在内存当中，结构存储在磁盘中

- InnoDB 不保存表的具体行数。而 MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快

- 应用场景
  - MyISAM：适合对于事务的完整性没有要求，以读和插入操作为主，只有极少的更新和删除
  - MEMORY：表的数据不是很多，对于需要快速定位记录可以提高极快的访问速度
  - InnoDB：如果对于事务要求高，并发下要求数据的一致性，除了查询和插入以外，还有很多更新和删除的，选择InnoDB

> Merge是一组MyISAM表的集合，这些MyISAM表必须结构完全相同。

## 2.3 引擎操作

* 查询数据库支持的存储引擎

  ```mysql
  SHOW ENGINES;
  SHOW VARIABLES LIKE '%storage_engine%'; -- 查看Mysql数据库默认的存储引擎 
  ```

* 查询某个数据库中所有数据表的存储引擎

  ```mysql
  SHOW TABLE STATUS FROM 数据库名称;
  ```

* 查询某个数据库中某个数据表的存储引擎

  ```mysql
  SHOW TABLE STATUS FROM 数据库名称 WHERE NAME = '数据表名称';
  ```

* 创建数据表，指定存储引擎

  ```mysql
  CREATE TABLE 表名(
  	列名,数据类型,
      ...
  )ENGINE = 引擎名称;
  ```

* 修改数据表的存储引擎

  ```mysql
  ALTER TABLE 表名 ENGINE = 引擎名称;
  ```

# 3. 范式

## 3.1 前置知识

### 3.1.1 各种名词

**关系**：对应一个表

**元组（tuple）**：每一个行就是元组

**属性（attribute）**：列的名字

schema：which describes the columns, or field

**候选键（prime attribute）**：由关系的一个或多个属性组成，候选键都具备键的特征，都有资格成为主键。

**主属性（prime attribute）**：所有候选键所包含的属性都是主属性。

**外键（foreign key）**：如果某一个关系A中的一个（组）属性是另一个关系B的键，则该（组）属性在A中称为外键。

**依赖（relation）**：列属性间存在的某种联系。

### 3.1.2 依赖

- 函数依赖：A → B，如果通过 A 属性(属性组)的值，可以确定唯一 B 属性的值，则称 B 依赖于 A
- 完全函数依赖：A → B，如果A是一个属性组，则 B 属性值的确定需要依赖于 A 属性组的所有属性值
- 部分函数依赖：A → B，如果 A 是一个属性组，则 B 属性值的确定只需要依赖于 A 属性组的某些属性值
- 传递函数依赖：A → B，B → C，如果通过A属性(属性组)的值，可以确定唯一 B 属性的值，在通过 B 属性(属性组)的值，可以确定唯一 C 属性的值，则称 C 传递函数依赖于 A

## 3.2 第一范式

属性（对应于表中的字段）不能再被分割，也就是这个字段只能是一个值，不能再分为多个其他的字段了。**1NF 是所有关系型数据库的最基本要求** ，也就是说关系型数据库中创建的表一定满足第一范式。

简而言之，**第一范式每一列不可再拆分，称为原子性**

## 3.3 第二范式

介绍第二范式

> **2NF：**在满足第一范式的基础上，非主属性完全依赖于键码(候选码)，消除非主属性对主码的部分函数依赖。简而言之，**表中的每一个字段 （所有列）都完全依赖于主键，记录的唯一性**

作用：遵守第二范式减少数据冗余，通过主键区分相同数据。



**分解前**

| Sno  | Sname  | Sdept  | Mname  | Cname  | Grade |
| :--: | :----: | :----: | :----: | :----: | :---: |
|  1   | 学生-1 | 学院-1 | 院长-1 | 课程-1 |  90   |
|  2   | 学生-2 | 学院-2 | 院长-2 | 课程-2 |  80   |
|  2   | 学生-2 | 学院-2 | 院长-2 | 课程-1 |  100  |
|  3   | 学生-3 | 学院-2 | 院长-2 | 课程-2 |  95   |

以上学生课程关系中，{Sno, Cname} 为键码，有如下函数依赖:

- Sno -> Sname, Sdept
- Sdept -> Mname
- Sno, Cname-> Grade

Grade 完全函数依赖于键码，它没有任何冗余数据，每个学生的每门课都有特定的成绩。

Sname, Sdept 和 Mname 都部分依赖于键码，当一个学生选修了多门课时，这些数据就会出现多次，造成大量冗余数据。

**分解后**

关系-1

| Sno  | Sname  | Sdept  | Mname  |
| :--: | :----: | :----: | :----: |
|  1   | 学生-1 | 学院-1 | 院长-1 |
|  2   | 学生-2 | 学院-2 | 院长-2 |
|  3   | 学生-3 | 学院-2 | 院长-2 |

有以下函数依赖:

- Sno -> Sname, Sdept
- Sdept -> Mname

关系-2

| Sno  | Cname  | Grade |
| :--: | :----: | :---: |
|  1   | 课程-1 |  90   |
|  2   | 课程-2 |  80   |
|  2   | 课程-1 |  100  |
|  3   | 课程-2 |  95   |

有以下函数依赖:

- Sno, Cname -> Grade

## 3.4 第三范式

**3NF：**在满足第二范式的基础上，消除传递依赖。简而言之，**非主键都直接依赖于主键，而不是通过其它的键来间接依赖于主键**。

作用：可以通过主键 id 区分相同数据，修改数据的时候只需要修改一张表（方便修改），反之需要修改多表。



非主属性不传递函数依赖于键码。

上面的 关系-1 中存在以下传递函数依赖:

- Sno -> Sdept -> Mname

可以进行以下分解:

关系-11

| Sno  | Sname  | Sdept  |
| :--: | :----: | :----: |
|  1   | 学生-1 | 学院-1 |
|  2   | 学生-2 | 学院-2 |
|  3   | 学生-3 | 学院-2 |

关系-12

| Sdept  | Mname  |
| :----: | :----: |
| 学院-1 | 院长-1 |
| 学院-2 | 院长-2 |

## 3.5 总结

- 1NF：属性不可再分。
- 2NF：1NF 的基础之上，消除了非主属性对于码的部分函数依赖。
- 3NF：3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖 。

