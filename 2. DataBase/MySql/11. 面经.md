# 1. 基本篇

## 1.2 count

count函数

- 参数不仅可以是字段名，也可以是其他任意表达式
- 作用是：统计符合查询条件的记录有多少条

结论： count(*) = count(1) > count(主键字段) > count(字段)

- count(*) / count(1)：优先选择key_len最小的二级索引进行扫描；如果没有，则使用主键索引进行扫描；作用是统计行数
- count(主键字段)：同样优先选择二级索引扫描每一行，比count(*)多的步骤是会取出记录里面的主键进行判断，是否为null
- count(普通字段)：采用全表扫描，效率最差

MyISAM 和 InnoDB

- MyISAM每张表都有一个字段来记录行数
- 因为InnoDB支持事务，同一时刻的多个查询，因为MVCC，返回的结果是不确定的，所以不能只维护一个row_count变量来记录行数

## 1.3 主键

为什么推荐使用整型自增主键而不是选择 UUID？

- 存储空间：UUID 是字符串，比整型消耗更多的存储空间；
- 比较效率：在 B+Tree 中进行查找时需要跟经过的节点值比较大小，整型数据的比较运算比字符串更快速；
- 插入效率：在插入或删除数据时，整型自增主键会在叶子结点的末尾建立新的叶子节点，不会破坏左侧子树的结构；UUID 主键很容易出现这样的情况，B+Tree  为了维持自身的特性，有可能会进行结构的重构，消耗更多的时间。

- 自增的整型索引在磁盘中会连续存储，在读取一页数据时也是连续；UUID 是随机产生的，读取的上下两行数据存储是分散的，不适合执行`where id > 5 && id <20`的条件查询语句；

## 1.4 join

先了解在join连接时哪个表是驱动表，哪个表是被驱动表：

1. 当使用left join时，左表是驱动表，右表是被驱动表
2. 当使用right join时，右表时驱动表，左表是驱动表
3. 当使用join时，mysql会选择数据量比较小的表作为驱动表，大表作为被驱动表
3. 当连接查询有where条件时，带where条件的表是驱动表，否则是被驱动表
4. EXPLAIN语句分析出来的第一行的表即是驱动表

> 结论：小表驱动大表优于大表驱动小表

join查询在有索引条件下

1. 驱动表有索引不会使用到索引
2. 被驱动表建立索引会使用到索引	

> 结论：给被驱动表建立索引

驱动表的含义：MySQL 表关联的算法是 Nest Loop Join.

- Simple Nested-Loop Join Algorithms : 不使用该算法

```java
for (row1 : 驱动表) {
    for (row2 : 被驱动表){
        if (conidtion == true){
            send client
        }
    }
}
```

- Index Nested-Loop Join Algorithms：我们对被驱动表创建了索引，那么MySQL一定使用的该算法

```java
// 如果给被驱动表加上索引
for (row1 : 驱动表) {
    索引在被驱动表中命中，不用再遍历被驱动表了
}
```

- Block Nested-Loop Join Algorithm: 当我们没有创建索引或者对驱动表创建了索引，使用该算法

> 1. 对在外部循环中读取的行进行缓冲，以减少必须读取内部循环中的表的次数。
> 2. 例如，如果将10行读入缓冲区并将缓冲区传递到下一个内部循环，则可以将内部循环中读取的每一行与缓冲区中的所有10行进行比较。这将内部表必须读取的次数减少了一个数量级。
> 3. MySQL连接缓冲区大小通过这个参数控制 ： join_buffer_size

![image-20220414102649428](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/image-20220414102649428.png)

# 2. 索引

查找过程

- 首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。

联合索引的优势

- 减少开销，建立一个联合索引相当于建立了多个索引，减少了磁盘空间的开销
- 覆盖索引，可以使用覆盖索引提高效率
- 索引列越多，通过索引筛选出来的数据越精确，越少

# 3. 事务

## 3.1 长事务

为什么不建议长事务

- 长事务意味着系统里面会存在很老的事务视图
- 由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间
- 长事务还占用锁资源

如何避免长事务对业务的影响

- 从应用开发端：
- 从数据库端

# 问题排查

MySQL 数据库 CPU 飙升到 500% 的话他怎么处理？

- 首先用top指令查看是不是mysqld占用造成的
- 使用show processlist查看正在运行的线程，是不是有消耗资源的 SQL 在运行；
- 找到消耗高的SQL，使用explain查看执行计划，是不是没用索引
- 然后kill掉这些线程，进行相应的调整（比如说加索引、改 SQL、改内存参数）之后，再重新跑这些 SQL。

# 命令区别

union和 union all

- 两者都是将两个结果集合并为一个
- UNION链接后会对结果进行排序然后去重；UNION ALL只是将结果合并后返回，并不会去重，所以效率高一些

drop/delete/truncate

|              | DROP                                                  | DELETE                                    | TRUNCATE                                                     |
| ------------ | ----------------------------------------------------- | ----------------------------------------- | ------------------------------------------------------------ |
| SQL 语句类型 | DDL                                                   | DML                                       | DDL                                                          |
| 回滚         | 不可回滚                                              | 可回滚                                    | 不可回滚                                                     |
| 删除内容     | 从数据库中 删除表，所有的数据行，索引和权限也会被删除 | 表结构还在，删除表的 全部或者一部分数据行 | 表结构还在，删除表中的 所有数据。（先drop掉表，然后重建表，所以自增长列会重置） |
| 删除速度     | 删除速度最快                                          | 删除速度慢，需要逐行删除                  | 删除速度快                                                   |

因此，在不再需要一张表的时候，采用 DROP；在想删除部分数据行时候，用 DELETE；在保留表而删除所有数据的时候用 TRUNCATE。

# 结构问题

1. InnoDB删除某条记录后，内部会怎么处理？

- 记录头信息里的delete_mask标记位设置为1（表示该记录已删除），同时将记录从记录行链 表中断开，并加入到垃圾链表中，垃圾链表的空间后续可以复用。
