# 1. 基本篇

## 1.1 数据类型

char(M)和varchar(M)的区别

- M指的是字符 而不是 字节
- char是固定长度，占据空间指定时就固定了；varchar是可变长度，存储的内容是存储的值再加上一个长度字段
- char会删除尾部的空格，varchar不会。
- 空间上varchar合适，效率上char合适

varchar 和 text的区别

- text不设置长度， 当不知道属性的最大长度时，适合用text。
- text的65535字节全部用来存储数据，varchar则会占用1－3个字节去存储数据大小。

BLOB 和 TEXT 有什么区别？

- BLOB 是一个二进制对象，可以容纳可变数量的数据。有四种类型的 BLOB：TINYBLOB、BLOB、MEDIUMBLO 和 LONGBLOB。
- TEXT 是一个不区分大小写的 BLOB。四种 TEXT 类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。
- BLOB 保存二进制数据，TEXT 保存字符数据。

TIMESTAMP 与 DATETIME 的区别

- 都是显示年月日时分秒，格式为YYYY-MM-DD HH:MM:SS。
- TIMESTAMP和时区有关，DATATIME和时区无关
- TIMESTAMP以4个字节存储，时间从1970~2038年；DATATIME从1000 ~ 9999年

## 1.2 count

count函数

- 参数不仅可以是字段名，也可以是其他任意表达式
- 作用是：统计符合查询条件的记录有多少条

结论： count(*) = count(1) > count(主键字段) > count(字段)

- count(*) / count(1)：优先选择key_len最小的二级索引进行扫描；如果没有，则使用主键索引进行扫描；作用是统计行数
- count(主键字段)：同样优先选择二级索引扫描每一行，比count(*)多的步骤是会取出记录里面的主键进行判断，是否为null
- count(普通字段)：采用全表扫描，效率最差

MyISAM 和 InnoDB

- MyISAM每张表都有一个字段来记录行数
- 因为InnoDB支持事务，同一时刻的多个查询，因为MVCC，返回的结果是不确定的，所以不能只维护一个row_count变量来记录行数

## 1.3 主键

为什么推荐使用整型自增主键而不是选择 UUID？

- 存储空间：UUID 是字符串，比整型消耗更多的存储空间；
- 比较效率：在 B+Tree 中进行查找时需要跟经过的节点值比较大小，整型数据的比较运算比字符串更快速；
- 插入效率：在插入或删除数据时，整型自增主键会在叶子结点的末尾建立新的叶子节点，不会破坏左侧子树的结构；UUID 主键很容易出现这样的情况，B+Tree  为了维持自身的特性，有可能会进行结构的重构，消耗更多的时间。

- 自增的整型索引在磁盘中会连续存储，在读取一页数据时也是连续；UUID 是随机产生的，读取的上下两行数据存储是分散的，不适合执行`where id > 5 && id <20`的条件查询语句；

# 2. 索引

查找过程

- 首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。

联合索引的优势

- 减少开销，建立一个联合索引相当于建立了多个索引，减少了磁盘空间的开销
- 覆盖索引，可以使用覆盖索引提高效率
- 索引列越多，通过索引筛选出来的数据越精确，越少

# 问题排查

MySQL 数据库 CPU 飙升到 500% 的话他怎么处理？

- 首先用top指令查看是不是mysqld占用造成的
- 使用show processlist查看正在运行的线程，是不是有消耗资源的 SQL 在运行；
- 找到消耗高的SQL，使用explain查看执行计划，是不是没用索引
- 然后kill掉这些线程，进行相应的调整（比如说加索引、改 SQL、改内存参数）之后，再重新跑这些 SQL。

# 命令区别

union和 union all

- 两者都是将两个结果集合并为一个
- UNION链接后会对结果进行排序然后去重；UNION ALL只是将结果合并后返回，并不会去重，所以效率高一些

drop/delete/truncate

|              | DROP                                                  | DELETE                                    | TRUNCATE                                                     |
| ------------ | ----------------------------------------------------- | ----------------------------------------- | ------------------------------------------------------------ |
| SQL 语句类型 | DDL                                                   | DML                                       | DDL                                                          |
| 回滚         | 不可回滚                                              | 可回滚                                    | 不可回滚                                                     |
| 删除内容     | 从数据库中 删除表，所有的数据行，索引和权限也会被删除 | 表结构还在，删除表的 全部或者一部分数据行 | 表结构还在，删除表中的 所有数据。（先drop掉表，然后重建表，所以自增长列会重置） |
| 删除速度     | 删除速度最快                                          | 删除速度慢，需要逐行删除                  | 删除速度快                                                   |

因此，在不再需要一张表的时候，采用 DROP；在想删除部分数据行时候，用 DELETE；在保留表而删除所有数据的时候用 TRUNCATE。

# 结构问题

1. InnoDB删除某条记录后，内部会怎么处理？

- 记录头信息里的delete_mask标记位设置为1（表示该记录已删除），同时将记录从记录行链 表中断开，并加入到垃圾链表中，垃圾链表的空间后续可以复用。
