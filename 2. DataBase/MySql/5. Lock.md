# Classification of locks

1. 按操作分类

- 共享锁(S Lock)：也叫读锁; 持有锁的事务只能读取数据; 读锁之间互相兼容
- 排他锁(X Lock)：也叫写锁; 持有锁的事务可以读写数据; 写锁是独占的

2. 按粒度细分: 表级锁, 页级锁, 行级锁

3. 按使用方式进行划分

- 悲观锁：每次查询数据时都认为别人会修改，很悲观，所以查询时加锁
- 乐观锁：每次查询数据时都认为别人不会修改，很乐观，但是更新时会判断一下在此期间别人有没有去更新这个数据。

4. 从锁的角度来说：

- 表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如 Web 应用

- 行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并查询的应用，如一些在线事务处理系统

| 存储引擎 | 表级锁   | 行级锁   | 页级锁 |
| -------- | -------- | -------- | ------ |
| MyISAM   | 支持     | 不支持   | 不支持 |
| InnoDB   | **支持** | **支持** | 不支持 |
| MEMORY   | 支持     | 不支持   | 不支持 |
| BDB      | 支持     | 不支持   | 支持   |

# Metadata Lock

MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)

MDL 叫元数据锁，主要用来保护 MySQL内部对象的元数据，保证数据读写的正确性，通过 MDL 机制保证 DDL、DML、DQL 操作的并发，**当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁**

* MDL 锁不需要显式使用，在访问一个表的时候会被自动加上，事务中的 MDL 锁，在语句执行开始时申请，在整个事务提交后释放
* MDL 锁是在 Server 中实现，不是 InnoDB 存储引擎层不能直接实现的锁
* MDL 锁还能实现其他粒度级别的锁，比如全局锁、库级别的锁、表空间级别的锁

> 事务中的MDL锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放

> TODO: [online DDL](https://learning.oreilly.com/library/view/high-performance-mysql/9781492080503/ch01.html#:-:text=Beginning%20with%20MySQL%205.6,tools%2C%20in%20Chapter%C2%A06.)

# MyISAM Lock

锁的粒度: 表锁

锁的添加: 读加共享锁, 写加互斥锁

锁的获取: 一次性获取所需要的全部锁(所以不会出现死锁)

锁的优先级: 写锁优先

# InnoDB Lock

## Row Lock

1. 锁的添加: 快照读不加锁, 写加互斥锁

```mysql
-- 当前读 手动加锁
SELECT * FROM table_name WHERE .... FOR SHARE
SELECT * FROM table_name WHERE .... FOR UPDATE [NOWAIT | SKIP LOCKED]
```

2. 锁的种类:

- Record lock：给 index record 上锁(`READ COMMITTED`的默认锁算法)
- Gap Lock：锁定一个范围，但不包含记录本身
- Next-key Lock: index-record lock 加上 index record 前加 gap lock(`REPEATABLE READ`的默认锁算法)

3. 加锁原则: 

- 原则 1: 加锁的基本单位是 next-key lock(前开后闭)
- 原则 2: 查找过程中访问到的对象才会加锁. 唯一索引上的范围查询会访问到不满足条件的第一个值为止
- 优化 1: 等值查询 + 唯一索引, 退回为行锁
- 优化 2: 等值查询 + 向右遍历时的最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁

## Intention Lock

1. 意向锁支持`多粒度锁机制`: 意向锁可以和表锁, 行锁共存

2. 意向锁的粒度: 表锁

- IS: 事务打算对表中的某些行加 S 锁, 加 S 锁之前需要先加 IS
- IX: 事务打算对表中的某些行加 X 锁, 加 X 锁之前需要先加 IX

3. 意向锁的目的:

- 当有事务已经锁住某些行时, 如果有新的事务想要对整个表加锁
- 传统方案为: 遍历表中的每一行看是否兼容
- 意向锁的方案: 查看新的表锁 和 现有的意向锁是否兼容

4. 意向锁 和 表级别的 I 和 X 的兼容性:

|      | `X`  | `IX` | `S`  | `IS` |
| :--- | :--- | :--- | :--- | ---- |
| `X`  | 冲突 | 冲突 | 冲突 | 冲突 |
| `IX` | 冲突 | 兼容 | 冲突 | 兼容 |
| `S`  | 冲突 | 冲突 | 兼容 | 兼容 |
| `IS` | 冲突 | 兼容 | 兼容 | 兼容 |

## 4.4 恢复和复制对于锁的影响(ToDo)

## 4.5 表锁注意事项

1. 在用LOCK TABLES，要将AUTOCOMMIT设为0，否则MYSQL不会给表加锁
2. 事务结束前，不要使用UNLCOK TABLES释放锁，因为其会隐含的提交事务
3. COMMIT或ROLLBACK并不会释放LOCK TABLES，需要手动释放
4. 表锁是SQL SERVER负责的，不是存储引擎负责的

## Deadlock

> MYISAMM是不会发生死锁的，因为MYISAM总是一次获得所需的全部锁，要么全部满足，要么等待，因此不会出现死锁。（因为加的是表锁）

解决策略:

- 等待超时:超时时间通过 innodb_lock_wait_timeout 设置; 但是时间的设置不好控制，因为超时可能不是因为死锁, 所以一般不采取该方式
- 死锁检测: 发现死锁存在环形依赖后, 主动回滚死锁链条中的某一个事务(开启方式: innodb_deadlock_detect = on)

查看死锁

```mysql
-- 确定最后一个死锁产生的原因，其中包括了引发锁的SQL语句，事务已经获得的锁，正在等待什么锁，以及被回滚
show engine innodb status
```

## 4.7 优化锁

InnoDB 存储引擎实现了行级锁定，虽然在锁定机制的实现方面带来了性能损耗可能比表锁会更高，但是在整体并发处理能力方面要远远优于 MyISAM 的表锁，当系统并发量较高的时候，InnoDB 的整体性能远远好于 MyISAM

但是使用不当可能会让InnoDB 的整体性能表现不仅不能比 MyISAM 高，甚至可能会更差

优化建议：

- 尽可能让所有数据检索都能通过索引来完成，避免无索引行锁升级为表锁
- 合理设计索引，尽量缩小锁的范围
- 尽可能减少索引条件及索引范围，避免间隙锁
- 尽量控制事务大小，减少锁定资源量和时间长度
- 尽可使用低级别事务隔离（需要业务层面满足需求）

## 4.8 锁和其他

**锁和外键**

- InnoDB会自动为外键加一个索引，从而避免表锁
- 对于外键值的插入和更新，需要先查父表中的记录，这个select用的是select ... lock in share mode

