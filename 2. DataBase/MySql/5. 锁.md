# 1. 基本介绍

锁是计算机协调多个进程或线程并发访问某一资源的机制（避免争抢）。

## 1.1 Mysql中的锁和Java并发的类比

1. Mysql中的事务相当于Java中的线程

2. 对于InnoDB行锁，某一个数据行 相当于 JAVA中 Synchronized()中的锁对象

3. lock的对象仅在commit或者rollback后进行释放

> Mysql中lock的对象是事务

## 1.2 锁的分类

按操作分类

- 共享锁(S Lock)：也叫读锁。对同一份数据，多个事务读操作可以同时加锁而不互相影响 ，但不能修改数据
- 排他锁(X Lock)：也叫写锁。只能有一个事务获取，其他事务在该事务释放锁之前不能获取对应的资源

按粒度细分

- 表级锁：开销小，加锁快；不会出现死锁；锁定力度大，发生锁冲突概率高，并发度最低
- 行级锁：开销大，加锁慢；会出现死锁；锁定力度小，发生锁冲突概率低，并发度高
- 页级锁：锁的力度、发生冲突的概率和加锁开销介于表锁和行锁之间，会出现死锁，并发性能一般

按使用方式进行划分

- 悲观锁：每次查询数据时都认为别人会修改，很悲观，所以查询时加锁
- 乐观锁：每次查询数据时都认为别人不会修改，很乐观，但是更新时会判断一下在此期间别人有没有去更新这个数据。

从锁的角度来说：

1. 表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如 Web 应用
2. 而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并查询的应用，如一些在线事务处理系统

不同存储引擎支持的锁

| 存储引擎 | 表级锁   | 行级锁   | 页级锁 |
| -------- | -------- | -------- | ------ |
| MyISAM   | 支持     | 不支持   | 不支持 |
| InnoDB   | **支持** | **支持** | 不支持 |
| MEMORY   | 支持     | 不支持   | 不支持 |
| BDB      | 支持     | 不支持   | 支持   |

# 2. 元数据锁

MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)

MDL 叫元数据锁，主要用来保护 MySQL内部对象的元数据，保证数据读写的正确性，通过 MDL 机制保证 DDL、DML、DQL 操作的并发，**当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁**

* MDL 锁不需要显式使用，在访问一个表的时候会被自动加上，事务中的 MDL 锁，在语句执行开始时申请，在整个事务提交后释放
* MDL 锁是在 Server 中实现，不是 InnoDB 存储引擎层不能直接实现的锁
* MDL 锁还能实现其他粒度级别的锁，比如全局锁、库级别的锁、表空间级别的锁

> 事务中的MDL锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放

# 3. MyISAM表锁

## 3.1 锁的模式

**有读锁和写锁两种模式**

- 读操作，不会阻塞其他用户对同一个表的读请求，但是会阻塞对同一个表的写请求。
- 写操作，会阻塞其他用户对同一个表的读写请求。

> 1. 加了读锁就不能进行更新操作
> 2. 加锁以后，该线程只能访问加锁的这些表，不能访问未加锁的表。不管是自动的还是手动上锁
> 3. MYISAM总是一次性获得SQL语句所需要的全部锁，这也是MYISAM不会出现死锁的原因。

## 3.2 如何加锁

**自动上锁过程：**

1. MyISAM 引擎在执行查询语句之前，会**自动**给涉及到的所有表加读锁
2. 在执行增删改之前，会**自动**给涉及的表加写锁。

**手动上锁：**当想要在一定程度上模拟事务操作时.

```mysql
-- 读锁
LOCK TABLE <table_name> READ;

-- 写锁
LOCK TABLE <table_name> WRITE;

-- 将当前会话所有的表进行解锁
UNLOCK TABLES;
```

> 执行过程中使用了别名的话，也需要对别名进行上锁，否则报错。

## 3.3 并发插入

1. MYISAM表的读和写是串行的，但是在一定条件下，MYISAM也支持查询和插入操作的并发进行
2. MYISAM存储引擎有一个系统变量concurrent_insert,专门控制并发插入行为

- 值为0，不允许并发插入
- 值为1，如果表没有空间，允许一个进程读表的同时，另一个进程从表尾插入。默认设置
- 值为2，无论有无空间，都允许在表尾并发插入

## 3.4 锁调度

当一个进程请求写锁，一个进程请求读锁，写进程先获得锁不仅如此，即使读请求先到锁等待队列，写请求后到。写锁也会插到读锁请求之前因为MYISAM认为写更重要。所以MYISAM不太适合有大量更新操作的原因。

# 4. InnoDB锁

## 4.1 行锁

**自动加锁：**

1. 对于 UPDATE、DELETE 和 INSERT 语句，InnoDB 会**自动给涉及数据集加排他锁**（行锁），在 commit 的时候会自动释放；
2. 对于普通 SELECT 语句，不会加任何锁。所以SELECT永远也不会阻塞。  

**对于SELECT手动上锁，从而实现当前读**，普通的SELECT是快照读

```mysql
-- MYSQL5.7
SELECT * FROM table_name WHERE .... LOCK IN SHARE MODE
SELECT * FROM table_name WHERE .... LOCK FOR UPDATE
-- MYSQL8.0
SELECT * FROM table_name WHERE .... FOR SHARE
SELECT * FROM table_name WHERE .... FOR UPDATE [NOWAIT | SKIP LOCKED]
```

---

**InnoDB行锁分为3种情况**

- Record lock：当个行记录上的锁。READ COMMITTED的默认锁算法
- Gap Lock：锁定一个范围，但不包含记录本身
- Next-key Lock：前两种的结合，锁定一个范围，并且锁定记录本身。REPEATABLE READ的默认锁算法

加锁原则：

- 原则 1：加锁的基本单位是 next-key lock。是一个前开后闭区间。
- 原则 2：查找过程中访问到的对象才会加锁。唯一索引上的范围查询会访问到不满足条件的第一个值为止。
- 优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。
- 优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。

## 4.2 意向锁

### 4.2.1 为什么要有意向锁

1. 事务A锁住了表中的**一行**，让这一行只能读，不能写

2. 之后，事务B申请**整个表**的写锁。

3. 如果事务B申请成功，那么理论上它就能修改表中的任意一行，这与A持有的行锁是冲突的。

4. 数据库需要避免这种冲突，就是说要让B的申请被阻塞，直到A释放了行锁。

5. 数据库要怎么判断这个冲突呢？

   step1：判断表是否已被其他事务用表锁锁表

   step2：判断表中的每一行是否已被行锁锁住。

注意step2，这样的判断方法效率实在不高，因为需要遍历整个表。

---

于是就有了意向锁。

在意向锁存在的情况下，事务A必须先申请表的意向共享锁，成功后再申请一行的行锁。

在意向锁存在的情况下，上面的判断可以改成

step1：判断表是否已被其他事务用表锁锁表
step2：发现表上有意向共享锁，说明表中有些行被共享行锁锁住了，因此，事务B申请表的写锁会被阻塞。

注意：申请意向锁的动作是数据库完成的，就是说，事务A申请一行的行锁的时候，数据库会自动先开始申请表的意向锁，不需要我们程序员使用代码来申请。

### 4.2.2 意向锁的种类与兼容性

另外为了允许行锁和表锁共存，实现`多粒度锁机制`，InnoDB还有两种内部使用的意向锁，这两种意向锁都是表锁

- 意向共享锁(IS): 事务有意向对表中的某些行加共享锁,加共享锁之前需要先加意向共享锁
- 意向排他锁(IX): 事务有意向对表中的某些行加排他锁,加排他锁之前需要先加意向排他锁

**表级锁定类型的兼容性总结在下面的矩阵表格中**(注意是X和S表级别)

| 当前锁模式/是否兼容/请求锁模式 | X    | IX   | S    | IS   |
| ------------------------------ | ---- | ---- | ---- | ---- |
| X                              | 否   | 否   | 否   | 否   |
| IX                             | 否   | 兼容 | 否   | 兼容 |
| S                              | 否   | 否   | 兼容 | 兼容 |
| IS                             | 否   | 兼容 | 兼容 | 兼容 |

> **IX，IS是表级锁，不会和行级的X，S锁发生冲突。只会和表级的X，S发生冲突**
>
> 为了用X锁锁表，是不需要申请IX的，用X锁锁行，才需要申请IX

## 4.4 恢复和复制对于锁的影响(ToDo)

## 4.5 表锁注意事项

1. 在用LOCK TABLES，要将AUTOCOMMIT设为0，否则MYSQL不会给表加锁
2. 事务结束前，不要使用UNLCOK TABLES释放锁，因为其会隐含的提交事务
3. COMMIT或ROLLBACK并不会释放LOCK TABLES，需要手动释放
4. 表锁是SQL SERVER负责的，不是存储引擎负责的

## 4.6 死锁

> MYISAMM是不会发生死锁的，因为MYISAM总是一次获得所需的全部锁，要么全部满足，要么等待，因此不会出现死锁。（因为加的是表锁）

解决策略：

- 直接进入等待直到超时，超时时间可以通过参数 innodb_lock_wait_timeout 来设置，但是时间的设置不好控制，超时可能不是因为死锁，而是因为事务处理比较慢，所以一般不采取该方式

- 主动死锁检测，发现死锁后**主动回滚死锁链条中的某一个事务**，让其他事务得以继续执行，将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑

查看死锁

```mysql
-- 确定最后一个死锁产生的原因，其中包括了引发锁的SQL语句，事务已经获得的锁，正在等待什么锁，以及被回滚
show engine innodb status
```



## 4.7 优化锁

InnoDB 存储引擎实现了行级锁定，虽然在锁定机制的实现方面带来了性能损耗可能比表锁会更高，但是在整体并发处理能力方面要远远优于 MyISAM 的表锁，当系统并发量较高的时候，InnoDB 的整体性能远远好于 MyISAM

但是使用不当可能会让InnoDB 的整体性能表现不仅不能比 MyISAM 高，甚至可能会更差

优化建议：

- 尽可能让所有数据检索都能通过索引来完成，避免无索引行锁升级为表锁
- 合理设计索引，尽量缩小锁的范围
- 尽可能减少索引条件及索引范围，避免间隙锁
- 尽量控制事务大小，减少锁定资源量和时间长度
- 尽可使用低级别事务隔离（需要业务层面满足需求）

## 4.8 锁和其他

**锁和外键**

- InnoDB会自动为外键加一个索引，从而避免表锁
- 对于外键值的插入和更新，需要先查父表中的记录，这个select用的是select ... lock in share mode

