# 1. 索引介绍

索引是一个帮助 MySQL 高效获取数据的数据结构

优点：

- 提高数据检索效率，降低IO成本
- 索引自带排序，降低数据排序的成本，降低CPU的效劳

缺点：

- 索引占据空间大，每一个结点都是一个页，一个页占据16KB
- 增删改查效率慢；虽然提高了查询效率，但是对于表的修改操作，存储引擎需要额外的做一些移位，页面分裂，回收等措施来维护好索引

# 2. 索引分类

- BTree 索引：MySQL 使用最频繁的一个索引数据结构，是 InnoDB 和 MyISAM 存储引擎默认的索引类型，底层基于 B+Tree
- Hash 索引：MySQL中 Memory 存储引擎默认支持的索引类型
- R-tree 索引（空间索引）：空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型
- Full-text 索引（全文索引）：快速匹配全部文档的方式

| 索引      | InnoDB           | MyISAM | Memory |
| --------- | ---------------- | ------ | ------ |
| BTREE     | 支持             | 支持   | 支持   |
| HASH      | 不支持           | 不支持 | 支持   |
| R-tree    | 不支持           | 支持   | 不支持 |
| Full-text | 5.6 版本之后支持 | 支持   | 不支持 |

## 2.1 B+Tree 索引

**B+树和B树的区别**

- B树的非叶子结点页存储信息，而B+树所有的数据都放在叶子结点。（页的存储空间有限，如果data较大会导致key较少，容易使得树高增加，增大IO成本）
- 而且B+树的叶子结点通过指针形成了一个双向循环链表
- 且具有两个头指针一个指向根节点，另一个指向关键字最小的叶子节点。（因此B+Tree有两种查找运算：一种是对于主键的范围查找和分页查找，另一种是从根节点开始，进行随机查找。）

<img src="http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/image-20210826231010211.png" alt="image-20210826231010211"  />

**为什么选择B+树**

- InnoDB 存储引擎中页的大小为 16KB，因此一个页可以存储`16KB/（8B+8B）=1K` 个键值。深度为3的B+Tree可以维护 `10^3 * 10^3 * 10^3 = 10` 亿条记录。
- 因此在数据库中，B+Tree 的高度一般都在 2-4 层。MySQL 的 InnoDB 存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要 1~3 次磁盘 I/O 操作。

**MyISAM和InnoDB索引的区别**

- MyISAM的主键索引为`非聚集索引`，叶子结点的存储引擎存放的是数据记录的地址。（因为MyISAM索引和数据是分开存储的）

- InnoDB的主键索引是聚集索引，叶子结点存放的数据域是实际的数据记录。辅助索引的数据域是主键对应主键（不存储具体数据，从而保证数据一致性和节省存储空间）

**聚集索引和非聚集索引**

- 聚集索引访问数据会比非聚集索引快，因为非聚集索引需要回表。
- 插入速度严重依赖于插入顺序，按照主键的顺序（递增）插入是最快的方式，否则将会出现页分裂，严重影响性能，所以对于 InnoDB 表，一般都会定义一个自增的 ID 列为主键
- 更新主键的代价很高，将会导致被更新的行移动，所以对于 InnoDB 表，一般定义主键为不可更新

## 2.2 Hash索引

- 求出hash，再找到对应的索引，然后遍历单链表。能够以O(1)时间进行查找，如果有大量重复键值得情况下，哈希索引的效率会很低，因为存在哈希碰撞问题
- hash适合于等值查询，不支持范围查询，模糊查询(hash的不相关性),排序，最左匹配原则。
- MySQL 目前有 Memory 引擎和 NDB 引擎支持 Hash 索引。
- 自适应hash索引：当某个索引值使用频繁时，会在 B+ 树索引之上再创建一个哈希索引，从而实现快速查找

## 2.3 Full-Text 全文索引

- 用于通过关键词的匹配来进行查询过滤；效率会比LIKE模糊查询高，而且全文搜索可以同时对多个字段做索引，like只能对单一字段搜索
- 有自然语言的全文索引和布尔全文索引。
- 全文索引通常使用倒排索引来实现。

## 2.4 R-Tree 空间索引

空间索引是 MyISAM 的一种特殊索引类型，主要用于地理空间数据类型。

# 3. 索引的语法

创建索引

```mysql
CREATE 	[UNIQUE|FULLTEXT|SPATIAL]  INDEX <index_name>
[USING  index_type]
ON <tbl_name>(<index_col_name>,...)

index_col_name : column_name[(length)][ASC | DESC]
```

查看索引

```mysql
show index  from  <tbl_name>;
```

删除索引

```mysql
DROP  INDEX  <index_name>  ON  <tbl_name>;
```

修改索引

```mysql
1). alter  table  tb_name  add  primary  key(column_list); 
	该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL	
	
2). alter  table  tb_name  add  unique index_name(column_list);
	这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）
	
3). alter  table  tb_name  add  index index_name(column_list);
	添加普通索引， 索引值可以出现多次。
	
4). alter  table  tb_name  add  fulltext  index_name(column_list);
	该语句指定了索引为FULLTEXT， 用于全文索引
```

# 4. 索引设计原则

索引的设计可以遵循一些已有的原则，创建索引的时候请尽量考虑符合这些原则，便于提升索引的使用效率，更高效的使用索引。

- `使用短索引`,从而使得一个结点可以存放更多的索引值，使得树的深度不大，优化IO效率
- `选取查询频次高，数据量大的表建立索引`
- `索引字段，从where子句的条件中选取，如果组合较多，可以利用最左前缀法则，使用联合索引`
- `使用唯一索引`，区分度越高，使用索引的效率越高。
- `索引不是越多越好`。索引也是占据空间的；而且索引是需要维护的，对于增删改操作频繁的话，索引维护的代价很高
- 定义有 外键 的数据列一定要创建索引。

哪些情况不要建立索引：

* 记录太少的表
* 经常增删改的表，频繁更新的字段不适合创建索引
* where 条件里用不到的字段不创建索引
* 定义为 text、image 和 bit 数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。

# 5. 索引维护

B+ 树为了维护索引有序性，在插入新值的时候需要做必要的维护

每个索引中每个块存储在磁盘页中，可能会出现以下两种情况：

* 如果所在的数据页已经满了，这时候需要申请一个新的数据页，然后挪动部分数据过去，这个过程称为**页分裂**
* 当相邻两个页由于删除了数据，利用率很低之后，会将数据页做**页合并**，合并的过程可以认为是分裂过程的逆过程

# 6. 索引优化

## 6.1 覆盖索引

1. 是使用非主键索引才会出现的情况，目的是为了减少回表次数
2. select要查询的字段要么是id要么是索引值，可以直接从辅助索引中取得，无需回表

## 6.2 索引下推

1. 索引下推在**非主键索引**上的优化，目的是为了减少回表次数
2. 在辅助索引的叶子结点，存储引擎会对于数据进行判断，满足下推条件的就根据主键值进行回表查询，不满足的直接丢弃
3. 当使用 EXPLAIN 进行分析时，如果使用了索引条件下推，Extra 会显示 Using index condition

```mysql
# 如果建立了(name, age) 的联合索引，那么这时候就会使用到联合suo'y
mysql> select * from tuser where name like '张%' and age=10 and ismale=1;
```

## 6.3 前缀索引

当要索引的列字符很多时，索引会变大变慢，可以只索引列开始的部分字符串，节约索引空间，提高索引效率

注意：使用前缀索引就系统就忽略覆盖索引对查询性能的优化了

优化原则：**降低重复的索引值**

场景：存储身份证

* 直接创建完整索引，这样可能比较占用空间
* 创建前缀索引，节省空间，但会增加查询扫描次数，并且不能使用覆盖索引
* 倒序存储，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题（前 6 位相同的很多）
* 创建 hash 字段索引，查询性能稳定，有额外的存储和计算消耗，跟第三种方式一样，都不支持范围扫描

## 6.4 不可见索引

1. 不可见索引也就是对于优化器不可见，SQL在执行的时候也不会选择，但是在看表结构的适合仍然能看到
2. 之所以需要不可见索引是为了减小对于表上的索引进行调整时的潜在风险

- 当数据量过大时，如果直接删除一个我们认为不在需要的索引，可能系统存在个别使用这个索引的SQL，那么这些SQL的执行就可能改为全表扫描，对服务器造成巨大冲计
- 有了不可见索引，我们先将他设置为不可见，当过一段时候以后，发现这个索引对于系统性能影响很大时，可以直接恢复索引，而不需要在重建

3. 设置为不可见索引 `show index <> INVISIBLE`

