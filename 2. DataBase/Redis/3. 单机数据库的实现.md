# 1. 数据库

## 1.1 数据库结构

Redis每一个数据库

- 都有一个哈希类型的字典，用来保存该数据库的所有键值对。我们将这个字典称为键空间（key space）
- redisDb结构的**expires**字典保存了数据库中所有键的过期时间，我们称这个字典为**过期字典**

```C++
typedef struct redisDb {
    // 数据库键空间
    dict *dict;                 /* The keyspace for this DB */
    // 过期字典
    dict *expires;              /* Timeout of keys with a timeout set */
    dict *blocking_keys;        /* Keys with clients waiting for data (BLPOP)*/
    dict *ready_keys;           /* Blocked keys that received a PUSH */
    dict *watched_keys;         /* WATCHED keys for MULTI/EXEC CAS */
    int id;                     /* Database ID */
    long long avg_ttl;          /* Average TTL, just for stats */
    unsigned long expires_cursor; /* Cursor of the active expire cycle. */
    list *defrag_later;         /* List of key names to attempt to defrag one by one, gradually. */
} redisDb;
```

## 1.2 删除策略

有以下三种删除策略

- `定时删除`：在设置键的过期时间的同时，创建一个定时器（timer），让定时器在键的过期时间来临时，**立即执行对键的删除操作**
  - 对内存是最友好的，但是使用该方法需要用到定时事件，而时间事件是通过遍历无序链表找到需要执行的事件的，效率不高
- `惰性删除`：放任键过期不管，但是每次从键空间中**获取键时**，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，就返回该键
  - 对CPU最友好，但是会导致很多过期键占据内存。
- `定期删除`：**每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键**。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定
  - 综合的删除策略，能够兼顾CPU与内存

Redis服务器实际使用的是**惰性删除**和**定期删除**两种策略

- 惰性删除策略的实现：
  - 有读写数据库的Redis命令在执行之前都会调用expireIfNeeded函数对输入键进行检查
  - 如果输入键已经过期，那么expireIfNeeded函数将输入键从数据库中删除，否则不做处理，直接执行命令逻辑
- 定期删除策略的实现：
  - Redis的周期性事件每隔100ms执行`serverCron`函数，期间会调用activeExpireCycle函数。
  - 它在规定的时间内，**分多次遍历服务器中的各个数据库，从数据库的expires字典中随机检查一部分键的过期时间，并删除其中的过期键**。而且还会记录当前删除的进度，下一次执行时直接从当前位置开始执行。
  - 从过期字典随机选出20个key，然后删除其中的过期key，如果过期的key超过了1/4,则再次执行；最多不超过25ms

## 1.3 数据淘汰

**no-eviction**：内存不够时，写入操作会报错，读请求和del请求可以执行

**allkeys-lru**：内存不够时，在键空间中，移除最近最少使用的key。

**allkeys-random**：内存不够时，在键空间中，随机移除某个key。

**volatile-lru**：内存不够时，在设置了过期时间的键空间中，移除最近最少使用的key。

**volatile-random**：内存不够时，在设置了过期时间的键空间中，随机移除某个key。

**volatile-ttl**：内存不够时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。

## 1.4 AOF/RDB/复制对过期键的处理

- `生成RDB文件时`:
  - 在执行SAVE或者BGSAVE时，程序会对数据库中的键进行检测，已经过期的不会被保存到新创建的RDB文件中

- `载入RDB文件时`
  - 主服务器在载入RDB时会对键进行检查，如果过期，则不载入到数据库中
  - 从服务器在载入RDB时不论是键否过期都会载入到数据库。（因为进行数据同步时，从数据库会被清空，所以过期键无影响）

- `AOF文件写入时`
  - 当过期键没被删除时，无任何影响；一旦过期键被删除，程序会向AOF文件追加一条DEL命令，来显示记录该键被删除

- `AOF重写时`
  - 会对数据库的键进行检查，已过期的键不会被保存到重写后的AOF文件中

- `复制时`：
  - 主服务器删除一个过期键之后,会显示的向所有从服务器发送DEL命令。从服务器只有接收到主服务器的DEL才会删除过期键
  - 从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将其删除，而是当作未过期来处理；就是说就算过期也可以读到该值

# 2. 持久化

1. `为什么需要持久化`：因为Redis将数据保存在内存中，一旦退出，内存中的数据会丢失，所以要持久化到磁盘中

1. `文件的载入`是在服务器启动时自动进行的

- 如果服务器开启了AOF持久化功能，那么服务器优先使用AOF文件来还原数据库状态；否则使用RDB
- 载入RDB文件的实际工作是由rdbLoad函数来执行的
- 载入AOF文件的话，创建一个无网络连接的伪客户端，从AOF文件中取出一条写命令，伪客户端执行被读出的写命令，重复直到处理完毕。
- 文件载入时期，一直处于阻塞状态，直到载入工作完成。

## 2.1 RDB(Redis DataBase)

### 2.1.1 RDB文件的创建

1. 有两个Redis命令可以用于生成RDB文件，一个是save，另一个是bgsave

- save命令会**阻塞Redis服务器进程**，直到RDB文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求
- bgsave命令使用fork函数会**派生出一个子进程**，然后由子进程负责创建RDB文件，服务器进程（父进程）继续处理命令请求

**2. 在bgsave命令执行期间**，服务器处理save、bgsave、bgrewriteaof三个命令的方式会和平时有所不同

- basave执行期间，客户端发送的save和bgsave会被拒绝，以此防止竞争条件。
- bgwriteaof和bgsave两个命令不能同时执行
  - 如果bgsave命令正在执行，那么客户端发送的bgwriteaof命令会被延迟到bgsave命令执行完毕之后执行
  - 如果bgwriteaof命令正在执行，那么客户端发送的bgsave命令**会被服务器拒绝**

### 2.1.2 自动保存

用户可以在**conf文件**中配置多个保存条件，只要其中任意一个条件被满足，服务器就会执行bgsave命令

```bash
// second：监控时间范围,changes：监控key的变化量
// 默认为 900 1 ， 300 10，60 10000
save <second> <changes>
```

时间事件中的`serverCron()`函数默认每隔100毫秒就会执行一次，它的其中一项工作就是**检查save选项所设置的保存条件是否已经满足**，如果满足的话，就执行bgsave命令

### 2.1.3 RDB文件结构

RDB文件保存的是二进制数据

| REDIS | db_version | databases | EOF  | check_sum |
| ----- | ---------- | --------- | ---- | --------- |

- `REDIS`是魔数
- `db_version`记录了 RDB 文件的版本号
- `EOF`  标志着 RDB 文件正文内容的结束
- `check_sum`  保存着一个校验和.服务器在载入 RDB 文件时， 会将载入数据所计算出的校验和与 `check_sum` 所记录的校验和进行对比， 以此来检查 RDB 文件是否有出错或者损坏的情况出现。
- `databases`: 一个 RDB 文件的 `databases` 部分可以保存任意多个非空数据库。
  - 每个非空数据库在 RDB 文件中都可以保存为 `SELECTDB` 、 `db_number` 、 `key_value_pairs` 三个部分
  - `SELECTDB` : 当读入程序遇到这个值的时候， 它知道接下来要读入的将是一个数据库号码。
  - `db_number` 当程序读入 `db_number` 部分之后， 服务器会调用 SELECT 命令， 进行数据库切换
  - `key_value_pairs` 部分保存了数据库中的所有键值对数据， 如果键值对带有过期时间， 那么过期时间也会和键值对保存在一起。由tpye，key，value三部分组成

### 2.1.4 配置

在redis.config中可以进行如下配置

- dbfilename <dump.rdb>
  - 说明：设置本地数据库文件名，默认值为 dump.rdb
  - 经验：通常设置为dump-端口号.rdb
- dir <./>
  - 说明：设置存储.rdb文件的路径，默认为当前目录
  - 经验：通常设置成存储空间较大的目录中，目录名称data
- rdbcompression <yes>
  - 说明：设置存储至本地数据库时是否压缩数据，默认为 yes，采用 LZF 压缩
  - 经验：通常默认为开启状态，如果设置为no，可以节省 CPU 运行时间，但会使存储的文件变大（巨大）
- rdbchecksum <yes>
  - 说明：设置是否进行RDB文件格式校验，该校验过程在写文件和读文件过程均进行
  - 经验：通常默认为开启状态，如果设置为no，可以节约读写性过程约10%时间消耗，但是存储一定的数据损坏风险
- stop-writes-on-bgsave-error <<yes|no>
  - 后台存储过程中如果出现错误，是否停止保存操作，默认yes
  - bgsave特有

## 2.2 AOF(Append Only File)

1. RDB是通过保存数据库中的键值对来记录数据库状态；AOF通过保存`写命令`来记录数据库状态
2. AOF的主要作用是解决了数据持久化的实时性，目前已经是Redis持久化的**主流**方式
3. 不是WAL而是写后日志

### 2.2.1 AOF持久化的实现

AOF持久化功能的实现可以分为**命令追加**（append）、**文件写入**、**文件同步**（sync）三个步骤

- `命令追加`：服务器执行完一个写命令之后，会以协议格式**将被执行的写命令追加到aof_buf缓冲区的末尾**.

```c
struct redisServer {
    ...
    // 缓冲区，本质上是一个动态字符串
  	sds aof_buf;      /* AOF buffer, written before entering the event loop */
    ...
};
```

- `文件写入`
  - 每结束一个事件循环，将AOF_buffer中的内容写入到Page Cache中
- `文件同步`： appendfsync的三个值代表着三种不同的调用 `fsync`的策略。

| appendfsync 选项的值 | flushAppendOnlyFile函数的行为                   |
| :------------------- | :---------------------------------------------- |
| alway                | 在每个事件循环都写入并同步到AOF文件             |
| everysec             | 在每个事件循环都写入到AOF文件，每隔1s进行同步   |
| no                   | 在每个事件循环都写入到AOF文件，何时同步由OS决定 |

如果用户没有主动为 `appendfsync` 选项设置值， 那么 `appendfsync` 选项的默认值为 `everysec` 

### 2.2.2 AOF重写

**为什么要重写**

- 因为AOF保存的是命令，随着时间推移，占据体积大，影响数据恢复的效率；
- 而且其中有很多冗余，可以合并的命令

**重写的实现**

- 通过读取服务器当前的数据库状态来实现 AOF重写，不需要对原AOF文件进行读取

**AOF后台重写**(bgwriteaof)

- AOF重写通过fork，放到子进程中进行执行，从而不会影响到父进程继续处理命令请求
- 重写时，父进程需要 `执行客户端发送的命令`, `将命令追加到AOF缓冲区`， `将命令追加到AOF重写缓冲区`
- 子进程重写完成后，向父进程发送一个信号，父进程之后
  - 将AOF重写缓冲区的内容写入到新的AOF文件，从而保持AOF文件保存的信息和数据库当前状态一致
  - 使得新的AOF文件覆盖原来的AOF文件

- 在整个AOF后台重写过程中，只有信号处理函数执行时会对服务器进程造成阻塞，在其他时候，AOF后台重写都不会阻塞父进程

**触发时机**

- Redis 会记录上次重写时的 AOF 大小，默认配置是当 AOF 文件大小是上次重写后大小的一倍且文件大于 64M 时触发。

```
auto-aof-rewrite-min-size <size>		#设置重写的基准值，最小文件 64MB，达到这个值开始重写
auto-aof-rewrite-percentage <percent>	#触发AOF文件执行重写的增长率，当前AOF文件大小超过上一次重写的AOF文件大小的百分之多少才会重写，比如文件达到 100% 时开始重写就是两倍时触发
```

## 2.3 对比

AOF 和 RDB 同时开启，系统默认取 AOF 的数据（数据不会存在丢失）

RDB 与 AOF 对比：

- RDB记录的是数据库的键值对二进制信息，AOF记录的是写命令；从而RDB占据空间小，AOF占据空间大
- RDB恢复数据的速度比AOF的快;
- AOF写入速度比RDB快；
- AOF启动优先级高于AOF
- RDB会丢失数据，AOF的数据安全性则根据策略来决定.

综合对比：

- 不能容忍数据丢失的选用AOF;追求数据恢复速度的，选用RDB
- 灾难恢复选用RDB

## 2.4 混合使用

Redis4.0提出了混合使用AOF日志和RDB。

RDB以一定的频率执行，在两次快照之间，使用AOF记录这期间的所有命令。（也就是第一次RDB是做全量更新，之后的话借助AOF来实现增量更新（后续的快照只对修改了的数据进行快照记录））

从而避免了频繁RDB带来的

- 将全量数据写入磁盘的IO成本
- fork产生子进程本身是阻塞的，如果频繁RDB就会频繁阻塞父进程

# 3. 事件

Redis是一个事件驱动程序，服务器需要处理以下两类事件

- 时间事件(time event)：主要是周期性事件，也就是让程序每隔指定时间就执行一次。如每隔100ms执行一次`serverCron`函数

- 文件事件(file event): 服务器与客户端的通信会产生相应的文件事件，而服务器通过IO多路复用来监听这些事件从而完成网络通信

## 3.1 文件事件

- Redis基于`Reactor`模式，使用IO多路复用来同时监听多个套接字，当被监听的套接字产生了accept，read，write，close事件时，文件事件处理器就会调用对应的事件处理器来处理这些事件
- 因此虽然是单线程运行，但是通过IO多路复用技术，既实现了高性能的网络通信模型，又可以很好的和Redis中其他的单线程模块进行对接，保证了设计的简单性

文件事件处理器（file event handler）主要是包含 4 个部分：

- 多个 socket（客户端连接）
- IO 多路复用程序（支持多个客户端连接的关键）
- 文件事件分派器（将 socket 关联到相应的事件处理器）
- 事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）

I/O多路复用程序会将所有产生事件的套接字都放到一个队列中，然后一个一个的向文件事件分派传输socket。当上一个套接字产生的事件被处理完成以后，才会继续传输下一个。

Redis的I/O多路复用程序的所有功能都是通过包装常见的select，epoll，evport和kequeue这些I/O多路复用函数库来实现的。

## 3.2 时间事件

Redis的时间事件有两种

- 定时事件：让一端程序在指定的时间执行一次。目前未使用
- 周期性事件：让程序每隔指定时间就执行一次（每隔100ms调用serverCron函数）

服务器将所有时间事件放在一个无序链表中。每当时间事件执行器运行时，都会遍历整个链表，查找所有已经到达的时间事件，然后调用相应的事件处理器

---

Redis服务器以周期性事件的方式来运行serverCron函数，主要负责管理服务器的资源，并保持服务器自身的良好运转。

- 尝试进行AOF或RDB的持久化操作
- 清理数据库中的过期键值对
- 如果服务器是主服务器，那么对从服务器进行定期同步
- 如果处于集群模式，对集群进行定期同步和连接测试
- 更新服务的各类统计信息，比如时间，内存占用，数据库占用情况

## 3.3 事件的调度和执行

> 1. 阻塞等待最近的时间事件到达
> 2. 执行所有已经产生的文件事件
> 5. 执行已经到达的时间事件

# 4. 客户端

1. Redis服务器使用单线程，IO多路复用模型来与多个客户端进行网络通信
2. 对于每个与服务器进行连接的客户端，服务器都为这些客户端建立了对应的redisClient结构，里面保存了`socket描述符`，`名字`,`使用的数据库`,`执行的指令`,`输入缓冲区`，`输出缓冲区`
3. Redis服务器将这些客户端对应的数据结构保存在一个链表当中。
3. Redis服务器为每个客户端关联一个指令队列 和 响应队列

# 5. 服务器

命令执行过程

1. 客户端将命令转化为对应的协议格式，然后通过socket传输到服务器
2. 当服务器感知到对应客户端产生可读事件以后，将客户端的套接字交给对应的handler处理
3. handler会读取命令，然后放到客户端状态的输入缓冲区中,之后对输入缓冲区的指令进行解析，执行
4. 将结果放到客户端的输出缓冲区，然后产生一个可写事件，使得对应的handler执行命令回复处理
5. 客户端收到并打印命令的回复

初始化服务器

- 初始化服务器状态结构：设置运行id，运行频率，配置文件路径，端口号
- 载入配置选项
- 初始化服务器数据结构：客户端链表，db数组等
- 还原数据库状态，如读取RDB或者AOF文件

# 6. 发布与订阅

Redis的发布与订阅由PUBLISH SUBSCRIBE PSUBSCRIBE等命令组成

```shell
//订阅频道 
SUBSCRIBE <channel> --> subscribe "new.it"
//订阅模式
PSUBCRIBE <pattern> --> psubscibe "news.[ie]t"
//发布
publish <channel> <message>
# 查看订阅信息
PUBSUB CHANNELS [PATTERN]
# 查看频道的订阅者数量
PUBSUB NUMSUB [CHANNEL ....]
# 查看订阅模式的数量
PUBSUB NUMPAT 
```

频道的订阅和退订：

- Redis服务器的`redisServer`结构的`pubsub_channels`字典保存了所有频道的订阅信息，频道为key，value为一个链表，每个结点都是订阅该频道的客户端

模式的订阅和退订

- `redisServer`的`list *pubsub_patterns`保存了所有模式的订阅信息，每一个结点都记录了订阅的客户端和他订阅的模式

发送消息：

- 发送给频道订阅者：通过key在字典里面找到对应的订阅者链表，然后发送给其中的客户端
- 发送给模式订阅者：遍历整个链表找到模式匹配的

缺点

- 宕机重启后，无法收到宕机期间的消息，不具备持久化

# 7. 事务

1. 事务的步骤

- 事务开始：`MULTI`
- 命令入队: 在事务状态下，除了`EXEC,DISCARD,WATCH,MULTI`四个命令，其他命令不立即执行，而是放入命令队列中去
- 事务执行：事务状态下，发送`EXEC`,服务器会遍历事务队列，执行队列中保存的所有命令

2. WATCH：一种乐观锁思想

- `思想`：在EXEC执行之前，WATCH可以监视任意数量的数据库键，并在EXEC执行前，检查是被监视的键是否被修改，如果是，则不执行事务
- `结构`：数据库保留一个`watched_key`字典，其中key为被监视的键，value为一个链表，其中的结点都是监视这个键的客户端
- `监控机制的触发`: 所有对数据库进行修改的命令，都会导致一个函数被调用，这个函数会检查这个键是否被监视，如果是的话，将所有监视这个键的客户端的状态改为 `REDIS_DIRTY_CAS`
- `判断`:exec执行前，服务器会检查对应客户端的状态是否为`REDIS_DIRTY_CAS`,如果是，则拒绝执行

3. 事务的ACID

- `不支持原子性`：`不支持事务回滚`，命令入队阶段错误（语法错误），事务里所有命令不执行；但是执行阶段出现错误，其他事务还是会执行
- `一致性`：事务执行前后，数据库的完整性约束没有被破坏，事务执行的前后都是合法的数据状态。
- `隔离性`：Redis使用单线程，而且不会对事务进行中断，所以Redis的事务是串行执行的
- `持久性`： 持久性由RDB和AOF保证

# 8. 命令

## 8.1 scan

**keys的缺点**

- 没有offset，limit参数，一次性吐出所有满足条件的key
- 不仅不便于查看，而且当满足的key多时，因为Redis是单线程的，导致其他指令都被阻塞住

**scan**

- 复杂度还是O（N），但是他是通过游标分步进行的，不会阻塞线程；
- 遍历顺序：不是从数组的第0位开始遍历，而是采用了高位进位加法，是为了避免扩容和缩容时的重复遍历或遗漏
- scan的返回值就是遍历到了table的哪个索引（cursor）；单次返回的结果是空的不代表遍历结束，而是要看游标是否为0
- 提供limit参数，限制 一次遍历的table中下标的个数
- 返回的结果可能有重复，需要客户端去重

```shell
scan <cursor> match <pattern>  count <count>
```

## 8.2 管道

- 客户端的实现，通过对管道中的指令列表改变他们的顺序来节省网络成本。(多个write只消耗一次网络来回)。管道中的指令越多，效果越好

