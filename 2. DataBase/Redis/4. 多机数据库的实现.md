# 1. 复制

主从复制过程大体可以分为3个阶段

* 建立连接阶段（即准备阶段）：
* 数据同步阶段：**将从服务器的数据库状态更新至主服务器当前所处的数据库状态**
* 命令传播阶段：在**主服务器的数据库状态被修改，导致主从服务器的数据库状态出现不一致时，让主从服务器的数据库重新回到一致状态**
* 心跳检测：

## 1.1 建立连接阶段

> slaveof是一个异步命令，当完成第一步时，从服务器向客户端返回OK

- 根据ip 和 port建立socket连接，并为这个socket关联一个专门用于处理复制工作的文件事件处理器(如接收RDB,写命令)
- 从服务器向主服务器发送PING命令，若返回PONG则进入身份验证，否则端口并重连
- 身份验证：主从都没有设置密码，或者都设置了密码且密码相同，则验证成功；否则验证失败
- 从服务器向主服务器发送端口信息

## 1.2 数据同步阶段

旧版使用`SYNC`命令完成数据同步，从2.8开始使用`PSYNC`完成数据同步.

```shell
psync <主服务器的运行id> <从服务器的offset>
如果是第一次的话 runid 为 ？，offset 为 -1
```

PSYNC命令具有**完整重同步**（full resynchronization）和**部分重同步**（partial resynchronization）两种模式

---

**完整重同步**：主要用于初次复制，断线时间久或者master更换导致的完整重同步或者

- 主服务器收到PSYNC命令以后执行BGSAVE命令生成一个RDB文件，并使用一个缓冲区记录从现在开始执行的所有写命令。
- 将RDB文件发送给从服务器，从服务器接收并载入这个RDB文件；
- 主服务器将记录在**缓冲区里面的所有写命令发送给从服务器**，从服务器执行这些写命令，将自己的数据库状态更新至主服务器数据库当前所处的状态。

> 完整重同步非常消耗资源，因为需要生成RDB,在网络中传输RDB，从服务器载入RDB期间会被阻塞无法处理其他命令

---

**部分重同步 **： 用于处理断线后重复制情况

- 当主服务器进行命令传播时，不仅将写命令发送给从服务器，还会将写命令入队到复制积压缓冲区里面(一个固定长度的队列）
- 主服务器收到PSYNC命令以后，会对比客户端的offset和服务器的offset。
- 如果offset一致，说明主从状态一致，不需要复制
- 如果不一致，且客户端offset之后的数据仍存在于复制积压缓冲区里面，那么进行`部分重同步`，将缓冲区的命令发送给从服务器
- 如果offset偏移量之后的**数据已经不存在于复制积压缓冲区**，那么主服务器将对从服务器执行**完整重同步**操作

## 1.3 命令传播阶段

主服务器会将自己执行的写命令，发送给从服务器执行；从而保证主从服务器的数据一致性

## 1.4 心跳检测

- 命令传播阶段，从服务器会每秒一次的发送心跳检测包，来确保主从服务器的连接正常，其中会携带从服务器当前的复制偏移量
- 作用：
  - 检测主从服务器的连接状态；
  - 检测写命令是否半路上丢失：通过比较主从服务器的复制偏移量，如果不一致，则进行部分重同步

```bash
// 其中replication_offset是**从服务器当前的复制偏移量**
REPLCONE ACK <replication_offset>
```

## 1.5 主从复制作用

- **读写分离**：master 写、slave 读，提高服务器的读写负载能力
- **负载均衡**：基于主从结构，配合读写分离，由 slave 分担 master 负载，并根据需求的变化，改变 slave 的数量，通过多个从节点分担数据读取负载，大大提高 Redis 服务器并发量与数据吞吐量
- **故障恢复**：当 master 出现问题时，由 slave 提供服务，实现快速的故障恢复
- **数据冗余**：实现数据热备份，是持久化之外的一种数据冗余方式
- **高可用基石**：基于主从复制，构建哨兵模式与集群，实现 Redis 的高可用方案

应用场景

* 机器故障：硬盘故障、系统崩溃，造成数据丢失，对业务形成灾难性打击，基本上会放弃使用redis

* 容量瓶颈：内存不足，放弃使用 redis

* 解决方案：为了避免单点 Redis 服务器故障，准备多台服务器，互相连通。将数据复制多个副本保存在不同的服务器上连接在一起，并保证数据是同步的。即使有其中一台服务器宕机，其他服务器依然可以继续提供服务，实现 Redis 高可用，同时实现数据冗余备份

## 1.6 常见问题

- 频繁的全量复制
  - 因为master挂了，重启以后runid变了，导致所有的从服务器都需要全量复制。解决办法就是保存run_id,master重启时载入
  - 缓冲区过小且slave网络不佳，导致slave频繁进行全量复制
- 频繁的网络中断
  - 
- 数据不一致
  - 多个slave获取的数据不同步；说明网络不佳，数据发送有延迟

# 2. Sentinel

Sentinel作用：

- 由一个或多个Sentinel实例（instance）组成的Sentinel系统（system）可以监视任意多个主服务器，以及主服务器的从服务器；
- 并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器
- 还会**继续监视已下线的server1，并在它重新上线时，将它设置为新的主服务器的从服务器**

```sh
# 启动一个sentinel
redis-sentinel /sentinel.conf
#或者
redis-server /sentinel.conf
```

Sentinel本质上是一个运行在特殊模式下的Redis服务器

- 启动服务器的时候，不会载入RDB或者AOF文件
- 使用特定的命令表，很多常用命令不能使用

Sentinel如何发现主服务器

- 根据配置文件，从而监视对应的主服务器，并建立对主服务器的命令连接 和 订阅连接

Sentinel如何发现从服务器

- Sentinel默认每10s就会向主服务器/从服务器发送`INFO`命令，从而获得主服务器的信息以及其对应的从服务器信息；
- 如果有新的从服务器，就会将他加入到监视范围内，并建立对从服务器的命令连接和订阅连接。

Sentinel如何发现其他Sentinel

- Sentinel会以每隔两秒，向所有的主从服务器的\_sentinel\_:hello频道发送PUBLISH命令，其中包括Sentinel本身的信息和服务器的信息
- 其他Sentinel通过分析接收到的频道信息来获知其他Sentinel的存在，并通过发送频道信息来让其他Sentinel知道自己的存在。
- 获取到彼此的存在以后，会创建一个命令连接

## 2.1 检测主观下线

- Sentinel默认每秒一次向所有与他建立了命令连接的实例包括主服务器、从服务器、其他Sentinel在内）发送PING命令，并通过实例返回的PONG命令回复来判断实例是否在线。
- 如果一个实例在down-after-milliseconds毫秒内，连续向Sentinel返回无效回复，那么该Sentinel认为这个实例已经主观下线
- 同时可能多个sentinel监控同一个服务器，他们的down-after-milliseconds可能不同。

## 2.2 检测客观下线

- 当Sentinel将一个master判断为主观下线之后，，**它会向同样监视这一主服务器的其他Sentinel进行询问，看它们是否也认为主服务器已经进入了下线状态**（可以是主观下线或者客观下线）
- 当有足够多的Sentinel认为该服务器已经下线(>= 配置文件设置的quorum参数)，Sentinel就会将此服务器判定为客观下线，并执行故障转移操作。

## 2.3 选举领头Sentinel

当一个master被判定为客观下线时，监视这个服务器的Sentinel会选举一个领头Sentinel，由该Sentinel执行故障转移操作

选举规则如下

- 每个**发现主服务器进入客观下线**的Sentinel都会要求其他Sentinel将自己设置为局部领头Sentinel。
- Sentinel设置局部领头Sentinel的规则是**先到先得**，后到的所有请求都会被拒绝
- 如果有**某个Sentinel被半数以上的Sentinel设置成了局部领头Sentinel**，那么这个Sentinel成为领头Sentinel。
- 如果在给定时限内，没有一个Sentinel被选举为领头Sentinel，那么各个Sentinel将在一段时间之后**再次进行选举，直到选出领头Sentinel为止**。
- 每次进行领头Sentinel**选举之后**，不论选举是否成功，所有Sentinel的配置纪元（configuration epoch）的值都会自增一次。



- 在一个配置纪元里面，所有Sentinel都可以选一个局部领头Sentinel，并且设置了，在这个配置纪元就不能改。
- 源Sentinel在接收到目标Sentinel返回的命令回复之后，会检查配置纪元是否相同，如果相同的话，检查目标Sentinel是否选了字节，如果是那么表示目标Sentinel将源Sentinel设置成了局部领头Sentinel

## 2.4 故障转移

在选举产生出领头Sentinel之后，**领头Sentinel将对已下线的主服务器执行故障转移操作**，该操作包含以下三个步骤

- 在已下线主服务器**属下**的所有从服务器里面，**挑选出一个从服务器，并将其转换为主服务器**
- 让已下线主服务器属下的所有从服务器改为复制新的主服务器（可以通过向从服务器发送**SLAVEOF**命令来实现）
- 当旧的主服务器重新上线时，将它设置为新的主服务器的从服务器（重新上线后给新的master发送slaveof命令）

---

领头Sentinel筛选新主服务器的规则如下

- **删除列表中所有处于下线或者断线状态的从服务器**，这可以保证列表中剩余的从服务器都是正常在线的
- **删除列表中所有最近五秒内没有回复过领头Sentinel的INFO命令的从服务器**，这可以保证列表中剩余的从服务器都是最近成功进行过通信的
- 删除所有与已下线主服务器连接断开超过down-after-milliseconds*10毫秒的从服务器，保证从服务器的数据都是比较新的
- 选取优先级最高的从服务器
- 如果有多个优先级最高的，选择offset最大的
- 如果还有多个，选择运行ID最小的

---

选完以后，向这个从服务器发送SLAVEOF no one命令（断开与主服务器的连接），**将这个从服务器转换为主服务器**

# 3. 集群

集群通过分片(sharding)来进行数据共享，并提供复制和故障转移功能。

## 3.1 节点

1. `什么是节点`：一个节点就是一个运行在集群模式下的Redis 服务器。
2. `如何开启集群模式`：修改配置文件中的`cluster-enabled`选项为yes
3. 节点的数据结构：

- `clusterNode`:保存了节点的当前状态，比如创建时间，名字，配置纪元，ip和port.每个节点都会为自己和集群中的其他节点创建该结构。
- `clusterState`: 每个节点都有此结构，用于保存集群状态，集群的节点名单（k-v结构，k为节点名字，v为clusterNode）等

4. 添加节点到集群中去：`CLUSTER MEET <IP> <Port>`,设发出者为B，收到者为A

- A为B创建一个`clusterNode`结构，然后添加到`clusterState.nodes`中
- 之后A向B发送一个`CLUSTER MEET <IP> <Port>`消息
- 成功的话，B向A返回`PONG`信息，之后A向B返回`PING`信息，这样双方就知道信息传递成功，握手完成
- 之后A将B的信息通过`Gossip`协议传给集群中的其他节点，让他们也和B进行握手。

## 3.2 槽指派

1. `槽(分片)`：Redis Cluster将所有数据分为16384($2^{14}$)个槽,每个节点负责其中一部分槽，槽位的信息存储于每个节点中

2. `集群状态`: 当16384个槽都有节点处理时，处于上线状态(ok);否则处于下线状态(fail)

3. `记录节点的槽指派信息`：

- `ClusterNode`结构的`unsigned char slots[16384/8]`存储了当前节点处理哪些槽。对应索引为1表示该节点处理该槽。节点会将自己的槽指派信息传递给其他节点
- `ClusterState`结构的`clusterNode *slots[16384]`记录了每个槽被哪个节点负责。
- 通过ClusterNode 和 ClusterState使得 `找到槽被哪个节点负责` 和 `节点负责哪些槽`都可以以O(1)实现;

4. `槽指派`: `CLUSTER ADDSLOTS <SLOT> [SLOT ....]`
5. `槽和键的关系`: 通过`ClusterState的slots_to_keys`跳跃表来保存槽和键的关系

- score存储的是槽号，member存储的是数据库的键

## 3.3 在集群中执行命令

客户端向节点发送数据库的键命令

- 节点计算键属于哪个槽。
  - 计算公式：`CRC16(key) & 16383`
  - 命令： `CLUSTER KEYSLOT <key>`
- 如果是自己负责的槽，那么直接执行命令
- 否则向客户端返回一个MOVED错误，客户端根据MOVED错误提供的信息向正确的节点发出请求
  - 返回MOVEED信息：`MOVED <slotIndex> <ip>:<port>`
  - 一个集群的客户端通过会与多个节点创建socket连接，节点转换实际上就算换一个socket发送命令

## 3.4 重新分片

1. 什么是重新分片：

- 将槽指派给另一个节点，并且槽中的键值对也会被移动到目标节点
- 可以在线进行，不需要下线

2. 原理：通过`redis-trib`负责

- 迁移的单位是槽(slot)，当一个槽正在迁移时，这个槽处于中间状态；
- 首先在源节点 和 目标节点 设置好中间状态；使得槽在源节点处于migrating状态，在目标节点处于importingg阶段，表明数据从源节点迁移到目标节点;`CLUSTER SETSLOT <slot> IMPORTING <source_id>` 和 `CLUSTER SETSLOT <slot> MIGRATING <target_id>`
- 通过getkeysinslot命令，一次性获得源节点对应槽位的所有key列表
- ToDo

- 对于获得的每个键名，redis_trib向源节点发送`MIGRATE <target_ip> <target_port> <key_name> 0 <timeout>`进行键的迁移
- 重复执行3，4直到全部键迁移完成
- 向集群中任意一个节点发送`CLUSTER SETSLOT <slot> NODE <target_id>`，将slot指派给目标节点。然后会派送给整个集群

## 3.5 ASK错误

在重新进行分片期间，源节点向目标节点迁移一个槽的时候，可能会出现一部分键值对在源节点中，另一部分在目标节点中。

当发起请求后，如果在源节点没找到，发现请求的槽正在进行迁移，服务器返回一个ASK错误，指引客户端向目标节点发送要执行的指令。

```shell
redis <slot> <ip>:<port>
```

ASK和MOVED的区别

- MOVED代表槽的负责权在另一个节点上，下一次请求会直接发送至MOVED指向的节点
- ASK是两个节点正在重新分片时候的临时措施，ASK导致的转向不会对今后客户端发送关于槽i的命令产生任何影响。

## 3.6 复制与故障转移

1. Redis的节点分为主节点(master)和从节点(slave),主节点用于处理槽，从节点用于复制某个主节点。

2. 当某个主节点下线后，会从他的从节点选取一个作为主节点，接管原来节点所负责的槽；当下线节点重新上线后，成为新的主节点的从节点
3. 设置从节点: `CLUSTER REPLICATE <NODE_ID>`

- 节点在`clusterState.nodes`中找到node_id的clusterNode，然后将自己slaveOf指针指向这个结构
- 标记自己为slave状态，然后调用复制代码从主节点复制数据，相当于发送`slaveof <master_ip> <master_port>`
- 通知集群的其他节点该信息

4. 故障检测

- 集群的每个节点会定期向其他节点发送PING消息，如果没在规定时间收到PONG消息，那么就将对应节点标记位`疑似下线(probable fail,PFAIL)`
- 集群中的各个节点会通过互相发送消息来交换集群中各个节点的状态信息。
- 如果半数以上的主节点都认为某个主节点疑似下线了，那么该节点标记位`已下线(FAIL)`,通过广播形式告诉其他节点，所有收到消息的节点都会将该节点标记`FAIL`

5. 故障转移

- 当一个从节点发现自己的主节点下线以后，会从从节点中选取一个成为新的主节点，执行`slaveof no one`
- 新的主节点将原本指向主节点的槽，重新指派给自己
- 新的主节点向集群广播一条`PONG`,让其他节点知道该节点成为了主节点
- 故障转移完成

6. 选举新的主节点

- 开始一次故障转移，集群配置纪元就会 + 1
- 每个配置纪元，集群中的主节点都有一次投票机会，第一个向主节点要求投票的从节点会获得选票
- 如果一个从节点收到的投票大于 N/2 + 1，那么就成为了新的主节点
- 如果没有成功选出，那么久开始下一次配置纪元，重新进行选举，知道选出新的主节点

> 和Sentinel相似，都是基于Raft算法的领头选举

## 3.7 消息

节点发送的消息有五种

- MEET消息：
- PING消息：集群中的每个节点每秒会从已知节点中随机选出5个，然后给最长没发过PING的节点，发送PING消息
- PONG消息：当收到MEET消息或者PING消息，为了告诉发送者消息已到达，会发送PONG消息。或者故障转移完成也会发送PONG
- FALL消息: 当A判断B已经下线时，会广播一条关于B的Fall消息，所有收到该消息的，都将B设置为FALL
- PUBLISH消息: 当节点收到一条PUBLISH命令，节点会执行这个命令，然后向集群广播一条PUBLISH消息，收到消息的节点都会执行该命令

---

Redis各个节点通过GOSSIP协议来交换各自关于不同节点的状态信息。其中GOSSIP歇息由MEET,PING,PONG三种消息实现。



