Redis为什么那么快

* 所有的数据都是放在内存中的，而内存的访问速度很快。
* 核心是基于非阻塞的 IO 多路复用机制，单线程可以高效处理多个请求。
* 单线程同时也**避免了多线程的上下文频繁切换问题**，预防了多线程可能产生的竞争问题，避免了加锁带来的性能损耗
* 高效的数据结构：数据库使用hash表来进行数据的存取，同时一个对象可能有多种数据类型实现。
* 底层使用 C 语言实现，C 语言实现的程序距离操作系统更近，执行速度相对会更快。

为什么Redis是单线程的

- 因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。
- 好处：**不需要各种锁的性能消耗**

Redis 是单线程的，如何提高多核 CPU 的利用率？

- 使用Redis的管道

---

Redis使用场景

- 缓存:
- 分布式锁
- 排行榜：使用Zset(有序集合)
- 计算器/限速器：
  - 利用 Redis 中原子性的自增操作，我们可以统计类似用户点赞数、用户访问数等。
  - 限制某个用户访问某个 API 的频率，常用的有抢购时，防止用户疯狂点击带来不必要的压力；
- 好友关系：利用集合的一些命令，比如求交集、并集、差集等。
- 消息队列：使用list实现一个队列机制，比如到货通知，邮件发送等
- Session共享：

不适合场景：数据量大，访问频率太低的

---

RESP是Redis的序列化协议

---

因为生成RDB和AOF刷回磁盘涉及到耗时的IO操作，所以持久化的任务一般交给slave

---

如何提高Reids命中率

- 缓存预加载
- 增加缓存存储量
- 提升缓存更新频次

Redis性能优化

- Master 最好不要做任何持久化工作，如 RDB 内存快照和 AOF 日志文件。
- Master 调用 BGREWRITEAOF 重写 AOF 文件，AOF 在重写的时候会占大量的 CPU 和内存资源，导致服务 load 过高，出现短暂服务暂停现象。
