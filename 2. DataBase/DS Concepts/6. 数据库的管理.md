# 1. 事务

- 事务以BEGIN 或者 TRANSACTION开始，COMMIT 或者 ROLLBCAK结束

事务的性质：

- 原子性：对应事务管理子系统
- 一致性：对应事务完整性子系统
- 隔离性：对应事务并发子系统
- 持久性：对应事务恢复管理子系统

# 2. 数据库恢复

1. 数据库恢复的定义：系统把数据库从被破坏，不正确的状态恢复到最近一个正确的状态

2. 数据库恢复的基本策略：冗余(数据重复存储)

3. 数据库恢复的实现方法: 备份 和 日志

4. 故障类型：

- `事务故障`：
  - 非预期事务故障：运算错误，数据错误，死锁
  - 预期事务故障：在事务中可预期出错的地方所加的ROLLBACK语句
- `系统故障`：**硬件、系统软件出错，停电等，事务执行被打断，内存中数据被破坏**
- `介质故障`：**磁头、磁盘控制器或磁盘损坏，盘上数据丢失，病毒破坏等，****DB****遭破坏**

5. 恢复方法：利用备份和日志文件进行恢复

- 事务故障的恢复：反向扫描日志文件，对事务的更新操作执行逆操作
- 系统故障的恢复：
  - 导致数据库不一致的原因：**未完成事务对数据库的更新已写数据库**，已提交事务的更新来停留在缓冲区没有写入数据库
  - 解决方法：撤销故障发生时未完成的事务，重做已完成的事务
  - 具体做法：
  - 正向扫描日志文件，找出在故障前已提交事务，将其事务标识记入重做队列；找出未完成事务，将其事务标识记入撤销队列；
  - 对撤销队列的事务进行 和 `事务故障的恢复` 相同的操作
  - 对重做队列的事务进行 正向扫描日志文件，对每个REDO事务重新执行
- 介质故障恢复：
  - 找到最新的备份进行恢复
  - 然后找到redo日志，重做已经提交的事务

检查点(CheckPoint)机制：

- DBMS定时设置检查点,在检查点才真正将对DB的修改写到磁盘，并在日志文件写入一条检查点记录；主要做如下事情
- 将日志缓冲区中的日志记录写入磁盘
- 将数据库缓冲区中修改过的缓冲块内容写入磁盘
- 写一个检查点记录到磁盘，内容包括：检查点时刻，所有活动事务;每个事务最近日志记录地址
- 磁盘中日志检测点记录的地址写入重新启动文件中

运行记录优先原则：

- 先写日志，在写磁盘
- 直至对一事务的日志登记全部完成，方能够允许该事务完成COMMIT操作
- 这个原则确保了发生故障后能够根据日志对事务进行REDO 和 UNDO操作

# 3. 并发控制

并发控制的三个问题：

- 更新丢失：一个事务的修改被另外一个事务的修改覆盖了。（这个是写-写问题，剩下三个都是读写问题）
- 脏读：一个事务读到了另一个未提交事务修改过的数据
- 不可重复读：在同一事务中，同样的条件，第一次读的数据和第二次读的数据不一样

封锁机制：

- PX协议：事务要更新某一数据，需要对此数据对象加X锁，未获得X锁需要等待；可以解决因多事务同时更新同一数据对象而引起的`更新丢失`问题
- PXC协议：在PX协议加上解除X锁合并到事务结束(COMMIT或者ROLLBCAK);可以解决因事务ROLLBACK而引起的`更新丢失`问题
- PS协议：读数据要先获得S锁，事务在更新数据前必须先将它在该数据对象上的封锁升级为X封锁
- PSC协议：协议可以解决丢失更新、读脏数据和不一致分析问题

活锁和死锁：

- 活锁：出现某个事务永远处于等待状态得不到执行的现象；可以使用FIFO来解决
- 死锁：出现若干事务因循环等待而无法继续执行的现象
- 死锁检测：如果在`事务依赖图`中，沿着箭头方向存在一个循环，那么表示已出现死锁现象

并发事务的可串行化调度：

- 可串行化：如果一个并发调度与某一串行调度具有相同的执行结果
- 两段封锁协议：事务在对数据对象存取之前必须先获得对此数据对象的封锁，事务在解除了一个锁之后不再获得任何锁
- 若所有事务都遵守两段封锁协议，则对这些事务的任何并发调度策略都是可串行化的
- 但若并发事务的一个调度是可串行化的，并不一定所有事务都符合两段封锁协议
- 遵守两段封锁协议的事务也有可能发生死锁

# 4. 完整性

完整性：数据的正确性，有效性，相容性

完整性约束条件：为保证数据的完整性而规定的条件

完整性检查：检查DB中数据是否满足完整性约束条件

完整性规则的组成：

- 触发条件：规定何时执行本规则进行检查
- 约束条件：又称谓词，定义应满足的条件
- 否则子句：规定不满足条件时该作的处理

完整性规则分类：

- 域完整性规则：定义属性取值范围
- 域联系的规则：**定义属性间的联系、影响和约束**
- 关系完整性规则：**定义更新操作对值的影响和限制**

完整性规则：

- 用DDL描述
- 由系统执行检查

完整性约束：有域约束，基本表约束，断言三类

域约束：

- 域完整性规则：定义属性的取值范围; 包括域约束子句，非空值约束，基于属性的检查子句

```mysql
CREATE DOMAIN name [ AS ] data_type
    [ DEFAULT expression ]
    [ constraint [ ... ] ]
# 其中 constraint 是：
[ CONSTRAINT constraint_name ]
{ NOT NULL | NULL | CHECK (expression) }
```

基本表约束：

- 主键约束: **描述实体完整性规则**
- 外键约束：外部码的取值要么是null，要么是参照关系的主键值；如果删除或者修改时有五种方案(no action, cascade, restrict, set null, set default)
- 检查约束

> 级联操作：当把主表中的数据进行删除或更新时，从表中有关联的数据的相应操作，包括 RESTRICT、CASCADE、SET NULL 和 NO ACTION 
>
> * RESTRICT 和 NO ACTION相同， 是指限制在子表有关联记录的情况下， 父表不能更新
>
> * CASCADE 表示父表在更新或者删除时，更新或者删除子表对应的记录
>
> * SET NULL 则表示父表在更新或者删除的时候，子表的对应字段被SET NULL

断言：**如果完整性约束与多个关系有关，或者与聚合操作有关**, 提供断言机制让用户书写完整性约束

- 建立：CREATE ASSERTION 断言名 CHECK（条件）
- 撤销：DROP ASSERTION 断言名
- 检查子句不一定能保证完整性约束彻底实现，而断言能保证不出差错

触发器：

- 组成：事件（如insert，update，delete）；条件；动作
- 形式：FOR EACH ROW(对被事件影响的每一行); FOR EACH STATEMENT(默认，整个事件只执行一次)

```mysql
CREATE TRIGGER 触发器名称
BEFORE|AFTER  INSERT|UPDATE|DELETE
ON 表名
[FOR EACH ROW]  -- 行级触发器
BEGIN
	触发器要执行的功能;
END$

```

数据完整性：

- 域完整性--列级和元组级完整性：元组内的每个属性的值都要在定义的域的范围内
- 实体完整性--表级完整性：要求所有元组都有主键值
- 参照完整性--表级完整性：外键值要么为空值 要么 与相应的参照关系中的某个主键值相同

实现数据完整性的方法：约束，缺省，规则，触发器

# 5. 安全性

安全性级别：只讨论DBS级的安全性问题

权限的种类：读，插入，删除，修改, REFERENCES, USAGE

权限的行为

- 授予(GRANT)：可根据需要把在某对象上的某些权限授予特定的用户
- 转授：**若拥有转授权，则允许把已获得的权限再转授给其他用户**
- 回收(REVOKE)：**也可以撤消已授给某用户的某些权限**

安全性：由视图 和 授权子系统保证

```MYSQL
# GRANT语句
# 权限表，如ALL,CREATE,DROP,INSERT,SELECT等
# 数据库元素：如表名
# 用户名表：如developer@'192.168.0.%'
# WITH GRANT_OPTION：拥有转授权
GRANT <权限> ON <数据库元素>
TO <用户名表> 
[WITH [GRANT_OPTION];

# REVOKE子句
REVOKE <权限表> 
ON <数据库元素>
FROM<用户名表>
```
