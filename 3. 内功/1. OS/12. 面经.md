

# 1. 内存管理篇

1. 常见的内存管理机制

- 连续分配管理：块式管理(将内存分为几个块，每个块只包含一个进程)
- 非连续分配管理：页式，段式，段页式

2. 局部性原理

- 时间局部性：将数据保存到cache
- 空间局部性：预取机制

3. 静态链接和动态链接(ToDo)

# 2. 进程和线程篇

1. 为什么有了进程，还要有线程

- 背景：随着硬件的发展，CPU核心数增加，程序的可并行性增加，进程开始显得笨重.
- 并发度不高：一个进程里面有多种任务逻辑(比如QQ，可以聊天，视频，传文件)，但是进程在同一个时刻只能进行一个任务，不能充分利用CPU，导致并发度不高。
- 进程中的一个任务阻塞住了，整个进程都会被阻塞住， 即使进程中有其他不依赖于等待的资源的任务也不能执行。
- 进程和线程的对比：线程定义，创建角度，通信角度，上下文切换角度

---

2. 进程的终止

- 执行完成，正常退出(自愿，主动的)
- 发生错误
- 被其他进程杀死

3. 守护进程

- 指在后台运行的，没有控制终端与之相连的进程。Linux的大多数服务器就是用守护进程的方式实现的，如web服务器进程http等
- 一个守护进程的父进程是init进程，因为它真正的父进程在fork出子进程后就先于子进程exit退出了

4. 进程的基本操作

- 进程的创建：fork（）
- 进程的加载运行：exec(),如execve
- 进程的终止: exit()
- 进程的回收监控：wait

---

子进程和父进程资源共享关系

- 因为是通过fork，使用了cow技术，会共享整个内存空间，包括栈，堆，数据段，代码段
- 打开文件表
- 进程组ID和会话ID
- **当前工作路径。**

不会继承的

- 进程的进程号PID
- 锁

# 3. 调度篇

进程切换，切换了哪些东西

- 进程切换是在内核态完成的，所以首先涉及到了用户态切换到内核态
- 每个进程都有一个PCB描述进程的运行，所以进程切换必然涉及到PCB
- 每个进程都有自己的虚拟地址空间，所以要进行页表的切换
- 页表进行切换了，TLB也需要进行刷新

线程切换的区别

- 线程共享资源，所以不需要切换页表和刷新TLB

# 4. 通信篇

# 5. 同步篇

线程间的同步方式

- 互斥量(mutex): 一次只能一个线程拥有互斥锁。
- 条件变量：和互斥锁一起使用; 当条件不满足时，释放互斥锁然后加入到等待队列中进行阻塞；当条件满足后，将使用singal通知唤醒阻塞进程
- 信号量
- 自旋锁：如果进线程无法取得锁，进线程不会立刻放弃CPU时间片，而是一直循环尝试获取锁，直到获取为止。
- 读写锁：多个读者可以同时进行读，写者必须互斥；有写者优先，和读者优先
- 屏障:
- 事件(even): 也就是通过wait/notify的条件变量

# 6. 文件篇

1. 被换出的进程保存在哪里

- 保存在外存的交换区中
- 交换区主要追求换入换出的速度，所以一般采用连续分配方式；文件区追去存储空间的利用率，所以采用离散分配

# 7. 设备篇

异常和中断

- 都是会干扰指令的正常执行流程的意外事件
- 中断是指来自处理器之外的中断信号；异常是来自处理机内部的中断信号，通常和当前执行的指令有关
- 异常有 陷入(执行系统调用的)，故障(内核可修复的错误，如缺页异常)，终止(内核无法修复的，如整数除0)三种

- 陷入：如执行系统调用。
- 故障：错误条件引起，可能被内核修复，如缺页故障
- 终止：致命错误引起，内核无法修复，如整数除0

# 8. 其他

操作系统的分类

- 批处理操作系统，分时操作系统，实时操作系统，通用操作系统(兼顾批处理 和 分时)
- 分时：时间片； 实时：追求任务在规定时间内能完成

用户态 和 内核态

- 内核态：可以执行特权指令 和 非特权指令，能访问所有的存储空间
- 用户态：不能执行特权指令，只能访问用户空间
- 出现原因：保护操作系统 和 关键数据不被用户程序破坏

## 8.1 一个程序从开始运行到结束的完整过程

1. 预处理：

- .c文件 -> .i文件
- 主要处理是 宏的展开，处理所有的条件编译指令(#if,#iddef), 删除注释，引入头文件(#include),添加行号等

2. 编译：

- .i文件 -> .s文件；
- 主要处理是： 词法分析，语法分析，语义分析，以及进行优化后生成相应的汇编代码

3. 汇编

- .s 文件 -> .o文件；从汇编文件转化为二进制机器码文件

4. 链接

- 在程序中可能调用了某个库文件中的函数等问题需要链接来解决
- 将有关的目标文件彼此相连接，使得所有的这些目标文件成为一个能够被操作系统装入执行的统一整体。
- 链接分为静态链接和动态链接
  - 静态链接：后缀是.a，主要在编译的时候将库文件里面代码搬迁到可执行的文件中；
  - 动态链接：后缀是.so,主要在执行的时候需要转换到库文件代码执行；

## 8.2 **按下电脑开机键到用户输入密码这个过程都发生了什么？自己设计一下BIOS?**

BIOS是什么

- 基本输入输出系统，为电脑提供最低级，最直接的硬件控制和支持
- BIOS设置程序存放在ROM中

过程

- 开机，计算机通电，访问0xFFFF0地址，也就是访问BIOS；
- 读取BIOS
  - 进行硬件的自检(Power-On-Self-Test,POST),如果有问题会出现蜂鸣；没问题会显示CPU,内存，硬盘等信息
  - BIOS根据启动顺序，找到下一阶段的启动程序存放在哪一个设备中
- 读取MBR(Master boot record，主引导记录)
  - 读取设备的第一个扇区(也就是前512字节)，如果这512个字节的最后两个字节是0x55和0xAA，表明这个设备可以用于启动；否则找到启动顺序中的下一个设备进行上述操作
  - 读取MBR的作用主要是了解硬盘的分区，告诉计算机操作系统存在于硬盘的哪一个位置，也就是找到boot loader。
- 启动Boot Loader(grub): 系统读取grub配置信息，加载kernel
  - 加载操作系统内核进内存中(先载入/boot目录下面的kernel),然后启动(/sbin/init)init进程
  - init进程加载系统的各个模块，直至执行/bin/login程序 

## 8.3 键盘敲入字母时，期间发生了什么

- 键盘控制器将字符保存到设备的数据寄存器之中。
- 然后发送DMA请求，将数据从设备搬运到内存中，搬运完，DMA向CPU发送中断请求
- CPU调用键盘的中断处理程序
- 执行完后恢复被中断进程的上下文

## 8.4 Intel保证原子性

Intel使用 `缓存加锁` 或者 `总线加锁` 的方式来实现多处理器之间的原子操作.

- 首先处理器会自动保证基本的内存操作的原子性。如读写一个字节是原子的。
- `总线加锁`：使用LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。开销大，很多时候只需要对某个内存地址的操作是原子性的，但总线锁锁定了整个内存。

- `缓存加锁`：

# 9. 整合Java

**线程通信的方式**

- **volatile**: volatile具有可见性，可以用于线程之间通信
- wait/notify
- join
- threadlocal

