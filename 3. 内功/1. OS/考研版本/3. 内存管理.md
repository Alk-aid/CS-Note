1. `存储保护`

> 保证各进程在自己的的内存空间运行，不会越界访问

2. `地址转换`

> 操作系统负责将逻辑地址转化为物理地址，实现方式就是`内存装入`的三种方式

3. `内存空间的扩充`

> 利用覆盖技术，交换技术，虚拟存储技术实现,从逻辑上扩充内存

4. `内存空间的分配与回收`

> 由操作系统完成内存空间的分配和管理，对程序员透明

# 1. 存储保护

保证各进程在自己的的内存空间运行，不会越界访问

1. 设置`一对上下限寄存器`，存放进程的上下限。
2. 采用`重定位寄存器`(基址寄存器) 和 `界地址寄存器`（限长寄存器）进行越界检查

> 重定位寄存器中存放的是进程的`起始物理地址`。
>
> 界地址寄存器中存放的是进程的`最大逻辑地址`。

内存管理机构动态地将逻辑地址与界地址寄存器进行比较，若未发生地址越界，则加上重定位寄存器的值后映射成物理地址，再送交内存单元，

![image-20210907091341951](https://gitee.com/aik-aid/picture/raw/master/image-20210907091341951.png)

# 2. 地址转换

## 2.1 源代码 --> 程序

将用户源代码 --> 可在内存中执行的程序(exe)的三个步骤

1. 编译：将源代码转化为若干个目标模块
2. 链接：由链接程序将编译后形成的一组目标模块以及所需的库函数链接在一起，形成一个完整的装入模块
3. 装入：将装入模块装入内存运行

## 2.2 链接

1. 静态链接：`在程序运行之前`，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件（装入模块），之后不再拆开
2. 装入时动态链接：将各目标模块装入内存时，`边装入边链接`的链接方式。
3. 运行时动态链接：`在程序执行中需要该目标模块时`，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享。

## 2.3 装入

### 2.3.1 绝对装入

编译时知道程序将驻留在内存中的位置，所以将指令中的地址改为绝对地址

只使用于单道程序环境。

![image-20210907092941275](https://gitee.com/aik-aid/picture/raw/master/image-20210907092941275.png)

### 2.3.2 可重定位装入(静态重定位)

装入时对地址进行“重定位”，将逻辑地址变换为物理地址（地址变换是在装入时一次完成的）。

所以装入后内存中指令的地址是**绝对地址**

静态重定位的特点：是在一个作业装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存，就不能装入该作业。
作业一旦进入内存后，在运行期间就不能再移动，也不能再申请内存空间。

(适合于早期多道批处理阶段)

![image-20210907092921346](https://gitee.com/aik-aid/picture/raw/master/image-20210907092921346.png)



### 2.3.3 动态运行时装入(动态重定位)：

编译、链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后，**并不会立即把逻辑地址转换为物理地址**，而是把地址转换推迟到程序**真正要执行时才进行**。因此装入内存后所有的地址依然是**逻辑地址**。这种方式需要一个**重定位寄存器**的支持

特点：并且可将程序分配到不连续的存储区中；在程序运行前只需装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存；便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间。

采用动态重定位时**允许程序在内存中发生移动。**

适合于现代操作系统

![image-20210907093008253](https://gitee.com/aik-aid/picture/raw/master/image-20210907093008253.png)

# 3 内存空间的扩充

内存空间的扩充有三种方式

- 覆盖技术
- 交换技术（中级调度就是实现这个的技术）
- 虚拟存储技术

## 3.1 覆盖

覆盖的基本思想如下:由于程序运行时并非任何时候都要访问程序及数据的各个部分(尤其是大程序)，因此可把用户空间分成一个固定区和若干覆盖区。将经常活跃的部分放在固定区，其余部分按调用关系分段。首先将那些即将要访问的段放入覆盖区，其他段放在外存中，在需要调用前，系统再将其调入覆盖区，替换覆盖区中原有的段。

一个固定区：存放最活跃的程序段，固定区中的程序段在运行过程中不会调入调出

若干覆盖区：需要用到时调入内存，用不到时调出内存

缺点：必须由程序员申明覆盖结构，操作系统完成自动覆盖。对程序员不透明。覆盖技术只用于早期的操作系统中，现在已成为历史。



## 3.2 交换

交换(对换)的基本思想是，把处于等待状态(或在CPU调度原则下被剥夺运行权利)的程序从内存移到辅存，把内存空间腾出来，这一过程又称`换出`;把准备好竞争CPU运行的程序从辅存移到内存，这一过程又称`换入`。第2章介绍的`中级调度采用的就是交换技术`。

![image-20210907074705791](https://gitee.com/aik-aid/picture/raw/master/image-20210907074705791.png)

覆盖和交换的区别

> 覆盖是在同一个程序或进程中
>
> 交换是在不同进程(作业)中

## 3.3 虚拟存储技术

### 3.3.1 基本概念

![image-20210908092730476](https://gitee.com/aik-aid/picture/raw/master/image-20210908092730476.png)

### 3.3.2 请求分页管理

![image-20210908092839406](https://gitee.com/aik-aid/picture/raw/master/image-20210908092839406.png)

### 3.3.3 页面置换算法

1. 最佳置换算法(OPT)：每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面，这样可以保证最低的缺页率。

> 按最佳置换的规则，往后寻找，最后一个出现的页号就是要淘汰的页面.
>
> <font color="red">无法实现</font>

2. 先进先出置换算法(FIFO)

> Belady:当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。

3. 最近最久未使用算法(LRU):用`访问字段记录该页面自上次被访问以来所经历的时间t`

> 在手动做题时，若需要淘汰页面，可以逆向检查此时在内存中的几个页面号。<font color="red">在逆向扫描过程中最后一个出现的页号就是要淘汰的页面。</font>

4. 时钟置换算法(CLOCK)

> 为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个循环队列。当某页被访问时，其访问位置为1。当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出；如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描（第二轮扫描中一定会有访问位为0的页面，因此简单的CLOCK算法选择一个淘汰页面最多会经过两轮扫描）

5. 改进型的时钟置换算法

![image-20210908103438610](https://gitee.com/aik-aid/picture/raw/master/image-20210908103438610.png)

![image-20210908101938531](https://gitee.com/aik-aid/picture/raw/master/image-20210908101938531.png)

![image-20210908104812158](https://gitee.com/aik-aid/picture/raw/master/image-20210908104812158.png)

# 4 内存空间的分配与回收

`连续分配`：指为用户进程分配的必须是一个`连续的内存空间`。

`内部碎片`: 分配给某进程的内存区域中，如果有些部分没有用上。

`外部碎片`: 是指内存中的某些空闲分区由于太小而难以利用。

## 4.1 连续分配方式

### 4.1.1 单一连续分配

在单一连续分配方式中，内存被分为`系统区`和`用户区`。

`系统区`通常位于内存的`低地址部分`，用于存放操作系统相关数据；

`用户区`用于存放用户进程相关数据。内存中只能有一道用户程序，用户程序独占整个用户区空间。



`优点`：实现简单；`无外部碎片`；可以采用覆盖技术扩充内存；不一定需要采取内存保护（eg：早期的PC操作系统MS-DOS）。
`缺点`：只能用于单用户、单任务的操作系统中；有`内部碎片`；存储器利用率极低。

### 4.1.2 固定分区分配

#### I 概念

是将`整个用户空间`划分为`若干个固定大小的分区`，在每个分区中`只装入一道作业`，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式。

固定分区分配

- 分区大小相等
- 分区大小不同

`分区大小相等`：缺乏灵活性，但是很适合用于用一台计算机控制多个相同对象的场合（比如：钢铁厂有n个相同的炼钢炉，就可把内存分为n个大小相等的区域存放n个炼钢炉控制程序）

`分区大小不等`：增加了灵活性，可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分（比如：划分多个小分区、适量中等分区、少量大分区）

#### II 记录内存的使用情况的数据结构

系统要用什么样的数据结构记录内存的使用情况？

操作系统需要建立一个数据结构——`分区说明表`(数组或者链表)，来实现各个分区的分配与回收。每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的大小、起始地址、状态（是否已分配）。

当某用户程序要装入内存时，由操作系统内核程序根据用户程序大小检索该表，从中找到一个能满足大小的、未分配的分区，将之分配给该程序，然后修改状态为“已分配”。

`优点`：

​	实现简单，`无外部碎片`。
`缺点`：

​	a.当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采
用覆盖技术来解决，但这又会降低性能；

​	b.会产生`内部碎片`，内存利用率低。

### 4.1.3 动态分区分配

`动态分区分配`又称为`可变分区分配`。这种分配方式`不会预先划分内存分区`，而是在进程装入内存时，根据进程的大小`动态`地建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。

动态分区分配没有`内部碎片`，但是有`外部碎片`。

#### I 记录内存的使用情况的数据结构

1. 空闲分区表：每个空闲分区对应一个表项。表项中包含分区号、分区大小、分区起始地址等信息
2. 空闲分区链：每个分区的起始部分和末尾部分分别设置前向指针和后向指针。起始部分处还可记录分区大小等信息

#### II 怎么进行选择

**综合来看，四种算法中，首次适应算法的效果反而更好**

##### 首次适应算法(First Fit)

> **算法思想**：每次都从低地址开始查找，找到第一个能满足大小的空闲分区。
>
> **如何实现**：空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链（或空闲分区
> 表），找到大小能满足要求的第一个空闲分区。

##### 最佳适应算法(Best Fit)

> **算法思想**：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区，即，优先使用更小的空闲区。
>
> **如何实现**：空闲分区**按容量递增次序链接**。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区
>
> **缺点：**每次都选最小的分区进行分配，会留下越来越多的、很小的、难以利用的内存块。因此这种方法会产生很多的外部碎片。

##### 最坏适应算法(Worst Fit)

> 又称最大适应算法（Largest Fit）
> **算法思想：**为了解决最佳适应算法的问题——即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。
>
> **如何实现：**空闲分区按**容量递减次序链接**。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。
>
> 缺点：每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，但是这种方式会导致较大的连续空闲区被迅速用完。如果之后有“大进程”到达，就没有内存分区可用了

##### 临近适应算法(Next Fit)

> **算法思想：**首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。
>
> **如何实现**：空闲分区以地址递增的顺序排列（可排成一个循环链表）。每次分配内存时从上次查找结束的位置开始查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。

#### III 怎么进行回收

相邻的空闲分区要合并

## 4.2 非连续分配方式

`非连续分配`：为用户进程分配的可以是一些`分散的内存空间`。

### 4.2.1 基本分页存储管理

#### I 什么是分页存储

**会产生内部碎片**

对于内存来说：

	  将内存空间分为一个个大小相等的分区
	  页框:每个分区就是一个“页框”（页框=页帧=内存块=物理块=物理页面）。
	  页框号：每个页框有一个编号，即“页框号”（页框号=页帧号=内存块号=物理块号=物理页号），页框号从0开始。
对于进程来说：

> 页：将进程的逻辑地址空间也分为与页框大小相等的一个个部分
>
> 页号：每个页面也有一个编号，即“页号”，页号也是从0开始。

#### II 页表

页表的目的：为了能知道进程的每个页面在内存中存放的位置

1. 一个进程对应一张页表
2. 进程的每个页面对应一个页表项
3. 每个页表项由“页号”和“块号”组成 (页号可以是隐含的，即页号不占用存储空间)
4. 页表记录`进程页面`和`实际存放的内存块`之间的映射关系
5. 每个页表项的长度是相同的



页表项所占字节数：求出内存块的范围(注意 一般来说页表项所占字节数是2的幂)

![image-20210907162509452](https://gitee.com/aik-aid/picture/raw/master/image-20210907162509452.png)

i号页表项存放的地址：页表始地址 + i*页表项大小

#### III 地址转换

逻辑地址A对应的物理地址= P号页面在内存中的起始地址+页内偏移量W

1. 确定逻辑地址A对应的页号
2. 找到P号页面在内存中的起始地址（需要查页表）
3. 确定逻辑地址A的“页内偏移量

十进制计算

1. 页号=逻辑地址/页面长度
2. 页内偏移量=逻辑地址%页面长度

二进制计算

1. 页内偏移量：根据页的大小2^k,则逻辑地址的后k位就是页内偏移量
2. 页号：其余部分就是页号

#### IV 页表寄存器

通常会在系统中设置一个`页表寄存器`（PTR），存放`页表`在内存中的`起始地址F`和`页表长度M`。进程未执行时，页表的始址和页表长度放在`进程控制块`（PCB）中，当进程被调度时，操作系统内核会把它们放到`页表寄存器`中。

#### V 快表(TLB)

`快表`，又称`联想寄存器`（TLB，translation lookaside buffer ），是一种访问速度比内存快很多的`高速缓存`（`TLB不是内存`！），用来存放最近访问的页表项的副本，可以加速地址变换的速度。与此对应，内存中的页表常称为慢表。

快表的原理：程序的局部性原理

> 没有快表的话，访问一个逻辑地址的访存次数是2次
>
> 有快表的话：
>
> ​	快表命中，只需一次访存
> ​	快表未命中，需要两次访存

#### VI 两级页表

![image-20210907164229357](https://gitee.com/aik-aid/picture/raw/master/image-20210907164229357.png)

### 4.2.2 基本分段存储管理 

![image-20210908085544342](https://gitee.com/aik-aid/picture/raw/master/image-20210908085544342.png)

![image-20210908085859437](https://gitee.com/aik-aid/picture/raw/master/image-20210908085859437.png)

### 4.2.3 段页式存储管理

![image-20210908090850402](https://gitee.com/aik-aid/picture/raw/master/image-20210908090850402.png)
