# 1. 命令篇

> Shell是人与内核之间的翻译官

```shell
ls = list
cd = change directory
cp = copy
rm = remove
mv = move
pwd = print work directory
ps = process status
df = disk free
du = disk usage
mkdir = make directory
rmdir = remove directory
su = substitute user
chown = change owner
chmod = change mode
```

不只是命令，参数也是类似的，可以用英文含义辅助记忆，比如：

```shell
-a = all
-l = list
-f = force
-h = -human-readable
-n = number
-u = user
-z = zip
```

## 1.1 帮助命令

- 需要知道某个命令的简要说明，可以使用whatis；而更详细的介绍，则可用info命令；
- 查看命令在哪个位置，我们需要使用which；
- 而对于命令的具体参数及使用方法，我们需要用到强大的man；

## 1.2 文件命令

**解压缩**

| -c   | -x   | -z       | -j        | -v           | -f         | -c             |
| ---- | ---- | -------- | --------- | ------------ | ---------- | -------------- |
| 压缩 | 解压 | gzip压缩 | bzip2压缩 | 显示操作规程 | 指定文件名 | 切换到指定目录 |

- tar -zcvf test.tar.gz test.log  # 打包后，以 gzip 压缩 
- tar -zxvf test.tar.gz

**查看文本命令**

- cat：查看纯文本文件(内存较少)

- more：查看纯文本文件（内容较多）：

- tail:查看纯文本最后几行或者持续更新 。`tail -n <行号>`

- head:查看开头N行`head -n <行号>`

- less：它并不是一次加载完文件，而是根据需要加载内容.

**统计命令**

- wc:   统计行数（-l，line），字数（-w word），字节数(-c byte counts)
- file: 查看文件类型
- stat: 查看文件的具体存储信息和时间等信息(index-node信息)
- diff <文件1> <文件2>: 用于比较多个文件的差异

**提取命令**

- cut：按列提取文本字符

```bash
cut [参数] 文本
-d<间隔符>
-d<第几列>
-- 举例
cut -d: -f1 /etc/passwd
```

- tr: 替换文本文件中的字符

```bash
tr [原始字符] [目标字符]
cat anaconda-ks.cfg | tr [a-z] [A-Z]
```

- awk： 依次处理文件的每一行，并读取里面的每一个字段。

```shell
awk <参数> <条件 动作> <文件名>
参数：
 -F 指定分隔符

$0: 当前行
$n: 第几个字段
$(NF-n)：倒数第n+1个字段，n=0，就是最后一个字段、
NR：表示当前处理的是第几行
```

## 1.3 系统工作命令

### 1.3.1 普通命令

echo：	用于在终端输出字符串或变量

reboot：  重启

poweroff：关机

wget：	下载网络文件

pidof:    查询某个指定服务进程的PID

kill：    发送信号给某个进程

### 1.3.2 ps

查看系统中的进程状态(report a snapshot of the current processes.)

```bash
-a 显示所有进程(包括其他用户的进程)
-u 用户以及其他详细信息
-x 显示没有控制终端的进程
```
| USER   | PID    | %CPU      | %MEM       | VSZ            | RSS            | TTY      | STAT     | START    | TIME              | COMMAND        |
| ------ | ------ | --------- | ---------- | -------------- | -------------- | -------- | -------- | -------- | ----------------- | -------------- |
| 所有者 | 进程ID | CPU占用率 | 内存占用率 | 虚拟内存使用量 | 固定内存使用量 | 所在中断 | 进程状态 | 启动时间 | 实际使用CPU的时间 | 命令名称与参数 |

Linux进程的状态

- **R (TASK_RUNNING)，可执行状态。**：进程正在运行或者在运行队列中等待

- **S (TASK_INTERRUPTIBLE)，可中断的睡眠状态。**： 因为等待某某事件的发生（比如等待socket连接、等待信号量），而被挂起

- **D (TASK_UNINTERRUPTIBLE)，不可中断的睡眠状态。**：指的并不是CPU不响应外部硬件的中断，而是指进程不响应异步信号。

- **Z(TASK_ZOMBIE),僵死状态**：进程已经终止，但进程描述符以若存在，直到父进程调用wait4()系统函数将该进程释放

- **T(TASK_STOPPED)，停止状态：**进程收到一个SIGSTOP信号后停止运行，当受到一个SIGCONT信号时，又会恢复运行状态。

### 1.3.3 top命令

动态监视进程活动与系统负载等信息

**第1行是任务队列信息，其参数如下：**

- 系统负载，即任务队列的平均长度。 三个数值分别为 1分钟、5分钟、15分钟前到现在的平均值。
- load average: 如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了。

| 当前时间 | 系统运行时间 | 当前登录用户数 | 系统负载                       |
| -------- | ------------ | -------------- | ------------------------------ |
| 05:43:27 | up 4:52      | 2 users        | load average: 0.58, 0.41, 0.30 |

第二行是任务信息，也就是进程信息

| total    | running  | sleeping | stopped  | zombie   |
| -------- | -------- | -------- | -------- | -------- |
| 进程总数 | 运行进程 | 睡眠进程 | 停止进程 | 僵死进程 |

第三行是CPU信息

| us                  | sy                  | ni   | id            | wa                    | hi           | si           | st   |
| ------------------- | ------------------- | ---- | ------------- | --------------------- | ------------ | ------------ | ---- |
| 用户空间占CPU百分比 | 内核空间占CPU百分比 |      | 空闲CPU百分比 | 等待IO的CPU时间百分比 | 硬中断百分比 | 软中断百分比 |      |

第四行为内存相关信息

| total        | used       | free       | buffers            |
| ------------ | ---------- | ---------- | ------------------ |
| 物理内存总量 | 使用的数量 | 空闲的总量 | 用于内核缓存的总量 |

第五行为swap相关信息

| total      | free             | used             | avail Mem                          |
| ---------- | ---------------- | ---------------- | ---------------------------------- |
| 交换区总量 | 使用的交换区总量 | 空闲的交换区总量 | 可用于进程下一次分配的物理内存数量 |

计算可用内存数有一个近似的公式： 
第四行的free + 第四行的buffers + 第五行的cached

| PID  | USER | PR     | NI     | VIRT                   | RES                                | SHR          | S        | %CPU | %MEM | TIME+COMMAND  |
| ---- | ---- | ------ | ------ | ---------------------- | ---------------------------------- | ------------ | -------- | ---- | ---- | ------------- |
|      |      | 优先级 | nice值 | 进程使用的虚拟内存总量 | 进程使用的、未被换出的物理内存大小 | 共享内存大小 | 进程状态 |      |      | 命令名/命令行 |

- 默认按照CPU进行排序
- 按M，根据内存排序
- 按N，根据PID排序
- 按z，突出显示活动进程
- 按i，显示空闲进程
- 按u <name>,查看特定用户的进程
- 按d <频率>，更改top刷新频率
- 按k，可以杀死进程

## 1.4 系统状态检测命令

- ifconfig：获取网卡配置与网络状态等信息
- uname -a：查看当前系统信息
- uptime：查看系统的负载信息
- free：查看当前系统内存的使用量信息
- who: 查看当前登入主机的用户终端信息
- last：查看所有系统的登录信息

## 1.5 搜索命令

### 1.5.1 grep

用于在文本中执行关键词搜索，并显示匹配的结构

```bash
grep [选项] <pattern> [文件]
-n : 显示行号
-v ： 反向选择-仅列出没有关键词的行
-c : 仅显示找到的行数
-i : 忽略大小写
```

### 1.5.2 find

用于按照制定条件来查找文件

```bash
find [查找路径] 寻找模式 查找内容
```

- 寻找条件有： 文件名，大小，修改时间，权限等信息

| 参数              | 作用                                                         |
| ----------------- | ------------------------------------------------------------ |
| -name             | 匹配名字                                                     |
| -perm             | 匹配权限(mode为完全匹配，-mode为包含)                        |
| -user             | 匹配所有者                                                   |
| -group            | 匹配所有组                                                   |
| -size             | 匹配文件的大小(+50KB为查找超过50KB的文件，-50KB为查找小于50KB的文件) |
| -type b/d/c/p/l/f | 匹配文件类型                                                 |

## 1.7 管道符/重定向

### 1.7.1 输入输出重定向

与文件读写操作有关的重定向技术有五种

输入重定向就是把文件导入到命令中

输出重定向是把原本要输出到屏幕的数据写入到文件中

- **标准输入重定向**(STDIN,文件描述符为0)：默认从键盘输入，也可以从其他文件或命令输入。

- **标准输出重定向**(STDOUT,文件描述符为1)：默认输出到屏幕
- **错误输出重定向**(STDERR,文件描述符为2)：默认输出到屏幕

---

输入重定向

| 符号                  | 作用                                          |
| --------------------- | --------------------------------------------- |
| 命令 < 文件           | 将文件作为命令的标准输入                      |
| 命令 << 分界符        | 从标准输入中读入，知道遇到分界符才停止        |
| 命令 < 文件 1 > 文件2 | 将文件1作为命令的标准输入 并叫标准输出到文件2 |

输出重定向

| 符号                                | 作用                                       |
| ----------------------------------- | ------------------------------------------ |
| 命令 > 文件                         | 标准覆盖输出                               |
| 命令 2> 文件                        | 错误覆盖输出                               |
| 命令 >> 文件                        | 标准追加输出                               |
| 命令 2>> 文件                       | 错误追加输出                               |
| 命令 &>> 文件 <br>命令 >> 文件 2>&1 | 标准输出与错误输出共同写入到文件中（追加） |

### 1.7.2 管道命令符

把前一个原本要输出到屏幕的数据当作是后一个命令的标准输入

### 1.7.3 命令行的通配符

```
* 匹配零个或多个字符
? 匹配单个字符
[]
```

### 1.7.4 常用的转义字符

在计算机科学与远程通信中，当转义字符放在字符序列中，它将对它后续的几个字符进行替代并解释。通常，判定某字符是否为转义字符由上下文确定。转义字符即标志着转义序列开始的那个字符。

```
反斜杠(\) : 使反斜杠后面的一个变量变为单纯的字符串
单引号(''): 转移其中所有的变量为单纯的字符串
双引号(""): 保留其中的变量属性
反引号(``)：把其中的命令执行后返回结果
```

### 1.7.5 重要的环境变量

在LINUX系统中，变量名称一般是大写的，我们一般可以直接通过变量名来提起到对应的变量值。

命令在LINUX中的执行步骤

1. 判断用户是否以绝对路径或相对路径的方式输入命令，如果是的话则直接执行
2. 判断是否别名
3. Bash解释器判断输入的是内部命令还是外部命令
4. 系统在多个路径查找用户输入的命令文件，而定义这些路径的变量叫做PATH，作用是告诉BASH解析器待执行的命令可能存放的位置，然后Bash解释器就会去这些路径寻找。（PATH是由多个路径值组成的变量，每个路径值之间用冒号间隔）

# 2. VIM与SHELL

## 2.1 Vim

- 命令模式：控制光标移动，对文本进行复制，粘贴，删除，查找等工作（通过 Esc键 进入）
- 输入模式：正常的文本录入（通过 i 进入）
- 末行模式：保存或者退出文档，以及设置编辑环境（通过 ： 进入）

命令模式常用命令的格式

| motion: | 说明           |
| ------- | -------------- |
| w       | 到下一个单词头 |
| e       | 到本单词尾     |
| b       | 到上一个单词头 |
| 0       | 到行首         |
| $       | 到行尾         |

| 命令           | 作用                                       |
| -------------- | ------------------------------------------ |
| d [n] [motion] | 删除                                       |
| y [n] [motion] | 复制                                       |
| c [n] [motion] | 删除单词并定位到插入模式                   |
|                |                                            |
| [n]x           | 删除光标所在的字符                         |
| [n]r           | 替换                                       |
| [n]p           | 将之前删除或者复制过来的数据黏贴到光标后面 |
|                |                                            |
| [n]u           | 撤销上一步的操作                           |
| [n]Ctrl + R    | 前进                                       |
|                |                                            |
| Ctrl + g       | 指出文件名和当前文件位置                   |
| G              | 到底部                                     |
| gg             | 到头部                                     |
| nG             | 到第n行                                    |
| ctrl + o       | 回到刚刚的位置                             |
|                |                                            |
| n              | 显示搜索命令定位的下一个字符串             |
| N              | 显示搜索命令定位的上一个字符串             |
| %              | 定位在(则会找到对应的)，同理与[],{},       |



末行模式可用的命令

| 命令          | 作用                                 |
| ------------- | ------------------------------------ |
| :w            | 保存                                 |
| :q            | 退出                                 |
| :q!           | 强制退出（放弃对文档的修改内容）     |
| :wq!          | 强制保存退出                         |
| :set nu       | 显示行号                             |
| :set nonu     | 不显示行号                           |
| :命令         | 执行该命令                           |
| :整数         | 跳转到该行                           |
| :s/one/two    | 将当前光标所在行的第一个one替换成two |
| :s/one/two/g  | 将当前光标所在行的所有one替换成two   |
| /%s/one/two/g | 将全文中的所有one替换为two           |
| ?字符串       | 在文本中从下至上搜索该字符串         |
| /字符串       | 在文本中从上至下搜索该字符串         |

> v 字符可视模式
> V 行可视模式
> ctrl+v 块可视模式

## 2.2 shell

### 2.2.1 shell文件框架

```shell
#!/bin/bash
<内容>
```

### 2.2.2 执行shell

> - bash <脚本名称>  [参数]...
> - ./<脚本名称> [参数]...

### 2.2.3 参数

> - $0 :  对应shell脚本的名称
> - $1 :  对应第一个位置上的参数值
> - $# :  对应的是总共有几个参数
> - $* :  对应的是所有位置的参数值
> - $? :  对应的是显示上一次命令的执行返回值

### 2.2.4 条件测试语句

```shell
-- 格式，注意两倍都有一个空格
[ 条件表达式 ]
```

- 文件测试语句
- 逻辑测试语句： && || !
- 整数值比较语句: `-eq`,`-ne`,`-gt`,`-lt`,`-le`,`-ge`
- 字符串比较语句 : = , != , -z(判空)

| 运算符 | 作用                       |
| ------ | -------------------------- |
| -d     | 测试文件是否为目录         |
| -e     | 测试文件是否存在           |
| -f     | 测试是否为一般文件         |
| -r     | 测试当前用户是否有权限读取 |
| -w     | 测试当前用户是否有权写入   |
| -x     | 测试当前用户是否有权限执行 |

```shell
[ -d /etc/fstab ]
[-e /dev/cdrom ] && echo "Exist"
[ 10 -gt 10 ]
[ -z $String]
```

### 2.2.5 流程控制语句

```shell
# if
if [ $? -eq 0]
then
	echo "HOST1 $1"
elif
	echo "HOST2 $2"
else 
	echo "HOST3 $2"
fi
```

```shell
# for
for 变量名 in 取值列表
do 
	命令序列
done
```

```shell
# while 
while 条件测试操作
do 
	命令序列
then 
```

```shell
# case
```

### 2.6 计划任务服务程序

**一次性计划任务：**

- 定义任务： at <时间>
- 查看已经设置好但是没执行的一次性任务：`at -l`
- 删除任务：`atrm 任务序列`

**长期性计划任务：**

- 创建、编辑计划任务的命令为`crontab -e`
- 查看你当前计划任务的命令为`crontab -l`
- 删除某条计划任务的命令为`crontab -r`
- 参数格式 `分、时、日、月、星期 命令`
  - \*为每分/每时/每日/每月/每星期都要执行
  -  a-b 表示从第 a 到第 b 这段时间内要执行，表示范围
  - a,b,c,d   表示a,b,c,d时间要执行， 表示集合
  - \*/n 表示每n执行一次


# 3. 用户身份与文件权限

## 3.1 用户管理

每个用户都有一个唯一的UID，UID = 0 说明是系统的管理员用户；普通用户的UID是从1000开始的。1~999是系统用户，用来负责运行默认程序服务。

- useradd : 添加用户，默认的家目录为/home目录下

```shell
# 添加用户，默认的家目录为/home目录下
useradd [用户名]
useradd -d [指定目录] [新的用户名]
useradd -g [用户组] [用户名]
useradd -m [用户名]

# 删除用户
userdel [用户名]  (这个是保留了家目录的)
userdel -r [用户名] (不保留家目录)

# 修改
passwd [用户名]
# 锁定用户,禁止登录
passwd —l [用户名]
# 解除锁定
passwd -u [用户名]


# 查询用户信息，查看uid，gid，groups
id [用户]

# 切换用户
su - [用户名]

# 查看第一次登陆的用户信息
who am i
```

用户组命令

```sh
# 新增组
groupadd [组名]
# 删除组
groupdel [组名]
```

修改用户信息：可以直接在/etc/passwd文件中修改，也可以使用usermod

```shell
usermod -g [变更所属用户组] [用户名]
usermod -G [变更扩展用户组] [用户名]
usermod -d [指定目录] [新的用户名]
usermod -u [新的UID] [用户名]
```

1. /etc/passwd 文件

> 用户（user）的配置文件，记录用户的各种信息
> 每行的含义：用户名:口令(密码):用户标识号:组标识号:注释性描述:主目录:登录Shell

2. /etc/shadow 文件

> 口令的配置文件
> 每行的含义：登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志

3. /etc/group 文件

> 组(group)的配置文件，记录Linux 包含的组的信息
> 每行含义：组名:口令:组标识号:组内用户列表

## 3.2 文件权限

第0 位确定文件类型普通文件

```
- 普通文件
d 目录文件
l 链接文件
b 块设备文件：  用来访问块设备，比如硬盘
c 字符设备文件：用来访问字符设备，比如键盘
p 管道文件：用于进程间的通信
s 套接字文件：用于网络通信
```

第1-3 位确定`所有者`（该文件的所有者）拥有该文件的权限。---User
第4-6 位确定`所属组`（同用户组的）拥有该文件的权限，---Group
第7-9 位确定`其他用户`拥有该文件的权限---Other

rwx 作用于文件

> - r代表能够读取文件的实际内容
> - w代表能够对编辑，修改，新增，删除文件的实际内容
> - x表示能够运行一个脚本程序

rwx 作用于目录

> - r表示能够读取目录内的文件列表
> - w表示能偶在目录内新增，删除，重命名文件
> - x表示能进入到该目录

修改文件权限

```shell
# 其中默认权限是666
chown            //修改文件所有者
	- chown <newowner> <文件/目录>
	- chown <newowner>:<newgroup> <文件/目录>

chgrp 组名 文件名 //修改文件/目录所在组
	- chgrp <newgroup> 文件/目录

chmod           //修改文件的权限
	- chomod u+x /tmp/file
	- chomod 755 /tmp/file
```

sudo：让某个用户可以执行特定的指令

- root用户在/etc/sudoers 或者 visudo进行配置: `谁可以使用  允许的主机ip = (以谁的身份) 可执行命令的列表`
- 使用：sudo [参数] 命令名称;  验证密码后的5分钟内无需再让用户再次验证密码


| 参数             | 作用                       |
| ---------------- | -------------------------- |
| -l               | 列出当前用户可以执行的命令 |
| -u 用户名或者UID | 以指定的用户身份执行命令   |
| -b               | 再后台执行指定的命令       |

- 作用：限制用户执行的命令 ； 记录用户执行的每一条命令



# 4. 存储结构与磁盘划分

| /etc        | 主要存放配置文件                                     |
| ----------- | ---------------------------------------------------- |
| /var        | 主要放日志文件                                       |
| /tmp        | 主要存放临时文件                                     |
| /opt        | 主要存放第三方软件                                   |
| /dev        | 用于存放设备文件,如鼠标，键盘等                      |
| /lost+found | 文件系统发生错误时，将一些丢失的文件片段放在这里     |
|             |                                                      |
| /root       | 超级用户家目录                                       |
| /home       | 用户家目录                                           |
| /boot       | 开机所需要的文件                                     |
| /lib        | 系统运行相关的库函数                                 |
| /sbin       | 只有root用户才能使用的二进制可执行文件               |
| /bin        | 存放二进制可执行文件，常用命令一般在此               |
| /proc       | 虚拟文件系统，例如系统内核，进程，外部设备，网络状态 |
| /usr        | unix system resources,存放系统资源                   |
| /usr/local  | 用户自行安装的软件                                   |

挂载：当用户需要使用硬盘设备或者分区种的数据时，需要先将其与一个已经存在的目录文件进行关联，而这个关联动作就是挂载

mount：用于挂载文件系统

```shell
mount [文件系统] [挂载目录]
```

unmount：用于撤销已经挂载的文件

```shell
unmount [挂载点/涉笔文件]
```

交换分区（swap）：通过在硬盘中预先划分一定的空间，然后把内存中暂时用不到的数据临时存到硬盘中，以便腾出物理内存空间让更活跃程序使用。

# 5. 分析日志

- 分析PV(Page View): 用户访问一次就是一次PV

```shell
wc -l access.log
```

- PV分组：可以根据时间分组，

```sh
# 输出第四列的数据
awk '{print $4}' access.log
# 截取年月日
awk 'print substr($4,2,11)'
# 排序,然后分组，uniq去重的原理是比较相邻的行，然后除去第二行和该行的后续副本
awk 'print substr($4,2,11)' access.log | sort | uniq -c 
```

- UV(Uniq Vistor):访问人数，一天一个用户只算一个

```shell
awk '{print $1 }' access.log | sort | uniq | wc -l
```

- UV分组

```shell
awk '{print substr($4,2,11) " " $1}' access.log | sort
```

VV**Visit View）**

