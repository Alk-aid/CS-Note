# 1. 自动装配

## 1.1 依赖管理

1. springboot使用父项目作为依赖管理，父项目中定义了了各种技术的版本信息，使得我们无需关注版本号

2. springboot简化了依赖导入，开发导入starter场景启动器，自动为我们组合了一套最优搭配的技术版本。所有的starter最底层都依赖spring-boot-starter

## 1.2  什么是自动装配

1. 自动配置好了tomcat：包括引入tomcat依赖，配置tomcat
2. 自动配置好了springmvc：包括引入依赖和配置好了springmvc的常用功能
3. 自动配置好了Web常用功能：如字符编码问题
4. 默认的包扫描：主程序所在包及其下面的所有子包里面的组件都会被默认扫描进来
   1. 想要改变扫描路径，@SpringBootApplication(scanBasePackages="com.atguigu")

5. 各种配置拥有默认值
   1. 默认配置最终都是映射到某个类上，如：MultipartProperties
   2. 配置文件的值最终会绑定每个类上，这个类会在容器中创建对象

6. 按需加载所有自动配置项：引入了哪些场景这个场景的自动配置才会开启

> SpringBoot所有的自动配置功能都在 spring-boot-autoconfigure 包里面

## 1.3 底层注解

### 1.3.1 SpringBoot

@SpringBootApplication：启动注解，实现 SpringBoot 的自动部署

* 参数 scanBasePackages：可以指定扫描范围
* 默认扫描当前引导类所在包及其子包

假如所在包为 com.example.springbootenable，扫描配置包 com.example.config 的信息，三种解决办法：

1. 使用 @ComponentScan 扫描 com.example.config 包
2. 使用 @Import 注解，加载类，这些类都会被 Spring 创建并放入 ioc 容器，默认组件的名字就是**全类名**
3. 对 @Import 注解进行封装

```java
//1.@ComponentScan("com.example.config")
//2.@Import(UserConfig.class)
@EnableUser
@SpringBootApplication
public class SpringbootEnableApplication {

    public static void main(String[] args) {
        ConfigurableApplicationContext context = SpringApplication.run(SpringbootEnableApplication.class, args);
    	//获取Bean
        Object user = context.getBean("user");
        System.out.println(user);

	}
}
```

UserConfig：

```java
@Configuration
public class UserConfig {
    @Bean
    public User user() {
        return new User();
    }
}
```

EnableUser 注解类：

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Import(UserConfig.class)//@Import注解实现Bean的动态加载
public @interface EnableUser {
}
```

### 1.3.2 Configuration

@Configuration：设置当前类为 SpringBoot 的配置类

* proxyBeanMethods = true：Full 全模式，每个 @Bean 方法被调用多少次返回的组件都是单实例的，默认值，类组件之间**有依赖关系**，方法会被调用得到之前单实例组件
* proxyBeanMethods = false：Lite 轻量级模式，每个 @Bean 方法被调用多少次返回的组件都是新创建的，类组件之间**无依赖关系**用 Lite 模式加速容器启动过程

```java
@Configuration(proxyBeanMethods = true)
public class MyConfig {
    @Bean //给容器中添加组件。以方法名作为组件的 id。返回类型就是组件类型。返回的值，就是组件在容器中的实例
    public User user(){
        User user = new User("zhangsan", 18);
        return user;
    }
}
```

原理就是

> proxyBeanMethods=true，注册进IOC容器中的配置类是代理类，其中被@Bean注解的方法，会被增强。调用时会检查返回的对象是否在容器中，相当于单例模式

### 1.3.3 Condition

#### I 条件注解

Condition 是 Spring4.0 后引入的条件化配置接口，通过实现 Condition 接口可以完成有条件的加载相应的 Bean

注解：@Conditional

作用：条件装配，满足 Conditional 指定的条件则进行组件注入，加上方法或者类上，作用范围不同

使用：@Conditional 配合 Condition 的实现类（ClassCondition）进行使用.**也就是@Conditional括号里面的参数是某个condtion.class**



ConditionContext 类API：

| 方法                                                | 说明                          |
| --------------------------------------------------- | ----------------------------- |
| ConfigurableListableBeanFactory  getBeanFactory（） | 获取到 ioc 使用的 beanfactory |
| ClassLoader getClassLoader()                        | 获取类加载器                  |
| Environment getEnvironment()                        | 获取当前环境信息              |
| BeanDefinitionRegistry getRegistry()                | 获取到bean定义的注册类        |

* ClassCondition

  ```java
  public class ClassCondition implements Condition {
      /**
       * context 上下文对象。用于获取环境，IOC容器，ClassLoader对象
       * metadata 注解元对象。 可以用于获取注解定义的属性值
       */
      @Override
      public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
        
          //1.需求： 导入Jedis坐标后创建Bean
          //思路：判断redis.clients.jedis.Jedis.class文件是否存在
          boolean flag = true;
          try {
              Class<?> cls = Class.forName("redis.clients.jedis.Jedis");
          } catch (ClassNotFoundException e) {
              flag = false;
          }
          return flag;
      }
  }
  ```

* UserConfig

  ```java
  @Configuration
  public class UserConfig {
      @Bean
      @Conditional(ClassCondition.class)
      public User user(){
          return new User();
      }
  }
  ```

* 启动类：

  ```java
  @SpringBootApplication
  public class SpringbootConditionApplication {
      public static void main(String[] args) {
          //启动SpringBoot应用，返回Spring的IOC容器
          ConfigurableApplicationContext context = SpringApplication.run(SpringbootConditionApplication.class, args);
  
          Object user = context.getBean("user");
          System.out.println(user);
      }
  }
  ```

#### II 自定义注解

将类的判断定义为动态的，判断哪个字节码文件存在可以动态指定

* 自定义条件注解类

  ```java
  @Target({ElementType.TYPE, ElementType.METHOD})
  @Retention(RetentionPolicy.RUNTIME)
  @Documented
  @Conditional(ClassCondition.class)
  public @interface ConditionOnClass {
      String[] value();
  }
  ```

* ClassCondition

  ```java
  public class ClassCondition implements Condition {
      @Override
      public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata metadata) {
  
          //需求：通过注解属性值value指定坐标后创建bean
          Map<String, Object> map = metadata.getAnnotationAttributes
              					(ConditionOnClass.class.getName());
          //map = {value={属性值}}
          //获取所有的
          String[] value = (String[]) map.get("value");
  
          boolean flag = true;
          try {
              for (String className : value) {
                  Class<?> cls = Class.forName(className);
              }
          } catch (Exception e) {
              flag = false;
          }
          return flag;
      }
  }
  ```

* UserConfig

  ```java
  @Configuration
  public class UserConfig {
      @Bean
      @ConditionOnClass("com.alibaba.fastjson.JSON")//JSON加载了才注册 User 到容器
      public User user(){
          return new User();
      }
  }
  ```

* 测试 User 对象的创建

#### III 常用注解

SpringBoot 提供的常用条件注解：

@ConditionalOnProperty：判断**配置文件**中是否有对应属性和值才初始化 Bean

```java
@Configuration
public class UserConfig {
    @Bean
    @ConditionalOnProperty(name = "it", havingValue = "seazean")
    public User user() {
        return new User();
    }
}
```

```properties
it=seazean
```

@ConditionalOnClass：判断环境中是否有对应类文件才初始化 Bean

@ConditionalOnMissingClass：判断环境中是否有对应类文件才初始化 Bean

@ConditionalOnMissingBean：判断环境中没有对应Bean才初始化 Bean

### 1.3.4 ImportRes

使用 bean.xml 文件生成配置 bean，如果需要继续复用 bean.xml，@ImportResource 导入配置文件即可

```java
@ImportResource("classpath:beans.xml")
public class MyConfig {
	//...
}
```

```xml
<beans ...>
    <bean id="haha" class="com.lun.boot.bean.User">
        <property name="name" value="zhangsan"></property>
        <property name="age" value="18"></property>
    </bean>

    <bean id="hehe" class="com.lun.boot.bean.Pet">
        <property name="name" value="tomcat"></property>
    </bean>
</beans>
```

### 1.3.5 Properties

@ConfigurationProperties：读取到 properties 文件中的内容，并且封装到 JavaBean 中

配置文件：

```properties
mycar.brand=BYD
mycar.price=100000
```

JavaBean 类：

```java
@Component	//导入到容器内
@ConfigurationProperties(prefix = "mycar")//代表配置文件的前缀
public class Car {
    private String brand;
    private Integer price;
}
```

## 1.4 源码解析

### 1.4.1 启动流程

应用启动：

```java
@SpringBootApplication
public class BootApplication {
    public static void main(String[] args) {
        // 启动代码
        SpringApplication.run(BootApplication.class, args);
    }
}
```

SpringApplication 构造方法：

* `this.resourceLoader = resourceLoader`：资源加载器，初始为 null
* `this.webApplicationType = WebApplicationType.deduceFromClasspath()`：判断当前应用的类型，是响应式还是 Web 类
* `this.bootstrapRegistryInitializers = getBootstrapRegistryInitializersFromSpringFactories()`：**获取引导器**
  * 去 **`META-INF/spring.factories`** 文件中找 org.springframework.boot.Bootstrapper
  * 寻找的顺序：classpath → spring-beans → boot-devtools → springboot → boot-autoconfigure
* `setInitializers(getSpringFactoriesInstances(ApplicationContextInitializer.class))`：**获取初始化器**
  * 去 `META-INF/spring.factories` 文件中找 org.springframework.context.ApplicationContextInitializer
* `setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class))`：**获取监听器**
  * 去 `META-INF/spring.factories` 文件中找 org.springframework.context.ApplicationListener

* `this.mainApplicationClass = deduceMainApplicationClass()`：获取出 main 程序类

SpringApplication#run(String... args)：创建 IOC 容器并实现了自动装配

* `StopWatch stopWatch = new StopWatch()`：停止监听器，**监控整个应用的启停**

* `stopWatch.start()`：记录应用的启动时间

* `bootstrapContext = createBootstrapContext()`：**创建引导上下文环境**

  * `bootstrapContext = new DefaultBootstrapContext()`：创建默认的引导类环境
  * `this.bootstrapRegistryInitializers.forEach()`：遍历所有的引导器调用 initialize 方法完成初始化设置

* `configureHeadlessProperty()`：让当前应用进入 headless 模式

* `listeners = getRunListeners(args)`：**获取所有 RunListener（运行监听器）**

  * 去 `META-INF/spring.factories` 文件中找 org.springframework.boot.SpringApplicationRunListener

* `listeners.starting(bootstrapContext, this.mainApplicationClass)`：遍历所有的运行监听器调用 starting 方法

* `applicationArguments = new DefaultApplicationArguments(args)`：获取所有的命令行参数

* `environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments)`：**准备环境**

  * `environment = getOrCreateEnvironment()`：返回或创建基础环境信息对象
    * `switch (this.webApplicationType)`：根据当前应用的类型创建环境
      * `case SERVLET`：Web 应用环境对应 ApplicationServletEnvironment
      * `case REACTIVE`：响应式编程对应 ApplicationReactiveWebEnvironment
      * `default`：默认为 Spring 环境 ApplicationEnvironment
  * `configureEnvironment(environment, applicationArguments.getSourceArgs())`：读取所有配置源的属性值配置环境
  * `ConfigurationPropertySources.attach(environment)`：属性值绑定环境信息
    * `sources.addFirst(ATTACHED_PROPERTY_SOURCE_NAME,..)`：把 configurationProperties 放入环境的属性信息头部

  * `listeners.environmentPrepared(bootstrapContext, environment)`：运行监听器调用 environmentPrepared()，EventPublishingRunListener 发布事件通知所有的监听器当前环境准备完成

  * `DefaultPropertiesPropertySource.moveToEnd(environment)`：移动 defaultProperties 属性源到环境中的最后一个源

  * `bindToSpringApplication(environment)`：与容器绑定当前环境

  * `ConfigurationPropertySources.attach(environment)`：重新将属性值绑定环境信息

    * `sources.remove(ATTACHED_PROPERTY_SOURCE_NAME)`：从环境信息中移除 configurationProperties 

    * `sources.addFirst(ATTACHED_PROPERTY_SOURCE_NAME,..)`：把 configurationProperties 重新放入环境信息

* `configureIgnoreBeanInfo(environment)`：**配置忽略的 bean**

* `printedBanner = printBanner(environment)`：打印 SpringBoot 标志

* `context = createApplicationContext()`：**创建 IOC 容器**

  `switch (this.webApplicationType)`：根据当前应用的类型创建 IOC 容器

  * `case SERVLET`：Web 应用环境对应 AnnotationConfigServletWebServerApplicationContext
  * `case REACTIVE`：响应式编程对应 AnnotationConfigReactiveWebServerApplicationContext
  * `default`：默认为 Spring 环境 AnnotationConfigApplicationContext

* `context.setApplicationStartup(this.applicationStartup)`：设置一个启动器

* `prepareContext()`：配置 IOC 容器的基本信息

  * `postProcessApplicationContext(context)`：后置处理流程

  * `applyInitializers(context)`：获取所有的**初始化器调用 initialize() 方法**进行初始化
  * `listeners.contextPrepared(context)`：所有的运行监听器调用 environmentPrepared() 方法，EventPublishingRunListener 发布事件通知 IOC 容器准备完成
  * `listeners.contextLoaded(context)`：所有的运行监听器调用 contextLoaded() 方法，通知 IOC 加载完成

* `refreshContext(context)`：**刷新 IOC 容器**

  * Spring 的容器启动流程
  * `invokeBeanFactoryPostProcessors(beanFactory)`：**实现了自动装配**
  * `onRefresh()`：**创建 WebServer** 使用该接口

* `afterRefresh(context, applicationArguments)`：留给用户自定义容器刷新完成后的处理逻辑

* `stopWatch.stop()`：记录应用启动完成的时间

* `callRunners(context, applicationArguments)`：调用所有 runners

* `listeners.started(context)`：所有的运行监听器调用 started() 方法

* `listeners.running(context)`：所有的运行监听器调用 running() 方法

  * 获取容器中的 ApplicationRunner、CommandLineRunner
  * `AnnotationAwareOrderComparator.sort(runners)`：合并所有 runner 并且按照 @Order 进行排序

  * `callRunner()`：遍历所有的 runner，调用 run 方法

* `handleRunFailure(context, ex, listeners)`：**处理异常**，出现异常进入该逻辑

  * `handleExitCode(context, exception)`：处理错误代码
  * `listeners.failed(context, exception)`：运行监听器调用 failed() 方法
  * `reportFailure(getExceptionReporters(context), exception)`：通知异常

### 1.4.2 注解分析

SpringBoot 定义了一套接口规范，这套规范规定 SpringBoot 在启动时会扫描外部引用 jar 包中的 `META-INF/spring.factories` 文件，将文件中配置的类型信息加载到 Spring 容器，并执行类中定义的各种操作，对于外部的 jar 包，直接引入一个 starter 即可

@SpringBootApplication 注解是 `@SpringBootConfiguration`、`@EnableAutoConfiguration`、`@ComponentScan` 注解的集合。

#### I @SpringBootApplication 注解

```java
@Inherited
@SpringBootConfiguration	//代表 @SpringBootApplication 拥有了该注解的功能
@EnableAutoConfiguration	//有了自动配置功能
@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),
		@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })
// 扫描被 @Component (@Service,@Controller)注解的 bean，容器中将排除TypeExcludeFilter 和 AutoConfigurationExcludeFilter
public @interface SpringBootApplication { }
```

#### II @SpringBootConfiguration 注解：

```java
@Configuration	// 代表是配置类
@Indexed
public @interface SpringBootConfiguration {
	@AliasFor(annotation = Configuration.class)
	boolean proxyBeanMethods() default true;
}
```

@AliasFor 注解：表示别名，可以注解到自定义注解的两个属性上表示这两个互为别名，两个属性其实是同一个含义相互替代

#### III @ComponentScan 注解

默认扫描当前类所在包及其子级包下的所有文件

#### IV @EnableAutoConfiguration 注解

启用 SpringBoot 的自动配置机制.

```java
@AutoConfigurationPackage	
@Import(AutoConfigurationImportSelector.class)
public @interface EnableAutoConfiguration { 
	String ENABLED_OVERRIDE_PROPERTY = "spring.boot.enableautoconfiguration";
    Class<?>[] exclude() default {}; 
    String[] excludeName() default {};
}
```

---

@AutoConfigurationPackage：

**将添加该注解的类所在的 package 作为自动配置 package 进行管理**，把启动类所在的包设置一次，为了给各种自动配置的第三方库扫描用，比如带 @Mapper 注解的类，Spring 自身是不能识别的，但自动配置的 Mybatis 需要扫描用到，而 ComponentScan 只是用来扫描注解类，并没有提供接口给三方使用

```java
@Import(AutoConfigurationPackages.Registrar.class)	// 利用 Registrar 给容器中导入组件
public @interface AutoConfigurationPackage { 
	String[] basePackages() default {};	//自动配置包，指定了配置类的包
    Class<?>[] basePackageClasses() default {};
}
```

`register(registry, new PackageImports(metadata).getPackageNames().toArray(new String[0]))`：注册 BD

* `new PackageImports(metadata).getPackageNames()`：获取添加当前注解的类的所在包
* `registry.registerBeanDefinition(BEAN, new BasePackagesBeanDefinition(packageNames))`：存放到容器中
  * `new BasePackagesBeanDefinition(packageNames)`：把当前主类所在的包名封装到该对象中

---

@Import(AutoConfigurationImportSelector.class)：**自动装配的核心类**

容器刷新时执行：**invokeBeanFactoryPostProcessors()** → invokeBeanDefinitionRegistryPostProcessors() → postProcessBeanDefinitionRegistry() → processConfigBeanDefinitions() → parse() → process() → processGroupImports() → getImports() → process() → **AutoConfigurationImportSelector#getAutoConfigurationEntry()**

```java
protected AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) {
    if (!isEnabled(annotationMetadata)) {
        return EMPTY_ENTRY;
    }
    // 获取注解属性，@SpringBootApplication 注解的 exclude 属性和 excludeName 属性
    AnnotationAttributes attributes = getAttributes(annotationMetadata);
    // 获取所有需要自动装配的候选项
    List<String> configurations = getCandidateConfigurations(annotationMetadata, attributes);
    // 去除重复的选项
    configurations = removeDuplicates(configurations);
    // 获取注解配置的排除的自动装配类
    Set<String> exclusions = getExclusions(annotationMetadata, attributes);
    checkExcludedClasses(configurations, exclusions);
    // 移除所有的配置的不需要自动装配的类
    configurations.removeAll(exclusions);
    // 过滤，条件装配
    configurations = getConfigurationClassFilter().filter(configurations);
    // 获取 AutoConfigurationImportListener 类的监听器调用 onAutoConfigurationImportEvent 方法
    fireAutoConfigurationImportEvents(configurations, exclusions);
    // 包装成 AutoConfigurationEntry 返回
    return new AutoConfigurationEntry(configurations, exclusions);
}
```

AutoConfigurationImportSelector#getCandidateConfigurations：获取自动配置的候选项

* `List<String> configurations = SpringFactoriesLoader.loadFactoryNames()`：加载自动配置类

  参数一：`getSpringFactoriesLoaderFactoryClass()`：获取 @EnableAutoConfiguration 注解类

  参数二：`getBeanClassLoader()`：获取类加载器

  * `factoryTypeName = factoryType.getName()`：@EnableAutoConfiguration 注解的全类名
  * `return loadSpringFactories(classLoaderToUse).getOrDefault()`：加载资源
    * `urls = classLoader.getResources(FACTORIES_RESOURCE_LOCATION)`：获取资源类
    * `FACTORIES_RESOURCE_LOCATION = "META-INF/spring.factories"`：**加载的资源的位置**

* `return configurations`：返回所有自动装配类的候选项

- 从 spring-boot-autoconfigure-2.5.3.jar/META-INF/spring.factories 文件中寻找 EnableAutoConfiguration 字段，获取自动装配类，**进行条件装配，按需装配**

  ![](https://gitee.com/seazean/images/raw/master/Frame/SpringBoot-自动装配配置文件.png)

### 1.4.3 装配流程

Spring Boot 通过 `@EnableAutoConfiguration` 开启自动装配，通过 SpringFactoriesLoader 加载 `META-INF/spring.factories` 中的自动配置类实现自动装配，自动配置类其实就是通过 `@Conditional` 注解按需加载的配置类，想要其生效必须引入 `spring-boot-starter-xxx` 包实现起步依赖

* SpringBoot 先加载所有的自动配置类 xxxxxAutoConfiguration
* 每个自动配置类进行**条件装配**，默认都会绑定配置文件指定的值（xxxProperties 和配置文件进行了绑定）
* SpringBoot 默认会在底层配好所有的组件，如果用户自己配置了**以用户的优先**
* **定制化配置：**
  - 用户可以使用 @Bean 新建自己的组件来替换底层的组件
  - 用户可以去看这个组件是获取的配置文件前缀值，在配置文件中修改

以 DispatcherServletAutoConfiguration 为例：

```java
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)
// 类中的 Bean 默认不是单例
@Configuration(proxyBeanMethods = false)
@ConditionalOnWebApplication(type = Type.SERVLET)
// 条件装配，环境中有 DispatcherServlet 类才进行自动装配
@ConditionalOnClass(DispatcherServlet.class)
@AutoConfigureAfter(ServletWebServerFactoryAutoConfiguration.class)
public class DispatcherServletAutoConfiguration {
	// 注册的 DispatcherServlet 的 BeanName
	public static final String DEFAULT_DISPATCHER_SERVLET_BEAN_NAME = "dispatcherServlet";

	@Configuration(proxyBeanMethods = false)
	@Conditional(DefaultDispatcherServletCondition.class)
	@ConditionalOnClass(ServletRegistration.class)
    // 绑定配置文件的属性，从配置文件中获取配置项
	@EnableConfigurationProperties(WebMvcProperties.class)
	protected static class DispatcherServletConfiguration {
		
        // 给容器注册一个 DispatcherServlet，起名字为 dispatcherServlet
		@Bean(name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)
		public DispatcherServlet dispatcherServlet(WebMvcProperties webMvcProperties) {
            // 新建一个 DispatcherServlet 设置相关属性
			DispatcherServlet dispatcherServlet = new DispatcherServlet();
            // spring.mvc 中的配置项获取注入，没有就填充默认值
			dispatcherServlet.setDispatchOptionsRequest(webMvcProperties.isDispatchOptionsRequest());
			// ......
            // 返回该对象注册到容器内
			return dispatcherServlet;
		}

		@Bean
        // 容器中有这个类型组件才进行装配
		@ConditionalOnBean(MultipartResolver.class)
        // 容器中没有这个名字 multipartResolver 的组件
		@ConditionalOnMissingBean(name = DispatcherServlet.MULTIPART_RESOLVER_BEAN_NAME)
        // 方法名就是 BeanName
		public MultipartResolver multipartResolver(MultipartResolver resolver) {
			// 给 @Bean 标注的方法传入了对象参数，这个参数就会从容器中找，因为用户自定义了该类型，以用户配置的优先
            // 但是名字不符合规范，所以获取到该 Bean 并返回到容器一个规范的名称：multipartResolver
			return resolver;
		}
	}
}
```

```java
// 将配置文件中的 spring.mvc 前缀的属性与该类绑定
@ConfigurationProperties(prefix = "spring.mvc")	
public class WebMvcProperties { }
```

## 1.5 事件监听

SpringBoot 在项目启动时，会对几个监听器进行回调，可以实现监听器接口，在项目启动时完成一些操作

ApplicationContextInitializer、SpringApplicationRunListener、CommandLineRunner、ApplicationRunner

* MyApplicationRunner

  **自定义监听器的启动时机**：MyApplicationRunner 和 MyCommandLineRunner 都是当项目启动后执行，使用 @Component 放入容器即可使用

  ```java
  //当项目启动后执行run方法
  @Component
  public class MyApplicationRunner implements ApplicationRunner {
      @Override
      public void run(ApplicationArguments args) throws Exception {
          System.out.println("ApplicationRunner...run");
          System.out.println(Arrays.asList(args.getSourceArgs()));//properties配置信息
      }
  } 
  ```

* MyCommandLineRunner

  ```java
  @Component
  public class MyCommandLineRunner implements CommandLineRunner {
      @Override
      public void run(String... args) throws Exception {
          System.out.println("CommandLineRunner...run");
          System.out.println(Arrays.asList(args));
      }
  }
  ```

* MyApplicationContextInitializer 的启用要**在 resource 文件夹下添加 META-INF/spring.factories**

  ```properties
  org.springframework.context.ApplicationContextInitializer=\
  com.example.springbootlistener.listener.MyApplicationContextInitializer
  ```

  ```java
  @Component
  public class MyApplicationContextInitializer implements ApplicationContextInitializer {
      @Override
      public void initialize(ConfigurableApplicationContext applicationContext) {
          System.out.println("ApplicationContextInitializer....initialize");
      }
  }
  ```

* MySpringApplicationRunListener 的使用要添加**构造器**

  ```java
  public class MySpringApplicationRunListener implements SpringApplicationRunListener {
  	//构造器
      public MySpringApplicationRunListener(SpringApplication sa, String[] args) {
      }
  
      @Override
      public void starting() {
          System.out.println("starting...项目启动中");//输出SPRING之前
      }
  
      @Override
      public void environmentPrepared(ConfigurableEnvironment environment) {
          System.out.println("environmentPrepared...环境对象开始准备");
      }
  
      @Override
      public void contextPrepared(ConfigurableApplicationContext context) {
          System.out.println("contextPrepared...上下文对象开始准备");
      }
  
      @Override
      public void contextLoaded(ConfigurableApplicationContext context) {
          System.out.println("contextLoaded...上下文对象开始加载");
      }
  
      @Override
      public void started(ConfigurableApplicationContext context) {
          System.out.println("started...上下文对象加载完成");
      }
  
      @Override
      public void running(ConfigurableApplicationContext context) {
          System.out.println("running...项目启动完成，开始运行");
      }
  
      @Override
      public void failed(ConfigurableApplicationContext context, Throwable exception) {
          System.out.println("failed...项目启动失败");
      }
  }
  ```


# 2. 配置文件

官方文档中的配置参数介绍

https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#application-properties

## 2.1 配置方式

### 2.1.1 文件类型

SpringBoot 是基于约定的，很多配置都有默认值，如果想使用自己的配置替换默认配置，可以使用 application.properties 或者application.yml（application.yaml）进行配置

* 默认配置文件名称：application
* 在同一级目录下优先级为：properties > yml > yaml

例如配置内置 Tomcat 的端口

* properties：

  ```properties
  server.port=8080
  ```

* yml：

  ```yaml
  server: port: 8080
  ```

* yaml：

  ```yaml
  server: port: 8080
  ```

### 2.1.2 加载顺序

所有位置的配置文件都会被加载，互补配置，**高优先级配置内容会覆盖低优先级配置内容**

扫描配置文件的位置按优先级**从高到底**：

- `file:./config/`：**当前项目**下的 /config 目录下

- `file:./`：当前项目的根目录，Project工程目录

- `classpath:/config/`：classpath 的 /config 目录

- `classpath:/`：classpath 的根目录，就是 resoureces 目录

项目外部配置文件加载顺序：外部配置文件的使用是为了对内部文件的配合

* 命令行：在 package 打包后的 target 目录下，使用该命令

  ```sh
  java -jar myproject.jar --server.port=9000
  ```

* 指定配置文件位置

  ```sh
  java -jar myproject.jar --spring.config.location=e://application.properties
  ```

* 按优先级从高到底选择配置文件的加载命令

  ```sh
  java -jar myproject.jar
  ```

  

## 2.2 yaml语法

基本语法：

- 大小写敏感

- **数据值前边必须有空格，作为分隔符**

- 使用缩进表示层级关系

- 缩进时不允许使用Tab键，只允许使用空格（各个系统 Tab对应空格数目可能不同，导致层次混乱）

- 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可

- ''#" 表示注释，从这个字符一直到行尾，都会被解析器忽略

  ```yaml
  server: 
  	port: 8080  
      address: 127.0.0.1
  ```

数据格式：

* 纯量：单个的、不可再分的值

  ```yaml
  msg1: 'hello \n world'  # 单引忽略转义字符
  msg2: "hello \n world"  # 双引识别转义字符
  ```

* 对象：键值对集合，Map、Hash

  ```yaml
  person:  
     name: zhangsan
     age: 20
  # 行内写法
  person: {name: zhangsan}
  ```

  注意：不建议使用 JSON，应该使用 yaml 语法

* 数组：一组按次序排列的值，List、Array

  ```yaml
  address:
    - beijing
    - shanghai
  # 行内写法
  address: [beijing,shanghai]
  ```

  ```yaml
  allPerson	#List<Person>
    - {name:lisi, age:18}
    - {name:wangwu, age:20}
  # 行内写法
  allPerson: [{name:lisi, age:18}, {name:wangwu, age:20}]
  ```

* 参数引用：

  ```yaml
  name: lisi 
  person:
    name: ${name} # 引用上边定义的name值
  ```

## 2.3 获取配置

三种获取配置文件的方式：

* 注解 @Value

  ```java
  @RestController
  public class HelloController {
      @Value("${name}")
      private String name;
  
      @Value("${person.name}")
      private String name2;
  
      @Value("${address[0]}")
      private String address1;
  
      @Value("${msg1}")
      private String msg1;
  
      @Value("${msg2}")
      private String msg2;
      
      @RequestMapping("/hello")
      public String hello(){
          System.out.println("所有的数据");
          return " hello Spring Boot !";
      }
  }
  ```

* Evironment 对象

  ```java
  @Autowired
  private Environment env;
  
  @RequestMapping("/hello")
  public String hello() {
      System.out.println(env.getProperty("person.name"));
      System.out.println(env.getProperty("address[0]"));
      return " hello Spring Boot !";
  }
  ```

* 注解 @ConfigurationProperties 配合 @Component 使用以及@Data使用

  **注意**：参数 prefix 一定要指定

  ```java
  @Component	//不扫描该组件到容器内，无法完成自动装配
  @Da
  @ConfigurationProperties(prefix = "person")
  public class Person {
      private String name;
      private int age;
      private String[] address;
  }
  ```
  
  ```java
  @Autowired
  private Person person;
  
  @RequestMapping("/hello")
  public String hello() {
      System.out.println(person);
      //Person{name='zhangsan', age=20, address=[beijing, shanghai]}
      return " hello Spring Boot !";
  }
  ```


## 2.4 配置提示

自定义的类和配置文件绑定一般没有提示，添加如下依赖可以使用提示：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-configuration-processor</artifactId>
    <optional>true</optional>
</dependency>

<!-- 下面插件作用是工程打包时，不将spring-boot-configuration-processor打进包内，让其只在编码的时候有用 -->
<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
            <configuration>
                <excludes>
                    <exclude>
                        <groupId>org.springframework.boot</groupId>
                        <artifactId>spring-boot-configuration-processor</artifactId>
                    </exclude>
                </excludes>
            </configuration>
        </plugin>
    </plugins>
</build>
```

## 2.5 Profile

### 2.5.1 配置文件加载

1. 默认配置文件  application.yaml；任何时候都会加载
2. 指定环境配置文件  application-{env}.yaml
3. 激活指定环境
   1. 配置文件激活 `spring.profiles.active=dev`
   2. 命令行激活：java -jar xxx.jar --spring.profiles.active=prod  --person.name=haha
   3. 虚拟机参数：在VM options 指定：`-Dspring.profiles.active=dev`
   4. **修改配置文件的任意值，**命令行优先
4. 默认配置与环境配置同时生效
5. 同名配置项，profile配置优先



yml 多文档方式：在 yml 中使用  --- 分隔不同配置

```yacas
---
server:
  port: 8081
spring:
  profiles:dev
---
server:
  port: 8082
spring:
  profiles:test
---
server:
  port: 8083
spring:
  profiles:pro
---
```

### 2.5.2 @Profile

@Profile：指定组件在哪个环境的情况下才能被注册到容器中，不指定，任何环境下都能注册这个组件

 * 加了环境标识的 bean，只有这个环境被激活的时候才能注册到容器中，默认是 default 环境
 * 写在配置类上，只有是指定的环境的时候，整个配置类里面的所有配置才能开始生效
 * 没有标注环境标识的 bean 在，任何环境下都是加载的



# 3. Web开发

## 3.1 功能支持

SpringBoot 自动配置了很多约定，大多场景都无需自定义配置

* 内容协商视图解析器 ContentNegotiatingViewResolver 和 BeanName 视图解析器 BeanNameViewResolver
* 支持静态资源（包括 webjars）和静态 index.html 页支持
* 自动注册相关类：Converter、GenericConverter、Formatter
* 内容协商处理器：HttpMessageConverters
* 国际化：MessageCodesResolver

开发规范：

* 使用 `@Configuration` + `WebMvcConfigurer` 自定义规则，不使用 `@EnableWebMvc` 注解
* 声明 `WebMvcRegistrations` 的实现类改变默认底层组件
* 使用 `@EnableWebMvc` + `@Configuration` + `DelegatingWebMvcConfiguration` 全面接管 SpringMVC

## 3.2 静态资源

### 3.2.1 访问规则

1. 静态资源目录(只要静态资源放在以下目录，就能通过url访问到)

- classpath:/META-INF/resources/  
- classpath:/resources/ 
- classpath:/static/ 
- classpath:/public/

2. 访问方式 ： 当前项目根路径/ + 静态资源名 

3. 优先级：由高到低为：/META-INF/resources、/resources、 /static、/public  的包内，`/` 表示当前项目的根路径

### 3.2.2 访问原理

By default, resources are mapped on `/**`

请求进来，先去找Controller看能不能处理。不能处理的所有请求又都交给静态资源处理器。静态资源也找不到则响应404页面。

### 3.2.3 修改参数

1. 修改默认资源路径

```yaml
spring:
  web:
    resources:
      static-locations:: [classpath:/haha/]
```

2. 修改静态资源访问前缀，默认是 `/**`：

```yaml
spring:
  mvc:
    static-path-pattern: /resources/**
```

3. 禁用所有静态资源

```yaml
spring:
  resources:
    add-mappings: false   禁用所有静态资源规则
```

### 3.2.4 欢迎页面

1. 静态资源路径下 index.html 默认作为欢迎页面，访问 http://localhost:8080 出现该页面
2. 配置静态资源的访问前缀。将导致 index.html不能被默认访问

### 3.2.5 源码分析

- SpringBoot启动默认加载  xxxAutoConfiguration 类（自动配置类)
- 关于静态资源访问的原理在`SpringMVC功能的自动配置类 WebMvcAutoConfiguration`

```java
@Configuration(proxyBeanMethods = false)
@ConditionalOnWebApplication(type = Type.SERVLET)
@ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class })
@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)
@AutoConfigureAfter({ DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class,
		ValidationAutoConfiguration.class })
public class WebMvcAutoConfiguration {}
```

- 其中有一个静态内部类
  - WebMvcProperties 和 以`spring.mvc`为前缀的配置属性绑定
  - ResourceProperties和以`spring.resources`为前缀的配置属性绑定

```java
@Configuration(proxyBeanMethods = false)
@Import(EnableWebMvcConfiguration.class)
@EnableConfigurationProperties({ WebMvcProperties.class, ResourceProperties.class })
@Order(0)
public static class WebMvcAutoConfigurationAdapter implements WebMvcConfigurer {}
```

- **资源处理的默认规则**

```java
public void addResourceHandlers(ResourceHandlerRegistry registry) {
    //相当于spring.resources.add-mappings=false,禁用了所有的静态资源访问
    if (!this.resourceProperties.isAddMappings()) {
        logger.debug("Default resource handling disabled");
    } else {
        //自动映射url为/webjars/**的请求，到classpath:/META-INF/resources/webjars/中去寻找资源
        this.addResourceHandler(registry, "/webjars/**", "classpath:/META-INF/resources/webjars/");
        
        /**1.this.mvcProperties.getStaticPathPattern() 默认为**,可通过spring.mvc.static-path-pattern配置
         **2.this.resourceProperties.getStaticLocations() 默认为 那四个常见的静态目录
         **3.自动映射url为/**的请求，到静态目录下去寻找资源
        **/
        this.addResourceHandler(registry, this.mvcProperties.getStaticPathPattern(), (registration) -> {
            registration.addResourceLocations(this.resourceProperties.getStaticLocations());
            if (this.servletContext != null) {
                ServletContextResource resource = new ServletContextResource(this.servletContext, "/");
                registration.addResourceLocations(new Resource[]{resource});
            }

        });
    }
}
```

## 3.3 请求参数处理

### 3.3.1 Rest风格映射

#### I 基本介绍

Rest（REpresentational State Transfer）：表现层状态转化，定义了**资源”在网络传输中以某种“表现形式”进行“状态转移**，即网络资源的访问方式

* 资源：把真实的对象数据称为资源，一个资源既可以是一个集合，也可以是单个个体；每一种资源都有特定的 URI（统一资源标识符）与之对应，如果获取这个资源，访问这个 URI 就可以，比如获取特定的班级`/class/12`；资源也可以包含子资源，比如 `/classes/classId/teachers`某个指定班级的所有老师
* 表现形式："资源"是一种信息实体，它可以有多种外在表现形式，把"资源"具体呈现出来的形式比如 json、xml、image、txt 等等叫做它的"表现层/表现形式"
* 状态转移：描述的服务器端资源的状态，比如增删改查（通过 HTTP 动词实现）引起资源状态的改变，互联网通信协议 HTTP 协议，是一个**无状态协议**，所有的资源状态都保存在服务器端(如GET，POST，PUT,DELETE)

#### II 访问方式

不适用Rest风格

​	/getUser  获取用户    /deleteUser 删除用户   /editUser  修改用户      /saveUser 保存用户

使用Rest风格以后

​	/user    GET-获取用户    DELETE-删除用户     PUT-修改用户      POST-保存用户

优点：隐藏资源的访问行为，通过地址无法得知做的是何种操作，书写简化

#### III 代码实现

1. 手动开启rest功能

```yaml
spring:
  mvc:
    hiddenmethod:
      filter:
        enabled: true   #开启页面表单的Rest功能
```

2. 前端代码

- Get请求和POST请求直接设置method为get或post就行了
- put和delete请求需要设置method为post，并且页面表单**使用隐藏域提交请求类型**，参数名称固定为 _method，value为请求方式

```html
<form action="/user" method="post">
    <intput name="_method" type="hidden" value="PUT"/>
    <input value="REST-PUT 提交" type="submit"/>
</form>
```

3. 后端代码

```java
@RestController				/
@RequestMapping("/user/")	//设置公共访问路径，配合下方访问路径使用
public class UserController {
    @GetMapping("/user")
    //@RequestMapping(value = "/user",method = RequestMethod.GET)
    public String getUser(){
        return "GET-张三";
    }

    @PostMapping("/user")
    //@RequestMapping(value = "/user",method = RequestMethod.POST)
    public String saveUser(){
        return "POST-张三";
    }

    @PutMapping("/user")
    //@RequestMapping(value = "/user",method = RequestMethod.PUT)
    public String putUser(){
        return "PUT-张三";
    }

    @DeleteMapping("/user")
    //@RequestMapping(value = "/user",method = RequestMethod.DELETE)
    public String deleteUser(){
        return "DELETE-张三";
    }
}
```

#### IV 实现原理

表单提交要使用 REST 时，会带上 `_method=PUT`，请求过来被 `HiddenHttpMethodFilter` 拦截，进行过滤操作.

- mvc自动配置类中有一个组件,这个组件就是用来处理RESTFUL风格的filter

```java
@Bean
@ConditionalOnMissingBean({HiddenHttpMethodFilter.class})
@ConditionalOnProperty(
    prefix = "spring.mvc.hiddenmethod.filter",
    name = {"enabled"}
)
public OrderedHiddenHttpMethodFilter hiddenHttpMethodFilter() {
    return new OrderedHiddenHttpMethodFilter();
}
```

- 本质上是调用org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal()：

```java
public class HiddenHttpMethodFilter extends OncePerRequestFilter {
    // 兼容的请求 PUT、DELETE、PATCH
    private static final List<String> ALLOWED_METHODS =
			Collections.unmodifiableList(Arrays.asList(HttpMethod.PUT.name(),
					HttpMethod.DELETE.name(), HttpMethod.PATCH.name()));
    // 隐藏域的名字
	public static final String DEFAULT_METHOD_PARAM = "_method";

	private String methodParam = DEFAULT_METHOD_PARAM;
    
    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response,
                                    FilterChain filterChain) throws ServletException, IOException {

        HttpServletRequest requestToUse = request;
        // 请求必须是 POST，
        if ("POST".equals(request.getMethod()) && request.getAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE) == null) {
            // 获取标签中 name="_method" 的 value 值
            String paramValue = request.getParameter(this.methodParam);
            if (StringUtils.hasLength(paramValue)) {
                // 转成大写
                String method = paramValue.toUpperCase(Locale.ENGLISH);
                // 兼容的请求方式
                if (ALLOWED_METHODS.contains(method)) {
                    // 包装请求,使得getMethod()方法返回的是_method的值
                    requestToUse = new HttpMethodRequestWrapper(request, method);
                }
            }
        }
        // 过滤器链放行的时候用wrapper。以后的方法调用getMethod是调用requesWrapper的
        filterChain.doFilter(requestToUse, response);
    }
}
```

#### V 修改_method名字

```java
@Configuration(proxyBeanMethods = false)
public class WebConfig{
    //自定义filter
    @Bean
    public HiddenHttpMethodFilter hiddenHttpMethodFilter(){
        HiddenHttpMethodFilter methodFilter = new HiddenHttpMethodFilter();
        //通过set 方法自定义
        methodFilter.setMethodParam("_m");
        return methodFilter;
    }    
}
```

### 3.3.2 请求参数

1. 既可以将参数封装到单个的变量，也可以封装到一个Map中。当同时出现时，清求参数都会进行赋值

#### I 注解

1. **`@RequestParam`** annotated parameters get linked to specific Servlet request parameters. Parameter values are converted to the declared method argument type. This annotation indicates that a method parameter should `be bound to a web request parameter`。

1. **`@RequestBody`** annotated parameters get linked to the HTTP request body. Parameter values are converted to the declared method argument type using HttpMessageConverters. This annotation indicates a method parameter should `be bound to the body of the web request`.通常请求体中的是JSON数据
2. 

@PathVariable、@RequestHeader、@RequestParam、@CookieValue、@RequestBody、@RequestAttribute、@MatrixVariable

```java
@RestController
public class ParameterTestController {


    //  car/2/owner/zhangsan
    @GetMapping("/car/{id}/owner/{username}")
    public Map<String,Object> getCar(@PathVariable("id") Integer id,
                                     @PathVariable("username") String name,
                                     @PathVariable Map<String,String> pv,
                                     
                                     @RequestHeader("User-Agent") String userAgent,
                                     @RequestHeader Map<String,String> header,
                                     
                                     @RequestParam("age") Integer age,
                                     @RequestParam("inters") List<String> inters,
                                     @RequestParam Map<String,String> params,
                                     
                                     @CookieValue("_ga") String _ga,
                                     @CookieValue("_ga") Cookie cookie){


        Map<String,Object> map = new HashMap<>();

//        map.put("id",id);
//        map.put("name",name);
//        map.put("pv",pv);
//        map.put("userAgent",userAgent);
//        map.put("headers",header);
        map.put("age",age);
        map.put("inters",inters);
        map.put("params",params);
        map.put("_ga",_ga);
        System.out.println(cookie.getName()+"===>"+cookie.getValue());
        return map;
    }


    @PostMapping("/save")
    public Map postMethod(@RequestBody String content){
        Map<String,Object> map = new HashMap<>();
        map.put("content",content);
        return map;
    }


    //1、语法： 请求路径：/cars/sell;low=34;brand=byd,audi,yd
    //2、SpringBoot默认是禁用了矩阵变量的功能
    //      手动开启：原理。对于路径的处理。UrlPathHelper进行解析。
    //              removeSemicolonContent（移除分号内容）支持矩阵变量的
    //3、矩阵变量必须有url路径变量才能被解析
    @GetMapping("/cars/{path}")
    public Map carsSell(@MatrixVariable("low") Integer low,
                        @MatrixVariable("brand") List<String> brand,
                        @PathVariable("path") String path){
        Map<String,Object> map = new HashMap<>();

        map.put("low",low);
        map.put("brand",brand);
        map.put("path",path);
        return map;
    }

    // /boss/1;age=20/2;age=10

    @GetMapping("/boss/{bossId}/{empId}")
    public Map boss(@MatrixVariable(value = "age",pathVar = "bossId") Integer bossAge,
                    @MatrixVariable(value = "age",pathVar = "empId") Integer empAge){
        Map<String,Object> map = new HashMap<>();

        map.put("bossAge",bossAge);
        map.put("empAge",empAge);
        return map;

    }

}
```

#### II **Servlet API：**

WebRequest、ServletRequest、MultipartRequest、 HttpSession、javax.servlet.http.PushBuilder、Principal、InputStream、Reader、HttpMethod、Locale、TimeZone、ZoneId、**HttpServeltRequest**

#### III 复制参数

Map、Model（map、model里面的数据会被放在request的请求域  request.setAttribute）、Errors/BindingResult、RedirectAttributes（ 重定向携带数据）、ServletResponse（response）、SessionStatus、UriComponentsBuilder、ServletUriComponentsBuilder

#### IV 自定义对象参数

可以自动类型转换与格式化，可以级联封装。

```java
/**
 *     姓名： <input name="userName"/> <br/>
 *     年龄： <input name="age"/> <br/>
 *     生日： <input name="birth"/> <br/>
 *     宠物姓名：<input name="pet.name"/><br/>
 *     宠物年龄：<input name="pet.age"/>
 */
@Data
public class Person {
    
    private String userName;
    private Integer age;
    private Date birth;
    private Pet pet;
    
}

@Data
public class Pet {

    private String name;
    private String age;

}
```

## 3.4 运行原理

见springmvc->运行原理

## 3.5 拦截器

### 3.5.1 原理

1. 根据当前请求，找到HandlerExecutionChain【可以处理请求的handler以及handler的所有 拦截器】（就是getHandler方法）
2. 先来顺序执行 所有拦截器的 preHandle方法

- 如果当前拦截器prehandler返回为true。则执行下一个拦截器的preHandle

- 如果当前拦截器返回为false。直接倒序执行所有已经执行了的拦截器的  afterCompletion；

3. 如果任何一个pre拦截器返回false。直接跳出不执行目标方法
4. 所有拦截器都返回True。执行目标方法
5. 倒序执行所有拦截器的postHandle方法。
6. 前面的步骤有任何异常都会直接倒序触发 afterCompletion
7. 页面成功渲染完成以后，也会倒序触发 afterCompletion

> 详情见springmvc

### 3.5.2 自定义

1. 编写一个拦截器类

```java
/**
 * 登录检查
 * 1、配置好拦截器要拦截哪些请求
 * 2、把这些配置放在容器中
 */
@Slf4j
public class LoginInterceptor implements HandlerInterceptor {

    /**
     * 目标方法执行之前
     * @param request
     * @param response
     * @param handler
     * @return
     * @throws Exception
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {

        String requestURI = request.getRequestURI();
        log.info("preHandle拦截的请求路径是{}",requestURI);

        //登录检查逻辑
        HttpSession session = request.getSession();

        Object loginUser = session.getAttribute("loginUser");

        if(loginUser != null){
            //放行
            return true;
        }

        //拦截住。未登录。跳转到登录页
        request.setAttribute("msg","请先登录");
//        re.sendRedirect("/");
        request.getRequestDispatcher("/").forward(request,response);
        return false;
    }

    /**
     * 目标方法执行完成以后
     * @param request
     * @param response
     * @param handler
     * @param modelAndView
     * @throws Exception
     */
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        log.info("postHandle执行{}",modelAndView);
    }

    /**
     * 页面渲染以后
     * @param request
     * @param response
     * @param handler
     * @param ex
     * @throws Exception
     */
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        log.info("afterCompletion执行异常{}",ex);
    }
}
```

2. 配置拦截器

```java
/**
 * 1、编写一个拦截器实现HandlerInterceptor接口
 * 2、拦截器注册到容器中（实现WebMvcConfigurer的addInterceptors）
 * 3、指定拦截规则【如果是拦截所有，静态资源也会被拦截】
 */
@Configuration
public class AdminWebConfig implements WebMvcConfigurer {

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new LoginInterceptor())
                .addPathPatterns("/**")  //所有请求都被拦截包括静态资源
                .excludePathPatterns("/","/login","/css/**","/fonts/**","/images/**","/js/**"); //放行的请求
    }
}
```

## 3.6 文件上传

### 3.6.1 代码实现

1. 页面表单

```html
<form method="post" action="/upload" enctype="multipart/form-data">
    <input type="file" name="file"><br>
    <input type="submit" value="提交">
</form>
```

2. 文件上传代码

```java
/**
     * MultipartFile 自动封装上传过来的文件
     * @param email
     * @param username
     * @param headerImg
     * @param photos
     * @return
     */
@PostMapping("/upload")
public String upload(@RequestParam("email") String email,
                     @RequestParam("username") String username,
                     @RequestPart("headerImg") MultipartFile headerImg,
                     @RequestPart("photos") MultipartFile[] photos) throws IOException {

    log.info("上传的信息：email={}，username={}，headerImg={}，photos={}",
             email,username,headerImg.getSize(),photos.length);

    if(!headerImg.isEmpty()){
        //保存到文件服务器，OSS服务器
        String originalFilename = headerImg.getOriginalFilename();
        headerImg.transferTo(new File("H:\\cache\\"+originalFilename));
    }

    if(photos.length > 0){
        for (MultipartFile photo : photos) {
            if(!photo.isEmpty()){
                String originalFilename = photo.getOriginalFilename();
                photo.transferTo(new File("H:\\cache\\"+originalFilename));
            }
        }
    }


    return "main";
}
```

### 3.6.2 原理

见springmvc部分的文件上传

## 3.7 异常处理

见springmvc中的异常处理

## 3.8 嵌入式Servlet容器

SpringBoot 嵌入式 Servlet 容器，默认支持的 webServe：Tomcat、Jetty、Undertow

配置方式：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
    <exclusions>
        <exclusion> <!--必须要把内嵌的 Tomcat 容器-->
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-tomcat</artifactId>
        </exclusion>
    </exclusions>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-jetty</artifactId>
</dependency>
```

Web 应用启动，SpringBoot 导入 Web 场景包 tomcat，创建一个 Web 版的 IOC 容器：

* `SpringApplication.run(BootApplication.class, args)`：应用启动

* `ConfigurableApplicationContext.run()`：

  * `context = createApplicationContext()`：**创建容器**

    * `applicationContextFactory = ApplicationContextFactory.DEFAULT`

      ```java
      ApplicationContextFactory DEFAULT = (webApplicationType) -> {
          try {
              switch (webApplicationType) {
                  case SERVLET:
                      // Servlet 容器，继承自 ServletWebServerApplicationContext
                      return new AnnotationConfigServletWebServerApplicationContext();
                  case REACTIVE:
                      // 响应式编程
                      return new AnnotationConfigReactiveWebServerApplicationContext();
                  default:
                      // 普通 Spring 容器
                      return new AnnotationConfigApplicationContext();
              }
          } catch (Exception ex) {
              throw new IllegalStateException();
          }
      }
      ```

    * `applicationContextFactory.create(this.webApplicationType)`：根据应用类型创建容器

  * `refreshContext(context)`：容器启动刷新

内嵌容器工作流程：

- Spring 容器启动逻辑中，在实例化非懒加载的单例 Bean 之前有一个方法 **onRefresh()**，留给子类去扩展，Web 容器就是重写这个方法创建 WebServer

  ```java
  protected void onRefresh() {
      //省略....
  	createWebServer();
  }
  private void createWebServer() {
      ServletWebServerFactory factory = getWebServerFactory();
      this.webServer = factory.getWebServer(getSelfInitializer());
      createWebServer.end();
  }
  ```

  获取 WebServer 工厂 ServletWebServerFactory，并且获取的数量不等于 1 会报错，Spring 底层有三种：

  `TomcatServletWebServerFactory`、`JettyServletWebServerFactory`、`UndertowServletWebServerFactory`

- **自动配置类 ServletWebServerFactoryAutoConfiguration** 导入了 ServletWebServerFactoryConfiguration（配置类），根据条件装配判断系统中到底导入了哪个 Web 服务器的包，创建出服务器并启动

- 默认是 web-starter 导入 tomcat 包，容器中就有 TomcatServletWebServerFactory，创建出 Tomcat 服务器并启动，

  ```java
  public TomcatWebServer(Tomcat tomcat, boolean autoStart, Shutdown shutdown) {
  	// 初始化
     	initialize();
  }
  ```

  初始化方法 initialize 中有启动方法：`this.tomcat.start()`

# 4. 数据访问

## 4.1 JDBC

### 4.1.1 使用

1. pom.xml

```xml
<!--导入 JDBC 场景-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jdbc</artifactId>
</dependency>
<!--导入 MySQL 驱动-->
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <!--版本对应你的 MySQL 版本<version>5.1.49</version>-->
</dependency>
```

> 单独导入 MySQL 驱动是因为不确定用户使用的什么数据库

2. 配置文件

```yaml
spring:
  datasource:
    url: jdbc:mysql://49.235.253.211:3306/Mybatis?useUnicode=true&characterEncoding=utf-8&useSSL=false&serverTimezone=GMT
    username: root
    password: Aa123Aa123
    driver-class-name: com.mysql.cj.jdbc.Driver
```

3. 测试

```java
@Slf4j
@SpringBootTest
class Boot05WebAdminApplicationTests {

    @Autowired
    JdbcTemplate jdbcTemplate;

    @Test
    void contextLoads() {
        Long res = jdbcTemplate.queryForObject("select count(*) from account_tbl", Long.class);
        log.info("记录总数：{}", res);
    }
}
```

### 4.1.2 自动配置原理

DataSourceAutoConfiguration：数据源的自动配置

```java
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass({ DataSource.class, EmbeddedDatabaseType.class })
@EnableConfigurationProperties(DataSourceProperties.class)
public class DataSourceAutoConfiguration {
    
	@Conditional(PooledDataSourceCondition.class) 
	@ConditionalOnMissingBean({ DataSource.class, XADataSource.class })
	@Import({ DataSourceConfiguration.Hikari.class, DataSourceConfiguration.Tomcat.class,
			DataSourceConfiguration.Dbcp2.class, DataSourceConfiguration.OracleUcp.class})
	protected static class PooledDataSourceConfiguration {}
}
// 配置项
@ConfigurationProperties(prefix = "spring.datasource")
public class DataSourceProperties implements BeanClassLoaderAware, InitializingBean {}
```

- 底层默认配置好的连接池是：**HikariDataSource**
- 数据库连接池的配置，是容器中没有 DataSource 才自动配置的
- 修改数据源相关的配置：spring.datasource

其余相关配置：

- DataSourceTransactionManagerAutoConfiguration： 事务管理器的自动配置
- JdbcTemplateAutoConfiguration： JdbcTemplate 的自动配置
  - 可以修改这个配置项 @ConfigurationProperties(prefix = **"spring.jdbc"**) 来修改JdbcTemplate
  - `@AutoConfigureAfter(DataSourceAutoConfiguration.class)`：在 DataSource 装配后装配
- JndiDataSourceAutoConfiguration： jndi 的自动配置
- XADataSourceAutoConfiguration： 分布式事务相关



## 4.2 Druid

### 4.2.1 使用

1. 导入坐标

```xml
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid-spring-boot-starter</artifactId>
    <version>1.1.17</version>
</dependency>
```

2. 配置文件

```yaml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/Mybatis?useUnicode=true&characterEncoding=utf-8&useSSL=false&serverTimezone=GMT
    username: root
    password: Aa123Aa123
    driver-class-name: com.mysql.cj.jdbc.Driver

    druid:
      aop-patterns: com.atguigu.admin.*  #监控SpringBean
      filters: stat,wall     # 底层开启功能，stat（sql监控），wall（防火墙）

      stat-view-servlet:   # 配置监控页功能
        enabled: true
        login-username: admin	#项目启动访问：http://localhost:8080/druid ，账号和密码是 admin
        login-password: admin
        resetEnable: false

      web-stat-filter:  # 监控web
        enabled: true
        urlPattern: /*
        exclusions: '*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*'


      filter:
        stat:    # 对上面filters里面的stat的详细配置
          slow-sql-millis: 1000
          logSlowSql: true
          enabled: true
        wall:
          enabled: true
          config:
            drop-table-allow: false
```

配置示例：https://github.com/alibaba/druid/tree/master/druid-spring-boot-starter

配置项列表：https://github.com/alibaba/druid/wiki/DruidDataSource%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E5%88%97%E8%A1%A8

### 4.2.2 自动装配

```java
@Configuration
@ConditionalOnClass(DruidDataSource.class)
@AutoConfigureBefore(DataSourceAutoConfiguration.class)
@EnableConfigurationProperties({DruidStatProperties.class, DataSourceProperties.class})
@Import({DruidSpringAopConfiguration.class,
    DruidStatViewServletConfiguration.class,
    DruidWebStatFilterConfiguration.class,
    DruidFilterConfiguration.class})
public class DruidDataSourceAutoConfigure {}
```

自动配置：

- 扩展配置项 **spring.datasource.druid**
- DruidSpringAopConfiguration： 监控 SpringBean，配置项为 `spring.datasource.druid.aop-patterns`

- DruidStatViewServletConfiguration：监控页的配置项为 `spring.datasource.druid.stat-view-servlet`，默认开启
- DruidWebStatFilterConfiguration：Web 监控配置项为 `spring.datasource.druid.web-stat-filter`，默认开启

- DruidFilterConfiguration：所有 Druid 自己 filter 的配置

## 4.3 Mybatis

### 4.3.1 使用

1. 导入坐标：

   ```xml
   <dependency>
       <groupId>org.mybatis.spring.boot</groupId>
       <artifactId>mybatis-spring-boot-starter</artifactId>
       <version>2.1.4</version>
   </dependency>
   ```

2. 编写 MyBatis 相关配置：application.yml

   ```yaml
   # 配置mybatis规则
   mybatis:
     mapper-locations: classpath:mybatis/mapper/*.xml
     configuration:
       map-underscore-to-camel-case: true
   ```

3. 编写 dao 和 mapper 文件/纯注解开发

* dao：**@Mapper 注解必须加，使用自动装配的 package，否则在启动类指定 @MapperScan() 扫描路径（不建议）**

  ```java
  @Mapper  //必须加Mapper
  @Repository
  public interface UserXmlMapper {
      public List<User> findAll();
  }
  ```

  mapper.xml

  ```xml
  <?xml version="1.0" encoding="UTF-8" ?>
  <!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
  <mapper namespace="com.seazean.springbootmybatis.mapper.UserXmlMapper">
      <select id="findAll" resultType="user">
          select * from t_user
      </select>
  </mapper>
  ```

4. 定义表和实体类

   ```java
   public class User {
       private int id;
       private String username;
       private String password;
   }
   ```

### 4.3.2 自动配置

MybatisAutoConfiguration：

```java
@EnableConfigurationProperties(MybatisProperties.class)	//MyBatis配置项绑定类。
@AutoConfigureAfter({ DataSourceAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class })
public class MybatisAutoConfiguration {
    @Bean
  	@ConditionalOnMissingBean
  	public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
    	SqlSessionFactoryBean factory = new SqlSessionFactoryBean();
        return factory.getObject();
    }
    
    @org.springframework.context.annotation.Configuration
   	@Import(AutoConfiguredMapperScannerRegistrar.class)
   	@ConditionalOnMissingBean({ MapperFactoryBean.class, MapperScannerConfigurer.class })
   	public static class MapperScannerRegistrarNotFoundConfiguration implements InitializingBean {}
}

@ConfigurationProperties(prefix = "mybatis")
public class MybatisProperties {}
```

* 配置文件：`mybatis`
* 自动配置了 SqlSessionFactory
* SqlSession：自动配置了 SqlSessionTemplate 组合了SqlSession
* 导入 `AutoConfiguredMapperScannerRegistra` 实现 @Mapper 的扫描

## 4.4 Redis

### 4.4.1 使用

#### 1. 导入坐标

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
```

2. 配置redis相关属性

```yaml
spring:
  redis:
    host: 127.0.0.1 # redis的主机ip
    port: 6379
    password: 
```

3. 注入 RedisTemplate 模板

```java
@RunWith(SpringRunner.class)
@SpringBootTest
public class SpringbootRedisApplicationTests {
    @Autowired
    private RedisTemplate redisTemplate;

    @Test
    public void testSet() {
        //存入数据
        redisTemplate.boundValueOps("name").set("zhangsan");
    }
    @Test
    public void testGet() {
        //获取数据
        Object name = redisTemplate.boundValueOps("name").get();
        System.out.println(name);
    }
}
```

# 5. 单元测试

## 5.1 JUnit5

Spring Boot 2.2.0 版本开始引入 JUnit 5 作为单元测试默认库，由三个不同的子模块组成：

* JUnit Platform：在 JVM 上启动测试框架的基础，不仅支持 Junit 自制的测试引擎，其他测试引擎也可以接入

* JUnit Jupiter：提供了 JUnit5 的新的编程模型，是 JUnit5 新特性的核心，内部包含了一个测试引擎，用于在 Junit Platform 上运行

* JUnit Vintage：JUnit Vintage 提供了兼容 JUnit4.x、Junit3.x 的测试引擎

  > 注意：SpringBoot 2.4 以上版本移除了默认对 Vintage 的依赖，如果需要兼容 Junit4 需要自行引入

SpringBoot整合Junit以后。

1. 编写测试方法：@Test标注（注意需要使用junit5版本的注解）
2. Junit类具有Spring的功能，@Autowired、比如 @Transactional 标注测试方法，测试完成后自动回滚

```java
@SpringBootTest
class Boot05WebAdminApplicationTests {
    @Test
    void contextLoads() {

    }
}
```

## 5.2 常用注解

 JUnit5 的注解如下：

- @Test：表示方法是测试方法，但是与 JUnit4 的 @Test 不同，它的职责非常单一不能声明任何属性，拓展的测试将会由 Jupiter 提供额外测试，包是 `org.junit.jupiter.api.Test`
- @ParameterizedTest：表示方法是参数化测试
- @RepeatedTest：表示方法可重复执行
- @DisplayName：为测试类或者测试方法设置展示名称
- @BeforeEach：表示在每个单元测试之前执行的方法
- @AfterEach：表示在每个单元测试之后执行的方法
- @BeforeAll：表示在所有单元测试之前执行的方法
- @AfterAll：表示在所有单元测试之后执行的方法
- @Tag：表示单元测试类别，类似于 JUnit4 中的 @Categories
- @Disabled：表示测试类或测试方法不执行，类似于 JUnit4 中的 @Ignore
- @Timeout：表示测试方法运行如果超过了指定时间将会返回错误
- @ExtendWith：为测试类或测试方法提供扩展类引用

## 5.3 断言机制

### 5.3.1 简单断言

断言（assertions）是测试方法中的核心，用来对测试需要满足的条件进行验证，断言方法都是 org.junit.jupiter.api.Assertions 的静态方法

用来对单个值进行简单的验证：

| 方法            | 说明                                 |
| --------------- | ------------------------------------ |
| assertEquals    | 判断两个对象或两个原始类型是否相等   |
| assertNotEquals | 判断两个对象或两个原始类型是否不相等 |
| assertSame      | 判断两个对象引用是否指向同一个对象   |
| assertNotSame   | 判断两个对象引用是否指向不同的对象   |
| assertTrue      | 判断给定的布尔值是否为 true          |
| assertFalse     | 判断给定的布尔值是否为 false         |
| assertNull      | 判断给定的对象引用是否为 null        |
| assertNotNull   | 判断给定的对象引用是否不为 null      |

```java
@Test
@DisplayName("simple assertion")
public void simple() {
     assertEquals(3, 1 + 2, "simple math");
     assertNull(null);
     assertNotNull(new Object());
}
```

### 5.3.2 数组断言

通过 assertArrayEquals 方法来判断两个对象或原始类型的数组是否相等

```java
@Test
@DisplayName("array assertion")
public void array() {
 	assertArrayEquals(new int[]{1, 2}, new int[] {1, 2});
}
```

### 5.3.3 组合断言

assertAll 方法接受多个 org.junit.jupiter.api.Executable 函数式接口的实例作为验证的断言，可以通过 lambda 表达式提供这些断言

```java
@Test
@DisplayName("assert all")
public void all() {
	assertAll("Math",
              () -> assertEquals(2, 1 + 1),
              () -> assertTrue(1 > 0)
   	);
}
```

### 5.3.4 异常断言

Assertions.assertThrows()，配合函数式编程就可以进行使用

```java
@Test
@DisplayName("异常测试")
public void exceptionTest() {
    ArithmeticException exception = Assertions.assertThrows(
        //扔出断言异常
		ArithmeticException.class, () -> System.out.println(1 / 0)
    );
}
```

### 5.3.5 超时断言

Assertions.assertTimeout() 为测试方法设置了超时时间

```java
@Test
@DisplayName("超时测试")
public void timeoutTest() {
    //如果测试方法时间超过1s将会异常
    Assertions.assertTimeout(Duration.ofMillis(1000), () -> Thread.sleep(500));
}
```

### 5.3.6 快速失败

通过 fail 方法直接使得测试失败

```java
@Test
@DisplayName("fail")
public void shouldFail() {
	fail("This should fail");
}
```

## 5.4 前置条件

JUnit 5 中的前置条件（assumptions）类似于断言，不同之处在于**不满足的断言会使得测试方法失败**，而不满足的**前置条件只会使得测试方法的执行终止**，前置条件可以看成是测试方法执行的前提，当该前提不满足时，就没有继续执行的必要

```java
@DisplayName("测试前置条件")
@Test
void testassumptions(){
    Assumptions.assumeTrue(false,"结果不是true");
    System.out.println("111111");

}
```

## 5.5嵌套测试

JUnit 5 可以通过 Java 中的内部类和 @Nested 注解实现嵌套测试，从而可以更好的把相关的测试方法组织在一起，在内部类中可以使用 @BeforeEach 和 @AfterEach 注解，而且嵌套的层次没有限制

```java
@DisplayName("A stack")
class TestingAStackDemo {

    Stack<Object> stack;

    @Test
    @DisplayName("is instantiated with new Stack()")
    void isInstantiatedWithNew() {
        assertNull(stack)
    }

    @Nested
    @DisplayName("when new")
    class WhenNew {

        @BeforeEach
        void createNewStack() {
            stack = new Stack<>();
        }

        @Test
        @DisplayName("is empty")
        void isEmpty() {
            assertTrue(stack.isEmpty());
        }

        @Test
        @DisplayName("throws EmptyStackException when popped")
        void throwsExceptionWhenPopped() {
            assertThrows(EmptyStackException.class, stack::pop);
        }
    }
}
```

## 5.6 参数测试

参数化测试是 JUnit5 很重要的一个新特性，它使得用不同的参数多次运行测试成为了可能

利用**@ValueSource**等注解，指定入参，我们将可以使用不同的参数进行多次单元测试，而不需要每新增一个参数就新增一个单元测试，省去了很多冗余代码。

* @ValueSource：为参数化测试指定入参来源，支持八大基础类以及 String 类型、Class 类型

* @NullSource：表示为参数化测试提供一个 null 的入参

* @EnumSource：表示为参数化测试提供一个枚举入参

* @CsvFileSource：表示读取指定 CSV 文件内容作为参数化测试入参

* @MethodSource：表示读取指定方法的返回值作为参数化测试入参（注意方法返回需要是一个流）

```java
@ParameterizedTest
@ValueSource(strings = {"one", "two", "three"})
@DisplayName("参数化测试1")
public void parameterizedTest1(String string) {
    System.out.println(string);
    Assertions.assertTrue(StringUtils.isNotBlank(string));
}


@ParameterizedTest
@MethodSource("method")    //指定方法名
@DisplayName("方法来源参数")
public void testWithExplicitLocalMethodSource(String name) {
    System.out.println(name);
    Assertions.assertNotNull(name);
}

static Stream<String> method() {
    return Stream.of("apple", "banana");
}
```



# 6. 监控指标

## 6.1 Actuator

每一个微服务在云上部署以后，都需要对其进行监控、追踪、审计、控制等，SpringBoot 抽取了 Actuator 场景，使得每个微服务快速引用即可获得生产级别的应用监控、审计等功能

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```

暴露所有监控信息为 HTTP：

```yaml
management:
  endpoints:
    enabled-by-default: true #暴露所有端点信息
    web:
      exposure:
        include: '*'  #以web方式暴露
```

访问 http://localhost:8080/actuator/[beans/health/metrics/]

可视化界面：https://github.com/codecentric/spring-boot-admin

## 6.2 Endpoint

默认所有的 Endpoint 除过 shutdown 都是开启的

```yaml
management:
  endpoints:
    enabled-by-default: false	#禁用所有的
  endpoint:						#手动开启一部分
    beans:
      enabled: true
    health:
      enabled: true
```

端点：

| ID                 | 描述                                                         |
| ------------------ | ------------------------------------------------------------ |
| `auditevents`      | 暴露当前应用程序的审核事件信息。需要一个 `AuditEventRepository` 组件 |
| `beans`            | 显示应用程序中所有 Spring Bean 的完整列表                    |
| `caches`           | 暴露可用的缓存                                               |
| `conditions`       | 显示自动配置的所有条件信息，包括匹配或不匹配的原因           |
| `configprops`      | 显示所有 `@ConfigurationProperties`                          |
| `env`              | 暴露 Spring 的属性 `ConfigurableEnvironment`                 |
| `flyway`           | 显示已应用的所有 Flyway 数据库迁移。 需要一个或多个 Flyway 组件。 |
| `health`           | 显示应用程序运行状况信息                                     |
| `httptrace`        | 显示 HTTP 跟踪信息，默认情况下 100 个 HTTP 请求-响应需要一个 `HttpTraceRepository` 组件 |
| `info`             | 显示应用程序信息                                             |
| `integrationgraph` | 显示 Spring integrationgraph，需要依赖 `spring-integration-core` |
| `loggers`          | 显示和修改应用程序中日志的配置                               |
| `liquibase`        | 显示已应用的所有 Liquibase 数据库迁移，需要一个或多个 Liquibase 组件 |
| `metrics`          | 显示当前应用程序的指标信息。                                 |
| `mappings`         | 显示所有 `@RequestMapping` 路径列表                          |
| `scheduledtasks`   | 显示应用程序中的计划任务                                     |
| `sessions`         | 允许从 Spring Session 支持的会话存储中检索和删除用户会话，需要使用 Spring Session 的基于 Servlet 的 Web 应用程序 |
| `shutdown`         | 使应用程序正常关闭，默认禁用                                 |
| `startup`          | 显示由 `ApplicationStartup` 收集的启动步骤数据。需要使用 `SpringApplication` 进行配置 `BufferingApplicationStartup` |
| `threaddump`       | 执行线程转储                                                 |

应用程序是 Web 应用程序（Spring MVC，Spring WebFlux 或 Jersey），则可以使用以下附加端点：

| ID           | 描述                                                         |
| ------------ | ------------------------------------------------------------ |
| `heapdump`   | 返回 `hprof` 堆转储文件。                                    |
| `jolokia`    | 通过 HTTP 暴露 JMX bean（需要引入 Jolokia，不适用于 WebFlux），需要引入依赖 `jolokia-core` |
| `logfile`    | 返回日志文件的内容（如果已设置 `logging.file.name` 或 `logging.file.path` 属性），支持使用 HTTP Range标头来检索部分日志文件的内容。 |
| `prometheus` | 以 Prometheus 服务器可以抓取的格式公开指标，需要依赖 `micrometer-registry-prometheus` |

常用 Endpoint：

- Health：监控状况
- Metrics：运行时指标

- Loggers：日志记录





# 7. 项目部署

SpringBoot 项目开发完毕后，支持两种方式部署到服务器：

* jar 包 (官方推荐，默认)
* war 包

**更改 pom 文件中的打包方式为 war**

* 修改启动类

  ```java
  @SpringBootApplication
  public class SpringbootDeployApplication extends SpringBootServletInitializer {
      public static void main(String[] args) {
          SpringApplication.run(SpringbootDeployApplication.class, args);
      }
  
      @Override
      protected SpringApplicationBuilder configure(SpringApplicationBuilder b) {
          return b.sources(SpringbootDeployApplication.class);
      }
  }
  ```

* 指定打包的名称

  ```xml
  <packaging>war</packaging>
  <build>
       <finalName>springboot</finalName>
       <plugins>
           <plugin>
               <groupId>org.springframework.boot</groupId>
               <artifactId>spring-boot-maven-plugin</artifactId>
           </plugin>
       </plugins>
  </build>
  ```

