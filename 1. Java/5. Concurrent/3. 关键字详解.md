# 1. volatile

volatile定义：是JVM提供的最轻量级的同步机制，使用volatile主要是保证有序性 和 可见性

## 1.1 可见性

从表层来看，使用volatile的变量：

- 读取volatile变量是直接从主存中读取最新数据到工作内存，然后访问工作内存
- 写volatile变量是写入到工作内存后，立即写入到主内存中

从原理来看：是利用内存屏障

- volatile写变量的汇编指令会多上lock前缀，这个lock前缀可以保证将当前处理机行的数据写回到内存当中去
- 然后利用MESI协议保存缓存一致性

## 1.2 有序性

volatile保证有序性是通过禁用指令重排序来完成的。

从表层来说：

- 当程序执行到 `volatile` 变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；
- 在进行指令优化时，不能将在对 `volatile` 变量访问的语句放在其后面执行，也不能把 `volatile` 变量后面的语句放到其前面执行。

从原理来看：是通过内存屏障完成的

具体实现方式是在编译期生成字节码时，会在指令序列中增加内存屏障来保证，下面是基于保守策略的 JMM 内存屏障插入策略：

- 在每个 volatile 写操作的前面插入一个 StoreStore 屏障。 该屏障除了保证了屏障之前的写操作和该屏障之后的写操作不能重排序，还会保证了 volatile 写操作之前，任何的读写操作都会先于 volatile 被提交。
- 在每个 volatile 写操作的后面插入一个 StoreLoad 屏障。 该屏障除了使 volatile 写操作不会与之后的读操作重排序外，还会刷新处理器缓存，使 volatile 变量的写更新对其他线程可见。
- 在每个 volatile 读操作的前插入一个 LoadLoad 屏障。 该屏障除了使 volatile 读操作不会与之前的写操作发生重排序外，还会刷新处理器缓存，使 volatile 变量读取的为最新值。
- 在每个 volatile 读操作的后面插入一个 LoadStore 屏障。 该屏障除了禁止了 volatile 读操作与其之后的任何写操作进行重排序，还会刷新处理器缓存，使其他线程 volatile 变量的写更新对 volatile 读操作的线程可见。

## 1.3 原子性

- volatile不能保证完全的原子性，只能保证单次的读/写操作具有原子性。比如long / double, 因为他们都是64位，普通的long或double类型读/写可能不是原子的。可能先读高32位再读低32位。加了volatile以后可以保证单次读写的原子性

# 2. synchronized

## 2.1 使用

`synchronized`关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。

1. 修饰代码块
2. 加在方法上
   1. 非静态方法，锁对象为this
   2. 静态方法，锁对象为<类名>.class

## 2.2 原理分析

在Java中，`synchronized`有两种使用形式，同步方法和同步代码块。

对于同步方法，JVM采用`ACC_SYNCHRONIZED`标记符来实现同步。 对于同步代码块。JVM采用`monitorenter`、`monitorexit`两个指令来实现同步。

### 2.2.1 同步方法

1. 同步方法会有一个标识符`ACC_SYNCHRONIZED`
2. 当某个线程要访问某个方法的时候，会检查是否有`ACC_SYNCHRONIZED`
3. 如果有设置，则需要先获得Monitor锁，然后开始执行方法，方法执行之后再释放Monitor锁。
4. 这时如果其他线程来请求执行方法，会因为无法获得监视器锁而进入EntryList被BLOCK。

> 构造方法是同步的，但是没有ACC_SYNCHRONIZED访问标识

### 2.2.2 同步代码块

1. 同步代码块使用`monitorenter`和`monitorexit`两个指令实现。
2. 可以把执行`monitorenter`指令理解为加锁，执行`monitorexit`理解为释放锁。
3. 每个对象维护着一个记录着被锁次数的计数器。
4. 未被锁定的对象的该计数器为0，当一个线程获得锁（执行`monitorenter`）后，该计数器自增变为 1 ，当同一个线程再次获得该对象的锁的时候，计数器再次自增。
5. 当同一个线程释放锁（执行`monitorexit`指令）的时候，计数器再自减。
6. 当计数器为0的时候。锁将被释放，其他线程便可以获得锁。

### 2.2.3 Monitor

无论是`ACC_SYNCHRONIZED`还是`monitorenter`、`monitorexit`都是基于Monitor实现的，在Java虚拟机(HotSpot)中，Monitor是基于C++实现的，由ObjectMonitor实现。

ObjectMonitor中有几个关键属性：

> _owner：指向持有ObjectMonitor对象的线程
>
> _WaitSet：存放处于wait状态的线程队列
>
> _EntryList：存放处于等待锁block状态的线程队列
>
> _recursions：锁的重入次数
>
> _count：用来记录该线程获取锁的次数

当多个线程同时访问一段同步代码时，首先会进入`_EntryList`队列中，当某个线程获取到对象的monitor后进入`_Owner`区域并把monitor中的`_owner`变量设置为当前线程，同时monitor中的计数器`_count`加1。即获得对象锁。

若持有monitor的线程调用`wait()`方法，将释放当前持有的monitor，`_owner`变量恢复为`null`，`_count`自减1，同时该线程进入`_WaitSet`集合中等待被唤醒。若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor

## 2.3 锁优化

1. 简单来说在JVM中monitorenter和monitorexit字节码依赖于底层的操作系统的Mutex Lock来实现的，但是由于使用Mutex Lock需要将当前线程挂起并从用户态切换到内核态来执行，这种切换的代价是非常昂贵的；
2. 然而在现实中的大部分情况下，同步方法是运行在单线程环境(无锁竞争环境)如果每次都调用Mutex Lock那么将严重的影响程序的性能。
3. **不过在jdk1.6中对锁的实现引入了大量的优化，如锁粗化(Lock Coarsening)、锁消除(Lock Elimination)、轻量级锁(Lightweight Locking)、偏向锁(Biased Locking)、适应性自旋(Adaptive Spinning)等技术来减少锁操作的开销**。

- `锁粗化(Lock Coarsening)`：也就是减少不必要的紧连在一起的unlock，lock操作，将多个连续的锁扩展成一个范围更大的锁。
- `锁消除(Lock Elimination)`：通过运行时JIT编译器的逃逸分析来消除一些没有在当前同步块以外被其他线程共享的数据的锁保护，通过逃逸分析也可以在线程本地Stack上进行对象空间的分配(同时还可以减少Heap上的垃圾收集开销)。
- `轻量级锁(Lightweight Locking)`：这种锁实现的背后基于这样一种假设，即在真实的情况下我们程序中的大部分同步代码一般都处于无锁竞争状态(即单线程执行环境)，在无锁竞争的情况下完全可以避免调用操作系统层面的重量级互斥锁，取而代之的是在monitorenter和monitorexit中只需要依靠一条CAS原子指令就可以完成锁的获取及释放。当存在锁竞争的情况下，执行CAS指令失败的线程将调用操作系统互斥锁进入到阻塞状态，当锁被释放的时候被唤醒(具体处理步骤下面详细讨论)。
- `偏向锁(Biased Locking)`：是为了在无锁竞争的情况下避免在锁获取过程中执行不必要的CAS原子指令，因为CAS原子指令虽然相对于重量级锁来说开销比较小但还是存在非常可观的本地延迟。
- `适应性自旋(Adaptive Spinning)`：当线程在获取轻量级锁的过程中执行CAS操作失败时，在进入与monitor相关联的操作系统重量级锁(mutex semaphore)前会进入忙等待(Spinning)然后再次尝试，当尝试一定的次数后如果仍然没有成功则调用与该monitor关联的semaphore(即互斥锁)进入到阻塞状态。

### 2.3.1 锁的类型

在Java SE 1.6里Synchronied同步锁，一共有四种状态：`无锁`、`偏向锁`、`轻量级所`、`重量级锁`，它会随着竞争情况逐渐升级。锁可以升级但是不可以降级，目的是为了提供获取锁和释放锁的效率。

> 锁膨胀方向： 无锁 → 偏向锁 → 轻量级锁 → 重量级锁 (此过程是不可逆的)

### 2.3.2 锁消除

1. 锁消除是指JIT编译器在运行时，通过逃逸分析发现有些代码上添加了同步synchronized，但是通过检测发现不可能出现共享数据的竞争的情况。因此就会进行锁销除的操作
2. 在Java API中有很多方法都是加了同步的，那么此时JVM会判断这段代码是否需要加锁。如果数据并不会逃逸，则会进行锁消除。
3. 比如如下操作：在操作String类型数据时，由于String是一个不可变类，对字符串的连接操作总是通过生成的新的String对象来进行的。因此Javac编译器会对String连接做自动优化。在JDK 1.5之前会使用StringBuffer对象的连续append()操作，在JDK 1.5及以后的版本中，会转化为StringBuidler对象的连续append()操作。

### 2.3.3 锁粗化

1. 原则上，我们都知道在加同步锁时，尽可能的将同步块的作用范围限制到尽量小的范围(只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小。在存在锁同步竞争中，也可以使得等待锁的线程尽早的拿到锁)。
2. 大部分上述情况是完美正确的，但是如果存在连串的一系列操作都对同一个对象反复加锁和解锁，甚至加锁操作时出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要地性能操作。

### 2.3.4 偏向锁

#### 1.3.4.2 批量重定向

> 批量重偏向：当一个线程创建了大量对象并执行了初始的同步操作，后来另一个线程也来将这些对象作为锁对象进行操作，会导偏向锁重偏向的操作。
>
> 批量撤销：在多线程竞争剧烈的情况下，使用偏向锁将会降低效率，于是乎产生了批量撤销机制。

如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象的 Thread ID.

- 前19个会进行从偏向t1的`偏向锁`，遇到synchronized以后`撤销偏向锁`，变成`轻量级锁`，synchronized结束以后变成`normal`。

- 当撤销偏向锁阈值达到 20 次后，jvm 会这样觉得，我是不是偏向错了呢，于是会在给这些对象加锁时重新偏向至加锁线程

- 之后该线程的对象，遇到synchronized以后都会直接从指向t1的偏向锁 变成指向t2的偏向锁

```java
private static void test3() throws InterruptedException {
    Vector<Dog> list = new Vector<>();
    Thread t1 = new Thread(() -> {
        for (int i = 0; i < 30; i++) {
            Dog d = new Dog();
            list.add(d);
            synchronized (d) {
                log.debug(i + "\t" + ClassLayout.parseInstance(d).toPrintableSimple(true));
            }
        }
        synchronized (list) {
            list.notify();
        }
    }, "t1");
    t1.start();
    Thread t2 = new Thread(() -> {
        synchronized (list) {
            try {
                list.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        log.debug("===============> ");
        for (int i = 0; i < 30; i++) {
            Dog d = list.get(i);
            log.debug(i + "\t" + ClassLayout.parseInstance(d).toPrintableSimple(true));
            synchronized (d) {
                log.debug(i + "\t" + ClassLayout.parseInstance(d).toPrintableSimple(true));
            }
            log.debug(i + "\t" + ClassLayout.parseInstance(d).toPrintableSimple(true));
        }
    }, "t2");
    t2.start();
}
```

输出

```java
[t1] - 0 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101
[t1] - 1 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101
[t1] - 2 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101
[t1] - 3 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101
[t1] - 4 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101
[t1] - 5 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101
[t1] - 6 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101
[t1] - 7 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101
[t1] - 8 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101
[t1] - 9 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101
[t1] - 10 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101
[t1] - 11 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101
[t1] - 12 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101
[t1] - 13 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101
[t1] - 14 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101
[t1] - 15 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101
[t1] - 16 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101
[t1] - 17 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101
[t1] - 18 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101
[t1] - 19 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101
[t1] - 20 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101
[t1] - 21 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101
[t1] - 22 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101
[t1] - 23 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101
[t1] - 24 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101
[t1] - 25 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101
[t1] - 26 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101
[t1] - 27 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101
[t1] - 28 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101
[t1] - 29 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101
[t2] - ===============>
[t2] - 0 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101
[t2] - 0 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000
[t2] - 0 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001
[t2] - 1 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101
[t2] - 1 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000
[t2] - 1 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001
[t2] - 2 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101
[t2] - 2 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000
[t2] - 2 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001
[t2] - 3 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101
[t2] - 3 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000
[t2] - 3 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001
[t2] - 4 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101
[t2] - 4 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000
[t2] - 4 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001
[t2] - 5 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101
[t2] - 5 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000
[t2] - 5 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001
[t2] - 6 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101
[t2] - 6 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000
[t2] - 6 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001
[t2] - 7 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101
[t2] - 7 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000
[t2] - 7 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001
[t2] - 8 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101
[t2] - 8 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000
[t2] - 8 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001
[t2] - 9 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101
[t2] - 9 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000
[t2] - 9 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001
[t2] - 10 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101
[t2] - 10 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000
[t2] - 10 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001
[t2] - 11 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101
[t2] - 11 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000
[t2] - 11 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001
[t2] - 12 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101
[t2] - 12 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000
[t2] - 12 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001
[t2] - 13 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101
[t2] - 13 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000
[t2] - 13 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001
[t2] - 14 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101
[t2] - 14 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000
[t2] - 14 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001
[t2] - 15 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101
[t2] - 15 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000
[t2] - 15 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001
[t2] - 16 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101
[t2] - 16 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000
[t2] - 16 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001
[t2] - 17 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101
[t2] - 17 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000
[t2] - 17 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001
[t2] - 18 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101
[t2] - 18 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000
[t2] - 18 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001
[t2] - 19 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101
[t2] - 19 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101
[t2] - 19 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101
[t2] - 20 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101
[t2] - 20 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101
[t2] - 20 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101
[t2] - 21 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101
[t2] - 21 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101
[t2] - 21 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101
[t2] - 22 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101
[t2] - 22 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101
[t2] - 22 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101
[t2] - 23 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101
[t2] - 23 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101
[t2] - 23 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101
[t2] - 24 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101
[t2] - 24 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101
[t2] - 24 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101

[t2] - 25 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101
[t2] - 25 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101
[t2] - 25 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101
[t2] - 26 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101
[t2] - 26 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101
[t2] - 26 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101
[t2] - 27 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101
[t2] - 27 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101
[t2] - 27 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101
[t2] - 28 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101
[t2] - 28 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101
[t2] - 28 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101
[t2] - 29 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101
[t2] - 29 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101
[t2] - 29 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101
```

#### 1.3.4.3 批量撤销

当撤销偏向锁阈值超过 40 次后，jvm 会这样觉得，自己确实偏向错了，根本就不该偏向。于是`整个类的所有对象`都会变为不可偏向的，新建的对象也是不可偏向的。

```java
static Thread t1,t2,t3;
private static void test4() throws InterruptedException {
    Vector<Dog> list = new Vector<>();
    int loopNumber = 39;
    t1 = new Thread(() -> {
        for (int i = 0; i < loopNumber; i++) {
            Dog d = new Dog();
            list.add(d);
            synchronized (d) {
                log.debug(i + "\t" + ClassLayout.parseInstance(d).toPrintableSimple(true));
            }
        }
        LockSupport.unpark(t2);
    }, "t1");
    t1.start();
    t2 = new Thread(() -> {
        LockSupport.park();
        log.debug("===============> ");
        for (int i = 0; i < loopNumber; i++) {
            Dog d = list.get(i);
            log.debug(i + "\t" + ClassLayout.parseInstance(d).toPrintableSimple(true));
            synchronized (d) {
                log.debug(i + "\t" + ClassLayout.parseInstance(d).toPrintableSimple(true));
            }
            log.debug(i + "\t" + ClassLayout.parseInstance(d).toPrintableSimple(true));
        }
        LockSupport.unpark(t3);
    }, "t2");
    t2.start();
    t3 = new Thread(() -> {
        LockSupport.park();
        log.debug("===============> ");
        for (int i = 0; i < loopNumber; i++) {
            Dog d = list.get(i);
            log.debug(i + "\t" + ClassLayout.parseInstance(d).toPrintableSimple(true));
            synchronized (d) {
                log.debug(i + "\t" + ClassLayout.parseInstance(d).toPrintableSimple(true));
            }
            log.debug(i + "\t" + ClassLayout.parseInstance(d).toPrintableSimple(true));
        }
    }, "t3");
    t3.start();
    t3.join();
    log.debug(ClassLayout.parseInstance(new Dog()).toPrintableSimple(true));
}	
```

![image-20210711201428506](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/image-20210711201428506.png)

![image-20210712190925821](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/image-20210712190925821.png)

![image-20210712190910593](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/image-20210712190910593.png)



![image-20210712190854805](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/image-20210712190854805.png)

![image-20210712190834527](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/image-20210712190834527.png)

![image-20210713000504366](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/image-20210713000504366.png)

在上述中

1. t1线程的锁对象全部偏向t1
2. t2线程中
   1. 0-18会发生偏向锁撤销，变为轻量级锁，在变为normal
   2. 19-38因为达到了20次，所以会重定向为 偏向`t2`
3. t3线程中
   1. 0-18原本是normal，遇到synchronized变为轻量级锁，之后再为normal。
   2. 19-38会发生偏向锁撤销，变为轻量级锁，在变为normal

所以上述中，0-18，19-38分别在t2，t3进行了`偏向锁撤销`，所以当第40次的时候新建的类是不可偏向的，也就新建的对象的是normal

![image-20210711201942306](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/image-20210711201942306.png)

### 2.3.5 轻量级锁

轻量级锁的使用场景是：如果一个对象虽然有多个线程要对它进行加锁，但是加锁的时间是错开的（也就是没有人可以竞争的），那么可以使用轻量级锁来进行优化。

每次指向到synchronized代码块时，都会在每个线程的栈帧中创建锁记录（Lock Record）对象，锁对象可以记录对象的引用和对象的Mark Word。

1. 让锁记录中的Object reference指向对象，并且尝试用cas(compare and sweep)替换Object对象的Mark Word ，将Mark Word 的值存入锁记录。
2. 如果cas替换成功，那么对象的对象头储存的就是`锁记录的地址和状态00`
3. 如果cas失败，有两种情况
   1. 如果是其它线程已经持有了该Object的轻量级锁，那么表示有竞争，将进入锁膨胀阶段
   2. 如果是自己的线程已经执行了synchronized进行加锁，那么那么再添加一条 Lock Record 作为重入的计数，这时候原本存放Mark Word的地方存放null
4. 当线程退出synchronized代码块的时候，**如果获取的是取值为 null 的锁记录 **，表示有重入，这时重置锁记录，表示重入计数减一
5. 当线程退出synchronized代码块的时候，如果获取的锁记录取值不为 null，那么使用cas将Mark Word的值恢复给对象
   1. 成功则解锁成功
   2. 失败，则说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程

### 2.3.6 自旋锁

背景：大多数线程拥有锁对象的时间都很少，为了这段时间去挂起然后恢复阻塞线程(涉及到用户态和内核态的切换)是得不偿失的。所以可以让线程进行自旋

缺点

- 如果锁占用的时间很短，那么自旋锁的性能会很好
- 但是如果占用的时间很长，那么反而会带来更多的性能损耗
- 所以从1.6开始自旋锁的自旋时间是自适应的，根据由前一次在同一个锁上的自旋 时间及锁的拥有者的状态来决定的。
  - 如果某个锁自旋很少成功，那么就可能会省略自旋过程
  - 如果自旋成功高，那么就可能会增加等待时间

## 2.6 原子性的支持

1. 原子性是指一个操作是不可中断的，要全部执行完成，要不就都不执行，中间不会被打断
2. 被`synchronized`修饰的代码在同一时间只能被一个线程访问，在锁未释放之前，无法被其他线程访问到。即使CPU时间片用完了，但是并不会释放锁，因为支持可重入，下一次该线程仍然可以获取到该锁
3. 因此，在Java中可以使用`synchronized`来保证方法和代码块内的操作是原子性的。

## 2.7 可见性的支持

1. 可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。
2. 在`Java内存模型`中，synchronized规定，线程在加锁时， `先清空工作内存 → 在主内存中拷贝最新变量的副本到工作内存 → 执行完代码 → 将更改后的共享变量的值刷新到主内存中 → 释放互斥锁。`

## 2.8 有序性的支持

1. `synchronized`是无法禁止指令重排和处理器优化的。
2. 由于`synchronized`修饰的代码，同一时间只能被同一线程访问。那么也就是单线程执行的。所以，可以保证其有序性。
3. 这里面是有条件的，在synchronized代码块中的共享变量, 不会在代码块外使用到, 否则`有序性`不能被保证, 只能使用volatile来保证有序性。（详情可见双重检查机制）

# 3. ThreadLocal

## 3.1 什么是ThreadLocal

1. 实现线程安全的三种思路分别是互斥同步，非阻塞同步，无同步方案
1. 而ThreadLocal就是通过无同步方案来实现线程安全的。

## 3.2 ThreadLocal的数据结构

1. `Thread` 类有一个`ThreadLocal.ThreadLocalMap` 的实例变量 `threadLocals`，也就是说每个线程有一个自己的`ThreadLocalMap`。
2. 而这个`ThreadLocalMap`是`ThreadLocal`类的一个静态内部类
3. `ThreadLocalMap`的主要属性就是一个`Entry`类型的数组
4. 这个Entry继承自`WeakReference`,内部还有一个属性value，因此可以确定这是一个以ThreadLocal的弱引用为key，传入的值为value的k-v结构。
5. 每个线程在往`ThreadLocal`里放值的时候，其实都是把一个以`ThreadLocal的弱引用`为key，值为value的`Entr`y放入到`ThreadLocalMap`的数组里面。
6. 每次拿的时候我们也是以`ThreadLocal`作为key来获取value。
7. 而ThrealLocalMap是线程私有的，从而实现了线程隔离

![img](data:image/png;base64,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)

## 3.3 类的属性

Thread的属性

```java
ThreadLocal.ThreadLocalMap threadLocals = null;
```

### 3.3.1 ThreadLocalMap的属性

```java
// 初始化当前 map 内部散列表数组的初始长度 16
private static final int INITIAL_CAPACITY = 16;

// 存放数据的table，数组长度必须是2的整次幂。
private Entry[] table;

// 数组里面 entrys 的个数，可以用于判断 table 当前使用量是否超过阈值
private int size = 0;

// 进行扩容的阈值，表使用量大于它的时候进行扩容。
private int threshold;
```

```java
static class ThreadLocalMap {
    static class Entry extends WeakReference<ThreadLocal<?>> {
        /** The value associated with this ThreadLocal. */
        Object value;

        Entry(ThreadLocal<?> k, Object v) {
            super(k);
            value = v;
        }
    }
```

### 3.3.2 ThreadLocal的属性

```java
private final int threadLocalHashCode = nextHashCode();
private static AtomicInteger nextHashCode = new AtomicInteger();
private static final int HASH_INCREMENT = 0x61c88647;
```

## 3.4 源码解读

### 3.4.1 set

1. 通过当前线程获取ThreadLocalMap
2. 如果map ！= null，则
3. 如果map == null，则创建一个ThreadLocalMap，然后将ThreadLocal的弱引用和value作为传入的第一个结点

```java
// ThreadLocal的Set方法
public void set(T value) {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value);
}
```

- 如果 map == null的情况。则调用ThreadLocalMap的构造方法，初始化一个数组，然后计算hash和对应的index

```java
void createMap(Thread t, T firstValue) {
    t.threadLocals = new ThreadLocalMap(this, firstValue);
}
ThreadLocalMap(ThreadLocal<?> firstKey, Object firstValue) {
    // 初始化table，创建一个长度为16的Entry数组
    table = new Entry[INITIAL_CAPACITY];
    // 【寻址算法】计算索引
    int i = firstKey.threadLocalHashCode & (INITIAL_CAPACITY - 1);
    // 创建 entry 对象，存放到指定位置的 slot 中
    table[i] = new Entry(firstKey, firstValue);
    // 数据总量是 1
    size = 1;
    // 将阈值设置为 （当前数组长度 * 2）/ 3。
    setThreshold(INITIAL_CAPACITY);
}
```

- 如果map ！= null，当哈希冲突的时候，采用线性探测法

```java
private void set(ThreadLocal<?> key, Object value) {
    // 获取散列表
    ThreadLocal.ThreadLocalMap.Entry[] tab = table;
    int len = tab.length;
    // 哈希寻址
    int i = key.threadLocalHashCode & (len-1);
    // 使用线性探测法向后查找元素，碰到 entry 为空时停止探测
    for (ThreadLocal.ThreadLocalMap.Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) {
        // 获取当前元素 key
        ThreadLocal<?> k = e.get();
        // ThreadLocal 对应的 key 存在，【直接覆盖之前的值】
        if (k == key) {
            e.value = value;
            return;
        }
        // 【这两个条件谁先成立不一定，所以 replaceStaleEntry 中还需要判断 k == key 的情况】
        
        // key 为 null，但是值不为 null，说明之前的 ThreadLocal 对象已经被回收了，当前是【过期数据】
        if (k == null) {
            // 【碰到一个过期的 slot，当前数据复用该槽位，替换过期数据】
            // 这个方法还进行了垃圾清理动作，防止内存泄漏
            replaceStaleEntry(key, value, i);
            return;
        }
    }
	// 逻辑到这说明碰到 slot == null 的位置，则在空元素的位置创建一个新的 Entry
    tab[i] = new Entry(key, value);
    // 数量 + 1
    int sz = ++size;
    
    // 【做一次启发式清理】，如果没有清除任何 entry 并且【当前使用量达到了负载因子所定义，那么进行 rehash
    if (!cleanSomeSlots(i, sz) && sz >= threshold)
        // 扩容
        rehash();
}
```

```java
// 在指定位置插入指定的数据
private void replaceStaleEntry(ThreadLocal<?> key, Object value, int staleSlot) {
    // 获取散列表
    Entry[] tab = table;
    int len = tab.length;
    Entry e;
	// 探测式清理的开始下标，默认从当前 staleSlot 开始
    int slotToExpunge = staleSlot;
    // 以当前 staleSlot 开始【向前迭代查找】，找到索引靠前过期数据，找到以后替换 slotToExpunge 值
    // 【保证在一个区间段内，从最前面的过期数据开始清理】
    for (int i = prevIndex(staleSlot, len); (e = tab[i]) != null; i = prevIndex(i, len))
        if (e.get() == null)
            slotToExpunge = i;

	// 以 staleSlot 【向后去查找】，直到碰到 null 为止，还是线性探测
    for (int i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) {
        // 获取当前节点的 key
        ThreadLocal<?> k = e.get();
		// 条件成立说明是【替换逻辑】
        if (k == key) {
            e.value = value;
            // 因为本来要在 staleSlot 索引处插入该数据，现在找到了i索引处的key与数据一致
            // 但是 i 位置距离正确的位置更远，因为是向后查找，所以还是要在 staleSlot 位置插入当前 entry
            // 然后将 table[staleSlot] 这个过期数据放到当前循环到的 table[i] 这个位置，
            tab[i] = tab[staleSlot];
            tab[staleSlot] = e;
			
            // 条件成立说明向前查找过期数据并未找到过期的 entry，但 staleSlot 位置已经不是过期数据了，i 位置才是
            if (slotToExpunge == staleSlot)
                slotToExpunge = i;
            
            // 【清理过期数据，expungeStaleEntry 探测式清理，cleanSomeSlots 启发式清理】
            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);
            return;
        }
		// 条件成立说明当前遍历的 entry 是一个过期数据，并且该位置前面也没有过期数据
        if (k == null && slotToExpunge == staleSlot)
            // 探测式清理过期数据的开始下标修改为当前循环的 index，因为 staleSlot 会放入要添加的数据
            slotToExpunge = i;
    }
	// 向后查找过程中并未发现 k == key 的 entry，说明当前是一个【取代过期数据逻辑】
    // 删除原有的数据引用，防止内存泄露
    tab[staleSlot].value = null;
    // staleSlot 位置添加数据，【上面的所有逻辑都不会更改 staleSlot 的值】
    tab[staleSlot] = new Entry(key, value);

    // 条件成立说明除了 staleSlot 以外，还发现其它的过期 slot，所以要【开启清理数据的逻辑】
    if (slotToExpunge != staleSlot)
        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);
}
```

### 3.4.2 get

```java
public T get() {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        ThreadLocalMap.Entry e = map.getEntry(this);
        if (e != null) {
            @SuppressWarnings("unchecked")
            T result = (T)e.value;
            return result;
        }
    }
    return setInitialValue();
}
```

- 如果 map ！= null, 我们就通过ThreadLocal作为key找到value

```java
private Entry getEntry(ThreadLocal<?> key) {
    int i = key.threadLocalHashCode & (table.length - 1);
    Entry e = table[i];
    if (e != null && e.get() == key)
        return e;
    else
        return getEntryAfterMiss(key, i, e);
}
private Entry getEntryAfterMiss(ThreadLocal<?> key, int i, Entry e) {
    Entry[] tab = table;
    int len = tab.length;

    while (e != null) {
        ThreadLocal<?> k = e.get();
        if (k == key)
            return e;
        if (k == null)
            expungeStaleEntry(i);
        else
            i = nextIndex(i, len);
        e = tab[i];
    }
    return null;
}
```

- 如果map == null的话 或者 没找到value

```java
private T setInitialValue() {
    T value = initialValue();
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value);
    return value;
}
```

### 3.4.3 remove

```java
public void remove() {
    // 获取当前线程对象中维护的 ThreadLocalMap 对象
    ThreadLocalMap m = getMap(Thread.currentThread());
    if (m != null)
        // map 存在则调用 map.remove，this时当前ThreadLocal，以this为key删除对应的实体
        m.remove(this);
}
```

```java
private void remove(ThreadLocal<?> key) {
    Entry[] tab = table;
    int len = tab.length;
    int i = key.threadLocalHashCode & (len-1);
    for (Entry e = tab[i];
         e != null;
         e = tab[i = nextIndex(i, len)]) {
        if (e.get() == key) {
            e.clear();
            expungeStaleEntry(i);
            return;
        }
    }
}
public void clear() {
    this.referent = null;
}
```

### 3.4.4 nextHashCode

1. 我们维护了一个原子整型每当创建一个`ThreadLocal`对象，这个`ThreadLocal.nextHashCode` 这个值就会增长 `0x61c88647` 。

2. 这个值很特殊，它是**斐波那契数** 也叫 **黄金分割数**。

```java
private static AtomicInteger nextHashCode =
    new AtomicInteger();
private static int nextHashCode() {
    return nextHashCode.getAndAdd(HASH_INCREMENT);
}
```

### 3.4.5 扩容

如果执行完启发式清理工作后，未清理到任何数据，且当前散列数组中`Entry`的数量已经达到了列表的扩容阈值`(len*2/3)`，就开始执行`rehash()`逻辑：

```java
if (!cleanSomeSlots(i, sz) && sz >= threshold)
    rehash();
```

1. 进行探测式清理工作
2. 判断`size >= threshold * 3/4` 来决定是否扩容。

> 我们还记得上面进行`rehash()`的阈值是`size >= threshold`，所以当面试官套路我们`ThreadLocalMap`扩容机制的时候 我们一定要说清楚这两个步骤：

```java
private void rehash() {
    expungeStaleEntries();

    if (size >= threshold - threshold / 4)
        resize();
}

private void expungeStaleEntries() {
    Entry[] tab = table;
    int len = tab.length;
    for (int j = 0; j < len; j++) {
        Entry e = tab[j];
        if (e != null && e.get() == null)
            expungeStaleEntry(j);
    }
}

```

1. 生成一个新的数组，容量为原来的两倍
2. 遍历原数组

- 如果key为null，则我们将value也设置为null
- 计算hash求的index，如果冲突了就线性探测，一直加1，知道新数组的对应索引位置上没有元素，然后添加进去

```java
private void resize() {
    Entry[] oldTab = table;
    int oldLen = oldTab.length;
    int newLen = oldLen * 2;
    Entry[] newTab = new Entry[newLen];
    int count = 0;

    for (int j = 0; j < oldLen; ++j) {
        Entry e = oldTab[j];
        if (e != null) {
            ThreadLocal<?> k = e.get();
            if (k == null) {
                e.value = null; // Help the GC
            } else {
                int h = k.threadLocalHashCode & (newLen - 1);
                while (newTab[h] != null)
                    h = nextIndex(h, newLen);
                newTab[h] = e;
                count++;
            }
        }
    }

    setThreshold(newLen);
    size = count;
    table = newTab;
}
```

### 3.4.6 清理工作

#### I **探测式清理**

探测式清理：沿着开始位置向后探测清理过期数据，沿途中碰到未过期数据则将此数据 rehash 在 table 数组中的定位，重定位后的元素理论上更接近 `i = entry.key & (table.length - 1)`，让**数据的排列更紧凑**，会优化整个散列表查询性能

```java
// table[staleSlot] 是一个过期数据，以这个位置开始继续向后查找过期数据
private int expungeStaleEntry(int staleSlot) {
    // 获取散列表和数组长度
    Entry[] tab = table;
    int len = tab.length;

    // help gc，先把当前过期的 entry 置空，在取消对 entry 的引用
    tab[staleSlot].value = null;
    tab[staleSlot] = null;
    // 数量-1
    size--;

    Entry e;
    int i;
    // 从 staleSlot 开始向后遍历，直到碰到 slot == null 结束，【区间内清理过期数据】
    for (i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) {
        ThreadLocal<?> k = e.get();
        // 当前 entry 是过期数据
        if (k == null) {
            // help gc
            e.value = null;
            tab[i] = null;
            size--;
        } else {
            // 当前 entry 不是过期数据的逻辑
            // 重新计算当前 entry 对应的 index
            int h = k.threadLocalHashCode & (len - 1);
            // 条件成立说明当前 entry 存储时发生过 hash 冲突，向后偏移过了
            if (h != i) {
                // 当前位置置空
                tab[i] = null;
                // 以正确位置 h 开始，向后查找第一个可以存放 entry 的位置
                while (tab[h] != null)
                    h = nextIndex(h, len);
                // 将当前元素放入到【距离正确位置更近的位置，有可能就是正确位置】
                tab[h] = e;
            }
        }
    }
    // 返回 slot = null 的槽位索引，图例是 7，这个索引代表【索引前面的区间已经清理完成垃圾了】
    return i;
}
```



#### II **启发式清理**

```java
//  i 表示启发式清理工作开始位置，一般是空 slot，n 一般传递的是 table.length 
private boolean cleanSomeSlots(int i, int n) {
    // 表示启发式清理工作是否清除了过期数据
    boolean removed = false;
    // 获取当前 map 的散列表引用
    Entry[] tab = table;
    int len = tab.length;
    do {
        // 获取下一个索引，因为探测式返回的 slot 为 null
        i = nextIndex(i, len);
        Entry e = tab[i];
        // 条件成立说明是过期的数据，key 被 gc 了
        if (e != null && e.get() == null) {
            // 【发现过期数据重置 n 为数组的长度】
            n = len;
            // 表示清理过过期数据
            removed = true;
            // 以当前过期的 slot 为开始节点 做一次探测式清理工作
            i = expungeStaleEntry(i);
        }
        // 假设 table 长度为 16
        // 16 >>> 1 ==> 8，8 >>> 1 ==> 4，4 >>> 1 ==> 2，2 >>> 1 ==> 1，1 >>> 1 ==> 0
        // 连续经过这么多次循环【没有扫描到过期数据】，就停止循环，扫描到空 slot 不算，因为不是过期数据
    } while ((n >>>= 1) != 0);
    
    // 返回清除标记
    return removed;
}
```

## 3.5 内存泄漏问题

为什么ThreadLocalMap的key要使用弱引用

- 若使用强引用，那么当ThreadLocal使用完后，虚拟机栈中对ThreadLocal的引用会被回收；但是因为ThreadLocalMap的Entry中的key仍然持有ThreadLocal的强引用，导致ThreadLocal无法被回收，导致了内存泄漏问题；如果使用若引用的话，那么key可以被回收

导致ThreadLocal内存泄漏的原因：

- 因为ThreadLocalMap的生命周期和Thread一样长，所以就会一直持有Entry中value的引用，如果步手动remove对应的Entry的话，那么久会导致内存泄漏问题。

既然使用弱引用无法避免内存泄漏，那么为什么还是要使用弱引用

- 因为使用弱引用以后，使用完ThreadLocal就会将其回收，从而Entry的key = null。而ThreadLocalMap的set/get方法中，会有一种优化：如果key为null的话，那么会将对应的value设置为null
- 这样就算我们忘记remove了，那么当调用ThreadLocalMap的get/set方法时，仍会将对应的Entry清除，从而避免内存泄漏

![image-20220212145445727](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/image-20220212145445727.png)



## 3.6 InheritableThreadLocal

我们使用`ThreadLocal`的时候，在异步场景下是无法给子线程共享父线程中创建的线程副本数据的。

为了解决这个问题，JDK 中还有一个`InheritableThreadLocal`类，我们来看一个例子：

```java
public class InheritableThreadLocalDemo {
    public static void main(String[] args) {
        ThreadLocal<String> ThreadLocal = new ThreadLocal<>();
        ThreadLocal<String> inheritableThreadLocal = new InheritableThreadLocal<>();
        ThreadLocal.set("父类数据:threadLocal");
        inheritableThreadLocal.set("父类数据:inheritableThreadLocal");

        new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("子线程获取父类ThreadLocal数据：" + ThreadLocal.get());
                System.out.println("子线程获取父类inheritableThreadLocal数据：" + inheritableThreadLocal.get());
            }
        }).start();
    }
}
```

打印结果：

```java
子线程获取父类ThreadLocal数据：null
子线程获取父类inheritableThreadLocal数据：父类数据:inheritableThreadLocal
```

---

InheritableThreadLocal 源码：

```java
public class InheritableThreadLocal<T> extends ThreadLocal<T> {
    protected T childValue(T parentValue) {
        return parentValue;
    }
    ThreadLocalMap getMap(Thread t) {
       return t.inheritableThreadLocals;
    }
    void createMap(Thread t, T firstValue) {
        t.inheritableThreadLocals = new ThreadLocalMap(this, firstValue);
    }
}
```

实现父子线程间的局部变量共享需要追溯到 Thread 对象的构造方法：

```java
private void init(ThreadGroup g, Runnable target, String name, long stackSize, AccessControlContext acc,
                  // 该参数默认是 true
                  boolean inheritThreadLocals) {
  	// ...
    Thread parent = currentThread();

    // 判断父线程（创建子线程的线程）的 inheritableThreadLocals 属性不为 null
    if (inheritThreadLocals && parent.inheritableThreadLocals != null) {
        // 复制父线程的 inheritableThreadLocals 属性，实现父子线程局部变量共享
        this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals); 
    }
    // ..
}
// 【本质上还是创建 ThreadLocalMap，只是把父类中的可继承数据设置进去了】
static ThreadLocalMap createInheritedMap(ThreadLocalMap parentMap) {
    return new ThreadLocalMap(parentMap);
}
```

```java
private ThreadLocalMap(ThreadLocalMap parentMap) {
    // 获取父线程的哈希表
    Entry[] parentTable = parentMap.table;
    int len = parentTable.length;
    setThreshold(len);
    table = new Entry[len];
	// 【逐个复制父线程 ThreadLocalMap 中的数据】
    for (int j = 0; j < len; j++) {
        Entry e = parentTable[j];
        if (e != null) {
            ThreadLocal<Object> key = (ThreadLocal<Object>) e.get();
            if (key != null) {
                // 调用的是 InheritableThreadLocal#childValue(T parentValue)
                Object value = key.childValue(e.value);
                Entry c = new Entry(key, value);
                int h = key.threadLocalHashCode & (len - 1);
                // 线性探测
                while (table[h] != null)
                    h = nextIndex(h, len);
                table[h] = c;
                size++;
            }
        }
    }
}
```

## 3.7 使用

用途

- 线程间数据隔离
- 保存线程上下文信息，用ThreadLocal存储Connection，从而各个DAO可以获取同一Connection。
- 实现线程安全，因为数据是线程私有的，所有自然不会导致竞争问题，从而避免了同步带来的损失

局限性：

- 无法解决共享对象的更新问题

使用建议：

- 一般设置ThreadLocal为static类型，从而该线程的所有实例共享该变量
