方法调用的概念：确定被调方法的版本，不涉及方法的运行；（可以认为是将符号引用转化为直接引用）。

非虚方法：private，static，final，super.方法，构造器方法；

方法调用的指令：

- invokestatic：调用静态方法，解析阶段确定唯一方法版本
- invokespecial：调用`<init>`方法、私有及父类方法，解析阶段确定唯一方法版本
- invokevirtual：调用所有虚方法，包括了final方法，但是final方法是非虚方法
- invokeinterface：调用接口方法



将方法的符号引用转化位直接引用主要有两种情况： 解析 和 分派

- 解析: 方法的版本是编译器可知，运行期不变的；也就是非虚方法；类加载阶段将符号引用转化为直接引用
- 分派：有静态分派和动态分派

静态分派：重载，编译器可定

动态分派：重写，其中确定版本的流程如下

- 找到操作数栈顶的第一个元素所执行的对象的**实际类型**，记作C。

- 如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则确定了版本

- 否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。

  如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。

虚方法表：虚方法表是动态分派的实现

- 每次都使用动态分派的话，十分影响性能，所以在方法区建立虚方法表来进行优化，使用索引来查找版本
- 虚方法表是在链接阶段开始创建，初始化后建立完成
- 特点：具有相同签名的方法，在父类和子类的虚方法表中都应当具有一样的索引序号；索引指向相关类Class对象相应的方法信息上

![这里写图片描述](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/823435-20170514185548363-901763715.png)

静态类型的作用：

- Java的类型检查机制是静态类型检查 
- 规定了引用能够访问内存空间的大小

