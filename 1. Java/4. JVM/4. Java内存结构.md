Java虚拟机的组成部分：类加载子系统，运行时数据区，执行引擎，本地方法接口

内存结构(运行时数据区)：程序计数器，Java虚拟机栈，Java本地方法栈，堆，方法区。栈管运行，堆管存储

# 1. 程序计数器

- 程序计数器可以认为是当前线程执行字节码的行号指示器，如果是Java方法指向下一条要执行的字节码；本地方法程序计数器为空
- 为什么需要程序计数器，为什么程序计数器是私有的：
  - 因为程序是多线程执行的，会进行上下文切换；当切换回来我们需要知道上一次执行到哪里
  - 而每个线程执行的字节码可能不同，即使相同执行的情况也不一致，所以需要是私有的
- 程序计数器的特点：线程私有，生命周期和线程一致；没有OOM 和 GC，运行速度最快的区域

# 2. Java虚拟机栈

虚拟机栈的组成：

- 虚拟机栈的单位为栈帧，每个栈帧对应一个方法，栈顶的栈帧对应当前方法
- 栈帧的结构为：局部变量表，操作数栈，方法返回地址，动态链接，一些附加信息

局部变量表

- 单位为slot，除long和double占据两个slot，其他占据一个；而且slot可以复用
- 存放的内容主要是八种基本数据类型和引用类型

操作数栈：

- **主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间**。
- 最大深度在编译的时候就写入到Code属性的max_stacks数据项中

方法返回地址

- 正常退出：返回值给上一层，PC计数器的值为调用指令的下一个指令地址
- 异常退出：返回异常对象的引用给上一次，PC计数器的值由异常表决定

动态链接：指向运行时常量池的方法引用



虚拟机栈的特点

- 线程私有，生命周期和线程一致
- 不需要GC,但是会发生OOM(允许动态扩展出现) 或者 SOF（不允许动态扩展时，栈帧过大 或者 栈帧过多）
- 栈帧需要分配多少内存， 编译器就确定的

# 3. 堆

堆的特点

- 线程共享的
- 几乎所有的对象实例以及数组都应当在运行时分配在堆上，还有一些是未逃逸的就进行栈上分配
- GC的重点区域
- 堆可以处于**物理上**不连续的内存空间中，但在**逻辑上**它应该被视为连续的。

---

为什么要分代：为了优化GC性能

- 因为Java中的对象可以分为两类：一种是生命周期短，一种是生命周期很长的
- 同时垃圾回收算法也是各有优劣，

---

分代

- JDK8以前分为：新生代 + 老年代 + 永久代
- JDK8开始分卫： 新生代 + 老年代 + 元空间

---

新生代：

- 分为Eden区，Survivor0空间和Survivor1空间；默认比例是8：1：1，但是实际上好像是6：1：1；可以通过**-XX:SurvivorRatio**调整这个空间比例
- 几乎所有的Java对象都是在Eden区被new出来的，大部分对象都是朝生夕死的

老年代：

- 经过多轮GC还存活的，大对象（为了避免大量拷贝）存放在老年代
- 新生代和老年代的比例为：1:2；可以修改**-XX:NewRatio**

---

GC分类

- 部分收集：Young GC，Major GC,Mixed GC(G1才有，收集整个新生代和部分老年代)
- 整堆收集: Full GC

----

TLAB（Thread Local Allocation Buffer）

- JVM为每个线程在Eden区分配一块私有区域，
- 快速分配策略：对象创建时优先是使用TLAB分配空间，从而避免线程安全问题；空间不够在使用CAS

---

逃逸分析：

- 当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。
- 当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。
- 不足：可能会出现分析是否逃逸带来的性能损失 大于 本身的损失；比如分析后发现没逃逸，就白白浪费性能了

栈上分配：

- 如果不会发生逃逸，可以把对象分配到栈上

同步省略(锁消除)：

- 如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。

标量替换：

- 将一个对象拆分为多个成员变量来表示	

# 4. 方法区

存放的内容：线程共享的区域

- 类型信息：类的全限定名称，修饰符，父类和接口列表
- 字段信息：域名称，域类型，域修饰符
- 方法信息：方法修饰符，方法名称，字节码，异常表
- 运行时常量池：
  - 存放类引用，方法引用，name and type，数字常量，字符串常量(到堆中去了)

- JIT代码缓存：
- 静态变量：JD7开始在堆中

方法区的演变

- JDK6方法区由永久代实现，字符串常量池和静态变量还在永久代中
- JDK7还是永久代，不过字符串常量池和静态变量存放在堆中了
- JDK8方法区由元空间来实现，使用物理内存

为什么用元空间替代永久代：

- 为永久代设置大小很难，很容易出现因为动态加载的类过多导致OOM；而元空间使用本地内存，可使用的内存多很多

为什么字符串常量池要到堆中

- 永久代的回收效率很低，只有Full GC才进行永久代回收
- 但是开发中会有大量的字符串被创建，如果不及时回收容易导致内存不足

方法区的特点

- 线程共享,用于存储类信息、常量池、静态变量、JIT编译后的代码等数据
- 逻辑概念，有永久代和元空间两种实现方式

# 5. 执行引擎

执行引擎有：解释器和编译器

- 解释器：在执行程序时,才一条一条的解释成机器语言给计算机来执行
- 编译器: 从一种语言 转化为另一种语言
  - 前端编译：将源代码编译成字节码文件
  - JIT编译：将字节码直接编译成机器码放入方法区的JIT代码缓存中，下次要用直接执行
- 为什么还需要解释器：程序启动可以马上发挥作用，响应比编译器快

