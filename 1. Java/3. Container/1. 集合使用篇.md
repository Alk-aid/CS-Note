![img](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/java-collection-hierarchy.9d3304ed.png)

# 1. Collection(单列集合)

## 1.1 Collection

1. 增加

```java
boolean add(E e);
boolean addAll(Collection<? extends E> c);
```

2. 删除

```java
boolean remove(Object o);
boolean removeAll(Collection<?> c);

void clear();

boolean retainAll(Collection<?> c);
```

3. 查找元素

```java
boolean contains(Object o)
boolean containsAll(Collection<?> c);
```

4. 转变

```java
Object[] toArray();
<T> T[] toArray(T[] a);

default Stream<E> stream() {
    return StreamSupport.stream(spliterator(), false);
}
```

5. 属性

```java
int size();
boolean isEmpty();
Iterator<E> iterator();
```

6. 遍历的快捷键

```java
itit  -->迭代器
I     -->增强for
```

## 1.2 list

1. List集合中的元素是有序的(即添加顺序和取出顺序是一致的) 且可以重复
2. List集合中的每一个元素都有其对应的顺序索引 即支持索引 如 list.get(index)
3. 主要实现类有 ArrayList LinkedList Vector

---

相比于Collection接口，会增加如下方法

1. 添加

```java
void add(int index, E element);
boolean addAll(int index, Collection<? extends E> c);
```

2. 删除

```java
E remove(int index);
```

3. 修改

```java
E set(int index, E element);  --> Returns: the element previously at the specified position;
void replaceAll(UnaryOperator<E> operator)
```

4. 获取元素

```java
E get(int index);
int indexOf(Object o);
int lastIndexOf(Object o);
List<E> subList(int fromIndex, int toIndex);
```

## 1.3 Set

1. 无序(添加和取出顺序不一样，但是顺序是固定的) 没有索引
2. 不允许重复元素，所以最多包含一个null

相比较于Collection 没有新增的方法

## 1.4 Queue

1. 添加

```java
boolean add(E e);
boolean offer(E e);
//当使用容量受限的队列时,offer比add好
```

2. 删除

```java
E remove();  //如果此队列为空，抛出异常
E poll();    //如果此队列为空，则返回null 
```

3. 查找元素

```java
E element();   //如果此队列为空，抛出异常
E peek();      //如果此队列为空，则返回null 
```

# 2. Map(双列集合)

增加

```java
public V put(K key, V value);
public void putAll(Map<? extends K, ? extends V> m)
```

删除

```java
public V remove(Object key);
default boolean remove(Object key, Object value);
public void clear()
```

查找

```java
public V get(Object key);
public boolean containsKey(Object key);
public boolean containsValue(Object value);
public V getOrDefault(Object key, V defaultValue) {
    Node<K,V> e;
    return (e = getNode(hash(key), key)) == null ? defaultValue : e.value;
}
```

遍历

```java
public Set<K> keySet();
public Collection<V> values() ;
public Set<Map.Entry<K,V>> entrySet();
//其中Entry的方法有
1. getKey();
2. V getValue();
3. V setValue(V value);
4. boolean equals(Object o);
```

属性

```java
int size();
boolean isEmpty();
```

# 3. Collections 工具类

Collections 工具类常用方法:

1. 排序
2. 查找,替换操作
3. 同步控制(不推荐，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合)

## 3.1 排序操作

```java
void reverse(List list)//反转
void shuffle(List list)//随机排序
void sort(List list)//按自然排序的升序排序
void sort(List list, Comparator c)//定制排序，由Comparator控制排序逻辑
void swap(List list, int i , int j)//交换两个索引位置的元素
void rotate(List list, int distance)//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面
```

## 3.2 查找,替换操作

```java
int binarySearch(List list, Object key)//对List进行二分查找，返回索引，注意List必须是有序的
int max(Collection coll)//根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)
int max(Collection coll, Comparator c)//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)
void fill(List list, Object obj)//用指定的元素代替指定list中的所有元素
int frequency(Collection c, Object o)//统计元素出现次数
int indexOfSubList(List list, List target)//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target)
boolean replaceAll(List list, Object oldVal, Object newVal)//用新元素替换旧元素
```

## 3.3 同步控制

`Collections` 提供了多个`synchronizedXxx()`方法·，该方法可以将指定集合包装成线程同步的集合，从而解决多线程并发访问集合时的线程安全问题。

我们知道 `HashSet`，`TreeSet`，`ArrayList`,`LinkedList`,`HashMap`,`TreeMap` 都是线程不安全的。`Collections` 提供了多个静态方法可以把他们包装成线程同步的集合。

**最好不要用下面这些方法，效率非常低，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合。**

方法如下：

```java
synchronizedCollection(Collection<T>  c) //返回指定 collection 支持的同步（线程安全的）collection。
synchronizedList(List<T> list)//返回指定列表支持的同步（线程安全的）List。
synchronizedMap(Map<K,V> m) //返回由指定映射支持的同步（线程安全的）Map。
synchronizedSet(Set<T> s) //返回指定 set 支持的同步（线程安全的）set。
```

# 4. HashMap的遍历

HashMap **遍历从大的方向来说，可分为以下 4 类**：

1. 迭代器（Iterator）方式遍历；
2. For Each 方式遍历；
3. Lambda 表达式遍历（JDK 1.8+）;
4. Streams API 遍历（JDK 1.8+）。

## 4.1 迭代器 

```java
public class HashMapTest {
    public static void main(String[] args) {
        // 创建并赋值 HashMap
        Map<Integer, String> map = new HashMap();
        map.put(1, "Java");
        map.put(2, "JDK");
        map.put(3, "Spring Framework");
        map.put(4, "MyBatis framework");
        map.put(5, "Java中文社群");
        // entrySet遍历
        Iterator<Map.Entry<Integer, String>> iterator = map.entrySet().iterator();
        while (iterator.hasNext()) {
            Map.Entry<Integer, String> entry = iterator.next();
            System.out.println(entry.getKey());
            System.out.println(entry.getValue());
        }
        // keySet遍历
        Iterator<Integer> iterator = map.keySet().iterator();
        while (iterator.hasNext()) {
            Integer key = iterator.next();
            System.out.println(key);
            System.out.println(map.get(key));
        }
    }
}
```

## 4.2 ForEach

```java
public class HashMapTest {
    public static void main(String[] args) {
        // 创建并赋值 HashMap
        Map<Integer, String> map = new HashMap();
        map.put(1, "Java");
        map.put(2, "JDK");
        map.put(3, "Spring Framework");
        map.put(4, "MyBatis framework");
        map.put(5, "Java中文社群");
        // entrySet遍历
        for (Map.Entry<Integer, String> entry : map.entrySet()) {
            System.out.println(entry.getKey());
            System.out.println(entry.getValue());
        }
        // keySet
        for (Integer key : map.keySet()) {
            System.out.println(key);
            System.out.println(map.get(key));
        }
    }
}
```

## 4.3 Lambda

```java
public class HashMapTest {
    public static void main(String[] args) {
        // 创建并赋值 HashMap
        Map<Integer, String> map = new HashMap();
        map.put(1, "Java");
        map.put(2, "JDK");
        map.put(3, "Spring Framework");
        map.put(4, "MyBatis framework");
        map.put(5, "Java中文社群");
        // 遍历
        map.forEach((key, value) -> {
            System.out.println(key);
            System.out.println(value);
        });
        
    }
}
```

## 4.4 Streams API 

```java
public class HashMapTest {
    public static void main(String[] args) {
        // 创建并赋值 HashMap
        Map<Integer, String> map = new HashMap();
        map.put(1, "Java");
        map.put(2, "JDK");
        map.put(3, "Spring Framework");
        map.put(4, "MyBatis framework");
        map.put(5, "Java中文社群");
        // 单线程 遍历
        map.entrySet().stream().forEach((entry) -> {
            System.out.println(entry.getKey());
            System.out.println(entry.getValue());
        });
        // 多线程 遍历
        map.entrySet().parallelStream().forEach((entry) -> {
            System.out.println(entry.getKey());
            System.out.println(entry.getValue());
        });
    }
}
```

**`entrySet` 的性能比 `keySet` 的性能高出了一倍之多，因此我们应该尽量使用 `entrySet` 来实现 Map 集合的遍历**。

# 5. 线程安全

重点介绍java.util.concurrent.* 下的线程安全集合类，可以发现它们有规律，里面包含三类关键词：`Blocking`、`CopyOnWrite`、`Concurrent`

- Blocking 大部分实现基于锁，并提供用来阻塞的方法
- CopyOnWrite 之类容器修改开销相对较重
- Concurrent 类型的容器
  - 内部很多操作使用 cas 优化，一般可以提供较高吞吐量
  - 弱一致性
    - 遍历时弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍历，这时内容是旧的
    - 求大小弱一致性，size 操作未必是 100% 准确
    - 读取弱一致性

> 遍历时如果发生了修改，对于非安全容器来讲，使用 fail-fast 机制也就是让遍历立刻失败，抛出
> ConcurrentModificationException，不再继续遍历

