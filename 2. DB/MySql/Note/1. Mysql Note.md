# --------------系统优化--------------

主要方式

1. 主从复制
2. 使用连接池
3. 使用索引

# 1. 优化步骤

## 1.1 查看SQL执行频率

MySQL 客户端连接成功后，通过 show [session|global] status 命令可以提供服务器状态信息。show [session|global] status 可以根据需要加上参数“session”或者“global”来显示 session 级（当前连接）的统计结果和 global 级（自数据库上次启动至今）的统计结果。如果不写，默认使用参数是“session”。

下面的命令显示了当前 session 中所有统计参数的值：

```sql
show status like 'Com_______';
```

![1552487172501](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/1552487172501.png)

```sql
show status like 'Innodb_rows_%';
```

![1552487245859](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/1552487245859.png)

Com_xxx 表示每个 xxx 语句执行的次数，我们通常比较关心的是以下几个统计参数。

| 参数                 | 含义                                                         |
| -------------------- | ------------------------------------------------------------ |
| Com_select           | 执行 select 操作的次数，一次查询只累加 1。                   |
| Com_insert           | 执行 INSERT 操作的次数，对于批量插入的 INSERT 操作，只累加一次。 |
| Com_update           | 执行 UPDATE 操作的次数。                                     |
| Com_delete           | 执行 DELETE 操作的次数。                                     |
| Innodb_rows_read     | select 查询返回的行数。                                      |
| Innodb_rows_inserted | 执行 INSERT 操作插入的行数。                                 |
| Innodb_rows_updated  | 执行 UPDATE 操作更新的行数。                                 |
| Innodb_rows_deleted  | 执行 DELETE 操作删除的行数。                                 |
| Connections          | 试图连接 MySQL 服务器的次数。                                |
| Uptime               | 服务器工作时间。                                             |
| Slow_queries         | 慢查询的次数。                                               |

Com_*** : 这些参数对于所有存储引擎的表操作都会进行累计。

Innodb_*** : 这几个参数只是针对InnoDB 存储引擎的，累加的算法也略有不同。

## 1.2 定位低效执行SQL

慢 SQL 由三种原因造成：

* 偶尔慢：DB 在刷新脏页
  * redo log 写满了
  * 内存不够用，要从 LRU 链表中淘汰
  * MySQL 认为系统空闲的时候
  * MySQL 关闭时
* 一直慢的原因：索引没有设计好、SQL 语句没写好、MySQL 选错了索引

---

可以通过以下两种方式定位执行效率较低的 SQL 语句。

通过以下两种方式定位执行效率较低的 SQL 语句

- `慢日志查询`： 慢查询日志在查询结束以后才记录，执行效率出现问题时查询日志并不能定位问题

  配置文件修改：修改 .cnf 文件 `vim /etc/mysql/my.cnf`，重启 MySQL 服务器

  ```sh
  slow_query_log=ON
  slow_query_log_file=/usr/local/mysql/var/localhost-slow.log
  long_query_time=1	#记录超过long_query_time秒的SQL语句的日志
  log-queries-not-using-indexes = 1
  ```

  使用命令配置：

  ```mysql
  mysql> SET slow_query_log=ON;
  mysql> SET GLOBAL slow_query_log=ON;
  ```

  查看是否配置成功：

  ```mysql
  SHOW VARIABLES LIKE '%query%'
  ```

- `show processlist` : `慢查询日志在查询结束以后才记录，所以在应用反映执行效率出现问题的时候查询慢查询日志并不能定位问题，可以使用show processlist命令查看当前MySQL正在进行的线程，包括线程的状态、是否锁表等，可以实时地查看 SQL 的执行情况，同时对一些锁表操作进行优化。`

![1556098544349](https://gitee.com/aik-aid/picture/raw/master/1556098544349.png)

```markdown
1） id列，用户登录mysql时，系统分配的"connection_id"，可以使用函数connection_id()查看

2） user列，显示当前用户。如果不是root，这个命令就只显示用户权限范围的sql语句

3） host列，显示这个语句是从哪个ip的哪个端口上发的，可以用来跟踪出现问题语句的用户

4） db列，显示这个进程目前连接的是哪个数据库

5） command列，显示当前连接的执行的命令，一般取值为休眠（sleep），查询（query），连接（connect）等

6） time列，显示这个状态持续的时间，单位是秒

7） state列，显示使用当前连接的sql语句的状态，很重要的列。state描述的是语句执行中的某一个状态。一个sql语句，以查询为例，可能需要经过copying to tmp table、sorting result、sending data等状态才可以完成

8） info列，显示这个sql语句，是判断问题语句的一个重要依据
```

## 1.3 explain分析执行计划

### 1.3.1 什么是explain

> 通过以上步骤查询到效率低的 SQL 语句后，可以通过 EXPLAIN或者 DESC命令获取 MySQL如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序

通过 EXPLAIN 命令获取执行 SQL 语句的信息,包括

1. 在 SELECT 语句执行过程中如何连接和连接的顺序
2. 选取的索引

执行计划在优化器优化完成后、执行器之前生成，然后执行器会调用存储引擎检索数据



举例

查询SQL语句的执行计划 ：

```sql
explain  select * from tb_item where id = 1;
```

![1552487489859](https://gitee.com/aik-aid/picture/raw/master/1552487489859.png)

```sql
explain  select * from tb_item where title = '阿尔卡特 (OT-979) 冰川白 联通3G手机3';
```

![1552487526919](https://gitee.com/aik-aid/picture/raw/master/1552487526919.png)

| id            | select查询的序列号，表示查询中执行select子句或操作表的顺序   |
| ------------- | ------------------------------------------------------------ |
| select_type   | 表示 SELECT 的类型                                           |
| table         | 输出结果集的表，显示这一步所访问数据库中表名称，有时不是真实的表名字，可能是简称 |
| type          | 表示表的连接类型，性能由好到差的连接类型为( system ---> const -----> eq_ref ------> ref -------> ref_or_null----> index_merge ---> index_subquery -----> range -----> index ------> all ) |
| possible_keys | 表示查询时，可能使用的索引                                   |
| key           | 表示实际使用的索引                                           |
| key_len       | 索引字段的长度                                               |
| ref           | 列与索引的比较，表示表的连接匹配条件，即哪些列或常量被用于查找索引列上的值 |
| rows          | 扫描出的行数，表示 MySQL 根据表统计信息及索引选用情况，**估算**的找到所需的记录扫描的行数 |
| filtered      | 按表条件过滤的行百分比                                       |
| extra         | 执行情况的说明和描述                                         |

### 1.3.2 explain的局限性

MySQL 执行计划的局限：

* 只是计划，不是执行 SQL 语句，可以随着底层优化器输入的更改而更改
* EXPLAIN 不会告诉显示关于触发器、存储过程的信息对查询的影响情况
* EXPLAIN 不考虑各种 Cache
* EXPLAIN 不能显示 MySQL 在执行查询时的动态，因为执行计划在执行查询之前生成
* EXPALIN 部分统计信息是估算的，并非精确值
* EXPALIN 只能解释 SELECT 操作，其他操作要重写为 SELECT 后查看执行计划
* EXPLAIN PLAN 显示的是在解释语句时数据库将如何运行 SQL 语句，由于执行环境和 EXPLAIN PLAN 环境的不同，此计划可能与 SQL 语句实际的执行计划不同

### 1.3.3 环境准备

![1556122799330](https://gitee.com/aik-aid/picture/raw/master/1556122799330.png)

```mysql
    CREATE TABLE `t_role` (
      `id` varchar(32) NOT NULL,
      `role_name` varchar(255) DEFAULT NULL,
      `role_code` varchar(255) DEFAULT NULL,
      `description` varchar(255) DEFAULT NULL,
      PRIMARY KEY (`id`),
      UNIQUE KEY `unique_role_name` (`role_name`)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8;


    CREATE TABLE `t_user` (
      `id` varchar(32) NOT NULL,
      `username` varchar(45) NOT NULL,
      `password` varchar(96) NOT NULL,
      `name` varchar(45) NOT NULL,
      PRIMARY KEY (`id`),
      UNIQUE KEY `unique_user_username` (`username`)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8;


    CREATE TABLE `user_role` (
      `id` int(11) NOT NULL auto_increment ,
      `user_id` varchar(32) DEFAULT NULL,
      `role_id` varchar(32) DEFAULT NULL,
      PRIMARY KEY (`id`),
      KEY `fk_ur_user_id` (`user_id`),
      KEY `fk_ur_role_id` (`role_id`),
      CONSTRAINT `fk_ur_role_id` FOREIGN KEY (`role_id`) REFERENCES `t_role` (`id`) ON DELETE NO ACTION ON UPDATE NO ACTION,
      CONSTRAINT `fk_ur_user_id` FOREIGN KEY (`user_id`) REFERENCES `t_user` (`id`) ON DELETE NO ACTION ON UPDATE NO ACTION
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8;




    insert into `t_user` (`id`, `username`, `password`, `name`) values('1','super','$2a$10$TJ4TmCdK.X4wv/tCqHW14.w70U3CC33CeVncD3SLmyMXMknstqKRe','超级管理员');
    insert into `t_user` (`id`, `username`, `password`, `name`) values('2','admin','$2a$10$TJ4TmCdK.X4wv/tCqHW14.w70U3CC33CeVncD3SLmyMXMknstqKRe','系统管理员');
    insert into `t_user` (`id`, `username`, `password`, `name`) values('3','itcast','$2a$10$8qmaHgUFUAmPR5pOuWhYWOr291WJYjHelUlYn07k5ELF8ZCrW0Cui','test02');
    insert into `t_user` (`id`, `username`, `password`, `name`) values('4','stu1','$2a$10$pLtt2KDAFpwTWLjNsmTEi.oU1yOZyIn9XkziK/y/spH5rftCpUMZa','学生1');
    insert into `t_user` (`id`, `username`, `password`, `name`) values('5','stu2','$2a$10$nxPKkYSez7uz2YQYUnwhR.z57km3yqKn3Hr/p1FR6ZKgc18u.Tvqm','学生2');
    insert into `t_user` (`id`, `username`, `password`, `name`) values('6','t1','$2a$10$TJ4TmCdK.X4wv/tCqHW14.w70U3CC33CeVncD3SLmyMXMknstqKRe','老师1');



    INSERT INTO `t_role` (`id`, `role_name`, `role_code`, `description`) VALUES('5','学生','student','学生');
    INSERT INTO `t_role` (`id`, `role_name`, `role_code`, `description`) VALUES('7','老师','teacher','老师');
    INSERT INTO `t_role` (`id`, `role_name`, `role_code`, `description`) VALUES('8','教学管理员','teachmanager','教学管理员');
    INSERT INTO `t_role` (`id`, `role_name`, `role_code`, `description`) VALUES('9','管理员','admin','管理员');
    INSERT INTO `t_role` (`id`, `role_name`, `role_code`, `description`) VALUES('10','超级管理员','super','超级管理员');


    INSERT INTO user_role(id,user_id,role_id) VALUES(NULL, '1', '5'),(NULL, '1', '7'),(NULL, '2', '8'),(NULL, '3', '9'),(NULL, '4', '8'),(NULL, '5', '10') ;
```

### 1.3.4 各字段分析

#### I id

> id 字段是 select查询的序列号，是一组数字，表示的是查询中执行select子句或者是操作表的顺序。
>

id 情况有三种 ：

1） `id 相同表示加载表的顺序是从上到下。`

```sql
explain select * from t_role r, t_user u, user_role ur where r.id = ur.role_id and u.id = ur.user_id ;
```

![1556102471304](https://gitee.com/aik-aid/picture/raw/master/1556102471304.png)

2） `id 不同id值越大，优先级越高，越先被执行。`

```sql
EXPLAIN SELECT * FROM t_role WHERE id = (SELECT role_id FROM user_role WHERE user_id = (SELECT id FROM t_user WHERE username = 'stu1'))
```

![1556103009534](https://gitee.com/aik-aid/picture/raw/master/1556103009534.png)

3） `id 有相同，也有不同，同时存在。id相同的可以认为是一组，从上往下顺序执行；在所有的组中，id的值越大，优先级越高，越先执行。`

```sql
EXPLAIN SELECT * FROM t_role r , (SELECT * FROM user_role ur WHERE ur.`user_id` = '2') a WHERE r.id = a.role_id ; 
```

![1556103294182](https://gitee.com/aik-aid/picture/raw/master/1556103294182.png)

#### II select_type

数据读取操作的操作类型

表示 SELECT 的类型，常见的取值，如下表所示：`从上往下效率越来越低`

| select_type  | 含义                                                         |
| ------------ | ------------------------------------------------------------ |
| SIMPLE       | `简单的select查询，查询中不包含子查询或者UNION`              |
| PRIMARY      | `查询中若包含任何复杂的子查询，最外层查询标记为该标识`       |
| SUBQUERY     | `在SELECT 或 WHERE 列表中包含了子查询`                       |
| DERIVED      | 在FROM 列表中包含的子查询，被标记为 DERIVED（衍生） MYSQL会递归执行这些子查询，把结果放在临时表中 |
| UNION        | 若第二个SELECT出现在UNION之后，则标记为UNION ； 若UNION包含在FROM子句的子查询中，外层SELECT将被标记为 ： DERIVED |
| UNION RESULT | 从UNION表获取结果的SELECT                                    |

#### III table

展示这一行的数据是从 哪个表 取出来的

#### IV type

type 显示的是访问类型，是较为重要的一个指标，可取值为：

| type   | 含义                                                         |
| ------ | ------------------------------------------------------------ |
| NULL   | MySQL不访问任何表，索引，直接返回结果                        |
| system | 表只有一行记录(等于系统表)，这是const类型的特例，一般不会出现 |
| const  | `表示通过索引一次就找到了，const 用于比较primary key 或者 unique 索引。因为只匹配一行数据，所以很快。如将主键置于where列表中，MySQL 就能将该查询转换为一个常量。const将 "主键" 或 "唯一" 索引的所有部分与常量值进行比较` |
| eq_ref | `类似ref，区别在于使用的是唯一索引，使用主键的关联查询，关联查询出的记录只有一条。常见于主键或唯一索引扫描` |
| ref    | `非唯一性索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，返回所有匹配某个单独值的所有行（多个）` |
| range  | 只检索给定返回的行，使用一个索引来选择行。 where 之后出现 between ， < , > , in 等操作。 |
| index  | `index 与 ALL的区别为 index 类型只是遍历了索引树， 通常比ALL 快， ALL 是遍历数据文件。`(虽然都是读全表，但是index是从索引中读的，而all是从硬盘中读的) |
| all    | `将遍历全表以找到匹配的行`                                   |

结果值从最好到最坏以此是：

```sql
NULL > system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL


system > const > eq_ref > ref > range > index > ALL
```

`一般来说， 我们需要保证查询至少达到 range 级别， 最好达到ref 。`

```mysql
-- NULL演示
explain select '123'
-- const演示
explain select * from city where city_id=1;
-- eq_ref
explain select * from city c1 join city c2 on c1.city_id = c2.city_id
-- ref
explain select * from city where country_id=1
-- range
explain select * from city where country_id>1
-- index
explain select country_id from country 
```

#### V key

- possible_keys : 显示可能应用在这张表的索引， 一个或多个，但不一定被实际使用

- key ： 实际使用的索引， 如果为NULL， 则没有使用索引。

- key_len : 表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长度，是根据表定义计算而出的，而不是通过表内检索出的。在不损失精确性的前提下， 长度越短越好 。

查询中使用了覆盖索引，则该索引仅出现在key列表中

#### VI ref

显示索引的哪一列被使用了，如果可能的话，是一个常数，哪些列或常量被用于查找索引列上的值

![image-20210829114852578](https://gitee.com/aik-aid/picture/raw/master/image-20210829114852578.png)

#### VII rows

扫描行的数量。

#### VIII extra

其他的额外的执行计划信息，在该列展示 。`需要优化的前面两个，保持的是后面using index`

| extra                       | 含义                                                         |
| --------------------------- | ------------------------------------------------------------ |
| using filesort              | 说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取， 称为 “文件排序”, `效率低。` |
| using temporary             | 使用了临时表保存中间结果，MySQL在对查询结果排序时使用临时表。常见于 order by 和 group by； `效率低` |
| using index                 | 表示相应的select操作使用了覆盖索引， 避免访问表的数据行， `效率不错。`    如果同时出现了**using where** 表明索引被用来执行索引键值的查找       如果没有同时出现using where 表明索引用来读取数据而不是查找动作 |
| using where                 | 使用了where进行过滤                                          |
| using join buffer           | 使用了连接缓冲                                               |
| impossible where            | where子句的值总是false                                       |
| select table optimized away |                                                              |
| distinct                    | 优化distinct，在找到第一匹配的元组后停止找同样值的动作       |

![image-20210829120653604](https://gitee.com/aik-aid/picture/raw/master/image-20210829120653604.png)

```mysql
TIP : 
	
using index ：使用覆盖索引的时候就会出现

using where：在查找使用索引的情况下，需要回表去查询所需的数据

using index condition：查找使用了索引，但是需要回表查询数据

using index ; using where：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据
```



## 1.4 PROFILES



|      |      |
| ---- | ---- |
|      |      |
|      |      |
|      |      |
|      |      |

## 1.5 TRACE

MySQL5.6提供了对SQL的跟踪trace, 通过trace文件能够进一步了解为什么优化器选择A计划, 而不是选择B计划。

打开trace ， 设置格式为 JSON，并设置trace最大能够使用的内存大小，避免解析过程中因为默认内存过小而不能够完整展示。

```sql
SET optimizer_trace="enabled=on",end_markers_in_json=on;
set optimizer_trace_max_mem_size=1000000;
```

执行SQL语句 ：

```sql
select * from tb_item where id < 4;
```

最后， 检查information_schema.optimizer_trace就可以知道MySQL是如何执行SQL的 ：

```sql
select * from information_schema.optimizer_trace\G;
*************************** 1. row ***************************
QUERY: select * from tb_item where id < 4
TRACE: {
  "steps": [
    {
      "join_preparation": {
        "select#": 1,
        "steps": [
          {
            "expanded_query": "/* select#1 */ select `tb_item`.`id` AS `id`,`tb_item`.`title` AS `title`,`tb_item`.`price` AS `price`,`tb_item`.`num` AS `num`,`tb_item`.`categoryid` AS `categoryid`,`tb_item`.`status` AS `status`,`tb_item`.`sellerid` AS `sellerid`,`tb_item`.`createtime` AS `createtime`,`tb_item`.`updatetime` AS `updatetime` from `tb_item` where (`tb_item`.`id` < 4)"
          }
        ] /* steps */
      } /* join_preparation */
    },
    {
      "join_optimization": {
        "select#": 1,
        "steps": [
          {
            "condition_processing": {
              "condition": "WHERE",
              "original_condition": "(`tb_item`.`id` < 4)",
              "steps": [
                {
                  "transformation": "equality_propagation",
                  "resulting_condition": "(`tb_item`.`id` < 4)"
                },
                {
                  "transformation": "constant_propagation",
                  "resulting_condition": "(`tb_item`.`id` < 4)"
                },
                {
                  "transformation": "trivial_condition_removal",
                  "resulting_condition": "(`tb_item`.`id` < 4)"
                }
              ] /* steps */
            } /* condition_processing */
          },
          {
            "table_dependencies": [
              {
                "table": "`tb_item`",
                "row_may_be_null": false,
                "map_bit": 0,
                "depends_on_map_bits": [
                ] /* depends_on_map_bits */
              }
            ] /* table_dependencies */
          },
          {
            "ref_optimizer_key_uses": [
            ] /* ref_optimizer_key_uses */
          },
          {
            "rows_estimation": [
              {
                "table": "`tb_item`",
                "range_analysis": {
                  "table_scan": {
                    "rows": 9816098,
                    "cost": 2.04e6
                  } /* table_scan */,
                  "potential_range_indices": [
                    {
                      "index": "PRIMARY",
                      "usable": true,
                      "key_parts": [
                        "id"
                      ] /* key_parts */
                    }
                  ] /* potential_range_indices */,
                  "setup_range_conditions": [
                  ] /* setup_range_conditions */,
                  "group_index_range": {
                    "chosen": false,
                    "cause": "not_group_by_or_distinct"
                  } /* group_index_range */,
                  "analyzing_range_alternatives": {
                    "range_scan_alternatives": [
                      {
                        "index": "PRIMARY",
                        "ranges": [
                          "id < 4"
                        ] /* ranges */,
                        "index_dives_for_eq_ranges": true,
                        "rowid_ordered": true,
                        "using_mrr": false,
                        "index_only": false,
                        "rows": 3,
                        "cost": 1.6154,
                        "chosen": true
                      }
                    ] /* range_scan_alternatives */,
                    "analyzing_roworder_intersect": {
                      "usable": false,
                      "cause": "too_few_roworder_scans"
                    } /* analyzing_roworder_intersect */
                  } /* analyzing_range_alternatives */,
                  "chosen_range_access_summary": {
                    "range_access_plan": {
                      "type": "range_scan",
                      "index": "PRIMARY",
                      "rows": 3,
                      "ranges": [
                        "id < 4"
                      ] /* ranges */
                    } /* range_access_plan */,
                    "rows_for_plan": 3,
                    "cost_for_plan": 1.6154,
                    "chosen": true
                  } /* chosen_range_access_summary */
                } /* range_analysis */
              }
            ] /* rows_estimation */
          },
          {
            "considered_execution_plans": [
              {
                "plan_prefix": [
                ] /* plan_prefix */,
                "table": "`tb_item`",
                "best_access_path": {
                  "considered_access_paths": [
                    {
                      "access_type": "range",
                      "rows": 3,
                      "cost": 2.2154,
                      "chosen": true
                    }
                  ] /* considered_access_paths */
                } /* best_access_path */,
                "cost_for_plan": 2.2154,
                "rows_for_plan": 3,
                "chosen": true
              }
            ] /* considered_execution_plans */
          },
          {
            "attaching_conditions_to_tables": {
              "original_condition": "(`tb_item`.`id` < 4)",
              "attached_conditions_computation": [
              ] /* attached_conditions_computation */,
              "attached_conditions_summary": [
                {
                  "table": "`tb_item`",
                  "attached": "(`tb_item`.`id` < 4)"
                }
              ] /* attached_conditions_summary */
            } /* attaching_conditions_to_tables */
          },
          {
            "refine_plan": [
              {
                "table": "`tb_item`",
                "access_type": "range"
              }
            ] /* refine_plan */
          }
        ] /* steps */
      } /* join_optimization */
    },
    {
      "join_execution": {
        "select#": 1,
        "steps": [
        ] /* steps */
      } /* join_execution */
    }
  ] /* steps */
}
```

# 2. 索引失效

## 2.1 准备环境

```mysql
create table `tb_seller` (
	`sellerid` varchar (100),
	`name` varchar (100),
	`nickname` varchar (50),
	`password` varchar (60),
	`status` varchar (1),
	`address` varchar (100),
	`createtime` datetime,
    primary key(`sellerid`)
)engine=innodb default charset=utf8mb4; 

insert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values('alibaba','阿里巴巴','阿里小店','e10adc3949ba59abbe56e057f20f883e','1','北京市','2088-01-01 12:00:00');
insert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values('baidu','百度科技有限公司','百度小店','e10adc3949ba59abbe56e057f20f883e','1','北京市','2088-01-01 12:00:00');
insert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values('huawei','华为科技有限公司','华为小店','e10adc3949ba59abbe56e057f20f883e','0','北京市','2088-01-01 12:00:00');
insert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values('itcast','传智播客教育科技有限公司','传智播客','e10adc3949ba59abbe56e057f20f883e','1','北京市','2088-01-01 12:00:00');
insert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values('itheima','黑马程序员','黑马程序员','e10adc3949ba59abbe56e057f20f883e','0','北京市','2088-01-01 12:00:00');
insert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values('luoji','罗技科技有限公司','罗技小店','e10adc3949ba59abbe56e057f20f883e','1','北京市','2088-01-01 12:00:00');
insert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values('oppo','OPPO科技有限公司','OPPO官方旗舰店','e10adc3949ba59abbe56e057f20f883e','0','北京市','2088-01-01 12:00:00');
insert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values('ourpalm','掌趣科技股份有限公司','掌趣小店','e10adc3949ba59abbe56e057f20f883e','1','北京市','2088-01-01 12:00:00');
insert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values('qiandu','千度科技','千度小店','e10adc3949ba59abbe56e057f20f883e','2','北京市','2088-01-01 12:00:00');
insert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values('sina','新浪科技有限公司','新浪官方旗舰店','e10adc3949ba59abbe56e057f20f883e','1','北京市','2088-01-01 12:00:00');
insert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values('xiaomi','小米科技','小米官方旗舰店','e10adc3949ba59abbe56e057f20f883e','1','西安市','2088-01-01 12:00:00');
insert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values('yijia','宜家家居','宜家家居旗舰店','e10adc3949ba59abbe56e057f20f883e','1','北京市','2088-01-01 12:00:00');

-- 创建联合索引
create index idx_seller_name_sta_addr on tb_seller(name,status,address);
```

## 2.2 避免索引失效

### 2.2.1 全值匹配

1). `全值匹配 ，对索引中所有列都指定具体值。该情况下，索引生效，执行效率高。`

```sql
explain select * from tb_seller where name='小米科技' and status='1' and address='北京市';
```

![1556170997921](https://gitee.com/aik-aid/picture/raw/master/1556170997921.png)

### 2.2.2 最左前缀法则

1. 如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始，并且不跳过索引中的列
2. 这个和where后面各条件出现的顺序无关，只关注有无出现该前缀。

status address name 索引不会失效

![1556171348995](https://gitee.com/aik-aid/picture/raw/master/1556171348995.png)

违法最左前缀法则 ， 索引失效：

![1556171428140](https://gitee.com/aik-aid/picture/raw/master/1556171428140.png)

如果符合最左法则，但是出现跳跃某一列，只有最左列索引生效：

![1556171662203](https://gitee.com/aik-aid/picture/raw/master/1556171662203.png)

### 2.2.3 范围查询

范围查询右边的列，不能使用索引 。范围查询条件之后的字段，索引失效，范围查询的那个字段 索引不会失效

![1556172256791](https://gitee.com/aik-aid/picture/raw/master/1556172256791.png)

**根据前面的两个字段name ， status 查询是走索引的，** 但是最后一个条件address 没有用到索引。

### 2.2.4 不要在索引列上进行运算操作， 索引将失效。

![1556172813715](https://gitee.com/aik-aid/picture/raw/master/1556172813715.png)

### 2.2.5 字符串不加单引号，造成索引失效。

![1556172967493](https://gitee.com/aik-aid/picture/raw/master/1556172967493.png)

由于，在查询是，没有对字符串加单引号，MySQL的查询优化器，会自动的进行类型转换，隐式进行了运算，造成索引失效。

### 2.2.6 尽量使用覆盖索引，避免select *

尽量使用覆盖索引（只访问索引的查询（索引列完全包含查询列）），减少select * 。

![1556173928299](https://gitee.com/aik-aid/picture/raw/master/1556173928299.png)

如果查询列，超出索引列，也会降低性能。(索引列没有password，所以需要回表查询)

![1556173986068](https://gitee.com/aik-aid/picture/raw/master/1556173986068.png)

> TIP : 
> 	
> using index ：使用覆盖索引的时候就会出现
>
> using where：在查找使用索引的情况下，需要回表去查询所需的数据
>
> using index condition：查找使用了索引，但是需要回表查询数据
>
> using index ; using where：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据

### 2.2.7 or

`用or分割开的条件， 如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。`

示例，name字段是索引列 ， 而createtime不是索引列，中间是or进行连接是不走索引的 ：

```mysql
explain select * from tb_seller where name='黑马程序员' or createtime = '2088-01-01 12:00:00'\G;	
```

![1556174994440](https://gitee.com/aik-aid/picture/raw/master/1556174994440.png)

### 2.2.8 模糊查询

以%开头的Like模糊查询，索引失效。

如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。

![1556175114369](https://gitee.com/aik-aid/picture/raw/master/1556175114369.png)

解决方案 ：通过覆盖索引来解决

![1556247686483](https://gitee.com/aik-aid/picture/raw/master/1556247686483.png)

### 2.2.9 评估

`如果MySQL评估使用索引比全表更慢，则不使用索引。`

![1556175445210](https://gitee.com/aik-aid/picture/raw/master/1556175445210.png)

> 明明单独创建了address索引，但是explain查看没有使用索引，这种情况跟表中数据有关，查看表数据知道，12条数据，11条是'北京市'，使用索引查找效率不如直接全表扫描来的快，所以在执行SQL语句的时候，MySQL放弃使用索引，而使用全表扫描。

### 2.2.10 is NULL ， is NOT NULL `有时`索引失效。

![1556180634889](https://gitee.com/aik-aid/picture/raw/master/1556180634889.png)

> MySQL底层会自动判断，如果全表扫描快，则直接使用全表扫描，不走索引。如果表中该索引列数据绝大多数是非空值，则使用is not null的时候走索引，使用is null的时候不走索引（还不如全表扫描快），全表扫描；反之亦然。

### 2.2.11 in

`in 走索引， not in 索引失效。`

![1556249602732](https://gitee.com/aik-aid/picture/raw/master/1556249602732.png)

### 2.2.12 单列索引和复合索引

`尽量使用复合索引，而少使用单列索引 。`

创建复合索引

```sql
create index idx_name_sta_address on tb_seller(name, status, address);

就相当于创建了三个索引 ： 
	name
	name + status
	name + status + address
```

创建单列索引

```sql
create index idx_seller_name on tb_seller(name);
create index idx_seller_status on tb_seller(status);
create index idx_seller_address on tb_seller(address);
```

> 使用单列索引的时候，数据库会选择一个最优的索引（辨识度最高索引）来使用，并不会使用全部索引 。

## 2.3 查看索引使用情况

```sql
show status like 'Handler_read%';	 -- 查看当前会话索引使用情况

show global status like 'Handler_read%';	-- 查看全局索引使用情况
```

![1552885364563](https://gitee.com/aik-aid/picture/raw/master/1552885364563.png)

```sql
Handler_read_first：索引中第一条被读的次数。如果较高，表示服务器正执行大量全索引扫描（这个值越低越好）。

Handler_read_key：如果索引正在工作，这个值代表一个行被索引值读的次数，如果值越低，表示索引得到的性能改善不高，因为索引不经常使用（这个值越高越好）。

Handler_read_next ：按照键顺序读下一行的请求数。如果你用范围约束或如果执行索引扫描来查询索引列，该值增加。

Handler_read_prev：按照键顺序读前一行的请求数。该读方法主要用于优化ORDER BY ... DESC。

Handler_read_rnd ：根据固定位置读一行的请求数。如果你正执行大量查询并需要对结果进行排序该值较高。你可能使用了大量需要MySQL扫描整个表的查询或你的连接没有正确使用键。这个值较高，意味着运行效率低，应该建立索引来补救。

Handler_read_rnd_next：在数据文件中读下一行的请求数。如果你正进行大量的表扫描，该值较高。通常说明你的表索引不正确或写入的查询没有利用索引。
```

## 2.4 失效原理

1. 索引失效一般是针对联合索引的
2. 联合索引其实和多字段排序是很类似的，都是先按照第一个字段排序，然后排序第二个，依次类推
3. 如果第一个字段相等的话，那么第二个字段是有序的；如果第一个字段不相等的话，那么第二个字段是无序的。

<img src="https://gitee.com/seazean/images/raw/master/DB/MySQL-索引失效底层原理1.png" style="zoom:67%;" />

* 最左前缀法则：当不匹配前面的字段的时候，后面的字段都是无序的。这种无序不仅体现在叶子节点，也会**导致查询时扫描的非叶子节点也是无序的**，因为索引树相当于忽略的第一个字段，就无法使用二分查找

* 范围查询右边的列，不能使用索引，比如语句： `WHERE a > 1 AND b = 1 `，在 a 大于 1 的时候，b 是无序的，a > 1 是扫描时有序的，但是找到以后进行寻找 b 时，索引树就不是有序的了

  <img src="https://gitee.com/seazean/images/raw/master/DB/MySQL-索引失效底层原理2.png" style="zoom:67%;" />

* 以 % 开头的 LIKE 模糊查询，索引失效，比如语句：`WHERE a LIKE '%d'`，前面的不确定，导致不符合最左匹配，直接去索引中搜索以 d 结尾的节点，所以没有顺序
      ![](https://gitee.com/seazean/images/raw/master/DB/MySQL-索引失效底层原理3.png)

## 2.4 总结

1.  全值匹配我最爱
2.  最佳左前缀法则，比如建立了一个联合索引（a，b，c），那么其实我们可利用的索引就有（a），（a，b），（a，b，c）
3.  不在索引列上做任何操作（计算、函数、（自动 or 手动）类型转换），会导致索引失效而转向全表扫描
4.  存储引擎不能使用索引中范围条件右边的列
5.  尽量使用覆盖索引（只访问索引的查询（索引列和查询列一致）），减少 select
6.  is null，is not null也无法使用索引
7.  `like "xxxx%"`是可以用到索引的，`like "%xxxx"`则不行（`like "%xxx%"`同理）。`like` 以通配符开头`（'%ab...'）`索引失效会变成全表扫描的操作
8.  字符串不加单引号索引失效
9.  少用 or，用它来连接时会索引失效 <，<=，=，>，>=，BETWEEN， IN 可用到索引，<>，not in，!= 则不行，会导致全表扫描

**一般性建议**

-   对于单键索引，尽量选择针对当前 query 过滤性更好的索引
-   在选择组合索引的时候，当前 query 中过滤性最好的字段在索引字段顺序中，位置越靠前越好。
-   在选择组合索引的时候，尽量选择可以能够包含当前 query 中的 where 字句中更多字段的索引
-   尽可能通过分析统计信息和调整 query 的写法来达到选择合适索引的目的
-   少用 Hint 强制索引

# 3. SQL优化

## 3.1 大量insert语句

环境准备 ：

```sql
CREATE TABLE `tb_user_2` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `username` varchar(45) NOT NULL,
  `password` varchar(96) NOT NULL,
  `name` varchar(45) NOT NULL,
  `birthday` datetime DEFAULT NULL,
  `sex` char(1) DEFAULT NULL,
  `email` varchar(45) DEFAULT NULL,
  `phone` varchar(45) DEFAULT NULL,
  `qq` varchar(32) DEFAULT NULL,
  `status` varchar(32) NOT NULL COMMENT '用户状态',
  `create_time` datetime NOT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `unique_user_username` (`username`)  -- 唯一性约束
) ENGINE=InnoDB DEFAULT CHARSET=utf8 ;
```

当使用load 命令导入数据的时候，适当的设置可以提高导入的效率。

![1556269346488](https://gitee.com/aik-aid/picture/raw/master/1556269346488.png)

`对于 InnoDB 类型的表，有以下几种方式可以提高导入的效率：`

### 3.1.1 主键顺序插入

> 因为InnoDB类型的表是按照主键的顺序保存的，所以将导入的数据按照主键的顺序排列，可以有效的提高导入数据的效率。如果InnoDB表没有主键，那么系统会自动默认创建一个内部列作为主键，所以如果可以给表创建一个主键，将可以利用这点，来提高导入数据的效率。

```sql
脚本文件介绍 :
	sql1.log  ----> 主键有序
	sql2.log  ----> 主键无序
```

插入ID顺序排列数据：

![1555771750567](https://gitee.com/aik-aid/picture/raw/master/1555771750567.png)

插入ID无序排列数据：

![1555771959734](https://gitee.com/aik-aid/picture/raw/master/1555771959734.png)

### 3.1.2 关闭唯一性校验

> 在导入数据前执行 SET UNIQUE_CHECKS=0，关闭唯一性校验，在导入结束后执行SET UNIQUE_CHECKS=1，恢复唯一性校验，可以提高导入的效率。

![1555772132736](https://gitee.com/aik-aid/picture/raw/master/1555772132736.png)

### 3.1.3 手动提交事务

> 如果应用使用自动提交的方式，建议在导入前执行 SET AUTOCOMMIT=0，关闭自动提交，导入结束后再执行 SET AUTOCOMMIT=1，打开自动提交，也可以提高导入的效率。

![1555772351208](https://gitee.com/aik-aid/picture/raw/master/1555772351208.png)

### 3.1.4 多个值表的insert

如果需要同时对一张表插入很多行数据时，应该尽量使用多个值表的insert语句，这种方式将大大的缩减客户端与数据库之间的连接、关闭等消耗。使得效率比分开执行的单个insert语句快。

示例， 原始方式为：

```sql
insert into tb_test values(1,'Tom');
insert into tb_test values(2,'Cat');
insert into tb_test values(3,'Jerry');
```

优化后的方案为 ：

**这样就不用多次建立连接了**

```sql
insert into tb_test values(1,'Tom'),(2,'Cat')，(3,'Jerry');
```

## 3.2 优化order by

### 3.2.1 两种排序方式

之里面id是主键，(age,salary)是联合索引

#### I Using filesort

 第一种是通过对返回数据进行排序，也就是通常说的 filesort 排序，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。效率低

![1556335817763](https://gitee.com/aik-aid/picture/raw/master/1556335817763.png)

#### II Using index

第二种通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高。

![image-20210628173926392](https://gitee.com/aik-aid/picture/raw/master/image-20210628173926392.png)

多字段排序

![1556336352061](https://gitee.com/aik-aid/picture/raw/master/1556336352061.png)

> 了解了MySQL的排序方式，优化目标就清晰了：
>
> 1. 尽量减少额外的排序，通过索引直接返回有序数据(using index)。
> 2. where 条件和Order by 使用相同的索引
> 3. 并且Order By 的顺序和索引顺序相同，
> 4. 并且Order by 的字段都是升序，或者都是降序
> 5. 否则肯定需要额外的操作，这样就会出现FileSort。

### 3.2.2 Filesort优化

通过创建合适的索引，能够减少 Filesort 的出现，但是在某些情况下，条件限制不能让Filesort消失，那就需要加快 Filesort的排序操作。对于Filesort ， MySQL 有两种排序算法：

1） 两次扫描算法 ：MySQL4.1 之前，使用该方式排序。首先根据条件取出排序字段和行指针信息，然后在排序区 sort buffer 中排序，如果sort buffer不够，则在临时表 temporary table 中存储排序结果。完成排序之后，再根据行指针回表读取记录，该操作可能会导致大量随机I/O操作。

2）一次扫描算法：一次性取出满足条件的所有字段，然后在排序区 sort buffer 中排序后直接输出结果集。排序时内存开销较大，但是排序效率比两次扫描算法要高。

`MySQL 通过比较系统变量 max_length_for_sort_data 的大小和Query语句取出的字段总大小， 来判定是否那种排序算法，如果max_length_for_sort_data 更大，那么使用第二种优化之后的算法；否则使用第一种。`

`可以适当提高 sort_buffer_size 和 max_length_for_sort_data 系统变量，来增大排序区的大小，提高排序的效率。`

![1556338367593](https://gitee.com/aik-aid/picture/raw/master/1556338367593.png)

## 3.3 优化group by

由于GROUP BY 实际上也同样会进行排序操作，而且与ORDER BY 相比，GROUP BY 主要只是多了排序之后的分组操作。当然，如果在分组的时候还使用了其他的一些聚合函数，那么还需要一些聚合函数的计算。所以，在GROUP BY 的实现过程中，与 ORDER BY 一样也可以利用到索引。

`如果查询包含 group by 但是用户想要避免排序结果的消耗， 则可以执行order by null 禁止排序`。如下 ：

```sql
drop index idx_emp_age_salary on emp;

explain select age,count(*) from emp group by age;
```

![1556339573979](https://gitee.com/aik-aid/picture/raw/master/1556339573979.png)

优化后

```sql
explain select age,count(*) from emp group by age order by null;
```

![1556339633161](https://gitee.com/aik-aid/picture/raw/master/1556339633161.png)

从上面的例子可以看出，第一个SQL语句需要进行"filesort"，而第二个SQL由于order by null 不需要进行 "filesort"， 而上文提过Filesort往往非常耗费时间。

创建索引 ：

```sql
create index idx_emp_age_salary on emp(age,salary)；
```

![1556339688158](https://gitee.com/aik-aid/picture/raw/master/1556339688158.png)

## 3.4 优化嵌套查询

> Mysql4.1版本之后，开始支持SQL的子查询。这个技术可以使用SELECT语句来创建一个单列的查询结果，然后把这个结果作为过滤条件用在另一个查询中。使用子查询可以一次性的完成很多逻辑上需要多个步骤才能完成的SQL操作，同时也可以避免事务或者表锁死，并且写起来也很容易。但是，有些情况下，子查询是可以被更高效的连接（JOIN）替代。

示例 ，查找有角色的所有的用户信息 :

```sql
 explain select * from t_user where id in (select user_id from user_role );
```

执行计划为 :

![1556359399199](https://gitee.com/aik-aid/picture/raw/master/1556359399199.png)

优化后 :

```sql
explain select * from t_user u , user_role ur where u.id = ur.user_id;
```

![1556359482142](https://gitee.com/aik-aid/picture/raw/master/1556359482142.png)

> 连接(Join)查询之所以更有效率一些 ，是因为MySQL不需要在内存中创建临时表来完成这个逻辑上需要两个步骤的查询工作。

## 3.5 优化OR条件

`对于包含OR的查询子句，如果要利用索引，则OR之间的每个条件列都必须用到索引 ， 而且不能使用到复合索引； 如果没有索引，则应该考虑增加索引。`

获取 emp 表中的所有的索引 ：

![1556354464657](https://gitee.com/aik-aid/picture/raw/master/1556354464657.png)

示例 ：

```sql
explain select * from emp where id = 1 or age = 30;
```

![1556354887509](https://gitee.com/aik-aid/picture/raw/master/1556354887509.png)

![1556354920964](https://gitee.com/aik-aid/picture/raw/master/1556354920964.png)

`建议使用 union 替换 or `：

![1556355027728](https://gitee.com/aik-aid/picture/raw/master/1556355027728.png)

我们来比较下重要指标，发现主要差别是 type 和 ref 这两项

type 显示的是访问类型，是较为重要的一个指标，结果值从好到坏依次是：

```sql
system > const > eq_ref > ref > fulltext > ref_or_null  > index_merge > unique_subquery > index_subquery > range > index > ALL
```

UNION 语句的 type 值为 ref，OR 语句的 type 值为 range，可以看到这是一个很明显的差距

UNION 语句的 ref 值为 const，OR 语句的 type 值为 null，const 表示是常量值引用，非常快

这两项的差距就说明了 UNION 要优于 OR 。

## 3.6 优化分页查询

> 一般分页查询时，通过创建覆盖索引能够比较好地提高性能。一个常见又非常头疼的问题就是 limit 2000000,10 ，此时需要MySQL**排序**前2000010 记录，仅仅返回2000000 - 2000010 的记录，其他记录丢弃，查询排序的代价非常大 。

![1556361314783](https://gitee.com/aik-aid/picture/raw/master/1556361314783.png)

### 3.6.1 优化思路一

`在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容。`

![1556416102800](https://gitee.com/aik-aid/picture/raw/master/1556416102800.png)

### 3.6.2 优化思路二

`该方案适用于主键自增的表，可以把Limit 查询转换成某个位置的查询 。`(局限性：主键不能断层)

![1556363928151](https://gitee.com/aik-aid/picture/raw/master/1556363928151.png)

## 3.7 使用SQL提示

> SQL提示，是优化数据库的一个重要手段，简单 来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。

### 3.7.1 USE INDEX

`在查询语句中表名的后面，添加 use index 来提供希望MySQL去参考的索引列表，就可以让MySQL不再考虑其他可用的索引。`

```sql
create index idx_seller_name on tb_seller(name);
```

![1556370971576](https://gitee.com/aik-aid/picture/raw/master/1556370971576.png)

### 3.7.2 IGNORE INDEX

`如果用户只是单纯的想让MySQL忽略一个或者多个索引，则可以使用 ignore index 作为 hint 。`

```sql
 explain select * from tb_seller ignore index(idx_seller_name) where name = '小米科技';
```

![1556371004594](https://gitee.com/aik-aid/picture/raw/master/1556371004594.png)

### 3.7.3 FORCE INDEX

`为强制MySQL使用一个特定的索引，可在查询中使用 force index 作为hint 。`

```sql
create index idx_seller_address on tb_seller(address);
```

![1556371355788](https://gitee.com/aik-aid/picture/raw/master/1556371355788.png)

## 3.8 统计计数

在不同的 MySQL 引擎中，count(*) 有不同的实现方式：

* MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高，但不支持事务
* show table status 命令通过采样估算可以快速获取，但是不准确
* InnoDB 表执行 count(*) 会遍历全表，虽然结果准确，但会导致性能问题

解决方案：

* 计数保存在 Redis 中，但是更新 MySQL 和 Redis 的操作不是原子的，会存在数据一致性的问题

* 计数直接放到数据库里单独的一张计数表中，利用事务解决计数精确问题：

  <img src="https://gitee.com/seazean/images/raw/master/DB/MySQL-计数count优化.png" style="zoom: 50%;" />

  会话 B 的读操作在 T3 执行的，这时更新事务还没有提交，所以计数值加 1 这个操作对会话 B 还不可见，因此会话 B 查询的计数值和最近 100 条记录，返回的结果逻辑上就是一致的

  并发系统性能的角度考虑，应该先插入操作记录再更新计数表，因为更新计数表涉及到行锁的竞争，**先插入再更新能最大程度地减少事务之间的锁等待，提升并发度**

count 函数的按照效率排序：`count(字段) < count(主键id) < count(1) ≈ count(*)`，所以建议尽量使用 count(*)

* count(主键 id)：InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来返回给 Server 层，Server 判断 id 不为空就按行累加
* count(1)：InnoDB 引擎遍历整张表但不取值，Server 层对于返回的每一行，放一个数字 1 进去，判断不为空就按行累加

* count(字段)：如果这个字段是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加；如果这个字段定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加

## 3.9 减少访问

避免对数据进行重复检索：能够一次连接就获取到结果的，就不用两次连接，这样可以大大减少对数据库无用的重复请求

* 查询数据：

  ```mysql
  SELECT id,name FROM tb_book;
  SELECT id,status FROM tb_book; -- 向数据库提交两次请求，数据库就要做两次查询操作
  -- > 优化为:
  SELECT id,name,statu FROM tb_book;
  ```

* 插入数据：

  ```mysql
  INSERT INTO tb_test VALUES(1,'Tom');
  INSERT INTO tb_test VALUES(2,'Cat');
  INSERT INTO tb_test VALUES(3,'Jerry');	-- 连接三次数据库
  -- >优化为
  INSERT INTO tb_test VALUES(1,'Tom'),(2,'Cat')，(3,'Jerry');	-- 连接一次
  ```

* 在事务中进行数据插入：

  ```mysql
  start transaction;
  INSERT INTO tb_test VALUES(1,'Tom');
  INSERT INTO tb_test VALUES(2,'Cat');
  INSERT INTO tb_test VALUES(3,'Jerry');
  commit;	-- 手动提交，分段提交
  ```

* 数据有序插入：

  ```mysql
  INSERT INTO tb_test VALUES(1,'Tom');
  INSERT INTO tb_test VALUES(2,'Cat');
  INSERT INTO tb_test VALUES(3,'Jerry');
  ```

增加 cache 层：在应用中增加缓存层来达到减轻数据库负担的目的。可以部分数据从数据库中抽取出来放到应用端以文本方式存储，或者使用框架（Mybatis）提供的一级缓存 / 二级缓存，或者使用 Redis 数据库来缓存数据 

# 4. 内存优化

## 4.1 内存优化原则

1） 将尽量多的内存分配给MySQL做缓存，但要给操作系统和其他程序预留足够内存。

2） MyISAM 存储引擎的数据文件读取依赖于操作系统自身的IO缓存，因此，如果有MyISAM表，就要预留更多的内存给操作系统做IO缓存。

3） 排序区、连接区等缓存是分配给每个数据库会话（session）专用的，其默认值的设置要根据最大连接数合理分配，如果设置太大，不但浪费资源，而且在并发连接较高时会导致物理内存耗尽。

## 4.2 MyISAM 内存优化

> myisam存储引擎使用 key_buffer 缓存索引块，加速myisam索引的读写速度。对于myisam表的数据块，mysql没有特别的缓存机制，完全依赖于操作系统的IO缓存。

### 4.2.1 key_buffer_size

key_buffer_size决定MyISAM索引块缓存区的大小，直接影响到MyISAM表的存取效率。可以在MySQL参数文件中设置key_buffer_size的值，对于一般MyISAM数据库，建议至少将1/4可用内存分配给key_buffer_size。

在/usr/my.cnf 中做如下配置：

```sql
key_buffer_size=512M
```

### 4.2.2 read_buffer_size

如果需要经常顺序扫描myisam表，可以通过增大read_buffer_size的值来改善性能。但需要注意的是read_buffer_size是每个session独占的，如果默认值设置太大，就会造成内存浪费。

### 4.2.3 read_rnd_buffer_size

对于需要做排序的myisam表的查询，如带有order by子句的sql，适当增加 read_rnd_buffer_size 的值，可以改善此类的sql性能。但需要注意的是 read_rnd_buffer_size 是每个session独占的，如果默认值设置太大，就会造成内存浪费。

## 4.3 InnoDB 内存优化

> innodb用一块内存区做IO缓存池，该缓存池不仅用来缓存innodb的索引块，而且也用来缓存innodb的数据块。

### innodb_buffer_pool_size

该变量决定了 innodb 存储引擎表数据和索引数据的最大缓存区大小。在保证操作系统及其他程序有足够内存可用的情况下，innodb_buffer_pool_size 的值越大，缓存命中率越高，访问InnoDB表需要的磁盘I/O 就越少，性能也就越高。

```sql
innodb_buffer_pool_size=512M
```

### innodb_log_buffer_size

决定了innodb重做日志缓存的大小，对于可能产生大量更新记录的大事务，增加innodb_log_buffer_size的大小，可以避免innodb在事务提交前就执行不必要的日志写入磁盘操作。

```sql
innodb_log_buffer_size=10M
```

# 5. 并发优化

从实现上来说，MySQL Server 是多线程结构，包括后台线程和客户服务线程。多线程可以有效利用服务器资源，提高数据库的并发性能。在Mysql中，控制并发连接和线程的主要参数包括 max_connections、back_log、thread_cache_size、table_open_cahce。

## 5.1 max_connections

采用max_connections 控制允许连接到MySQL数据库的最大数量，默认值是 151。如果状态变量 connection_errors_max_connections 不为零，并且一直增长，则说明不断有连接请求因数据库连接数已达到允许最大值而失败，这是可以考虑增大max_connections 的值。

Mysql 最大可支持的连接数，取决于很多因素，包括给定操作系统平台的线程库的质量、内存大小、每个连接的负荷、CPU的处理速度，期望的响应时间等。在Linux 平台下，性能好的服务器，支持 500-1000 个连接不是难事，需要根据服务器性能进行评估设定。

## 5.2 back_log

back_log 参数控制MySQL监听TCP端口时设置的积压请求栈大小。`如果MySql的连接数达到max_connections时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即back_log，如果等待连接的数量超过back_log，将不被授予连接资源，将会报错。`5.6.6 版本之前默认值为 50 ， 之后的版本默认为 50 + （max_connections / 5）， 但最大不超过900。

如果需要数据库在较短的时间内处理大量连接请求， 可以考虑适当增大back_log 的值。

## 5.3 table_open_cache

该参数用来控制所有SQL语句执行线程可打开表缓存的数量， 而在执行SQL语句时，每一个SQL执行线程至少要打开 1 个表缓存。该参数的值应该根据设置的最大连接数 max_connections 以及每个连接执行关联查询中涉及的表的最大数量来设定 ：

 max_connections x N ；

## 13.4 thread_cache_size

为了加快连接数据库的速度，MySQL 会缓存一定数量的客户服务线程以备重用，通过参数 thread_cache_size 可控制 MySQL 缓存客户服务线程的数量。(在MySQL Server端设置了线程池的大小)

## 13.5 innodb_lock_wait_timeout

该参数是用来设置InnoDB 事务等待行锁的时间，默认值是50s ， 可以根据需要进行动态设置。`对于需要快速反馈的业务系统来说，可以将行锁的等待时间调小，以避免事务长时间挂起； 对于后台运行的批量处理程序来说， 可以将行锁的等待时间调大， 以避免发生大的回滚操作。`

# 6. 应用优化

前面章节，我们介绍了很多数据库的优化措施。但是在实际生产环境中，由于数据库本身的性能局限，就必须要对前台的应用进行一些优化，来降低数据库的访问压力。

## 6.1 使用连接池

对于访问数据库来说，建立连接的代价是比较昂贵的，因为我们频繁的创建关闭连接，是比较耗费资源的，我们有必要建立 数据库连接池，以提高访问的性能。

## 6.2 减少对MySQL的访问

### 6.2.1 避免对数据进行重复检索

在编写应用代码时，需要能够理清对数据库的访问逻辑。能够一次连接就获取到结果的，就不用两次连接，这样可以大大减少对数据库无用的重复请求。

比如 ，需要获取书籍的id 和name字段 ， 则查询如下：

```sql
 select id , name from tb_book;
```

之后，在业务逻辑中有需要获取到书籍状态信息， 则查询如下：

```sql
select id , status from tb_book;
```

这样，就需要向数据库提交两次请求，数据库就要做两次查询操作。其实完全可以用一条SQL语句得到想要的结果。

```sql
select id, name , status from tb_book;
```

### 6.2.2 增加cache层

在应用中，我们可以在应用中增加 缓存 层来达到减轻数据库负担的目的。缓存层有很多种，也有很多实现方式，只要能达到降低数据库的负担又能满足应用需求就可以。

因此可以部分数据从数据库中抽取出来放到应用端以文本方式存储， 或者使用框架(Mybatis, Hibernate)提供的一级缓存/二级缓存，或者使用redis数据库来缓存数据 。

## 6.3 负载均衡

负载均衡是应用中使用非常普遍的一种优化方法，它的机制就是利用某种均衡算法，将固定的负载量分布到不同的服务器上， 以此来降低单台服务器的负载，达到优化的效果。

### 6.3.1 利用MySQL复制分流查询

通过MySQL的主从复制，实现读写分离，使增删改操作走主节点，查询操作走从节点，从而可以降低单台服务器的读写压力。

![1](https://gitee.com/aik-aid/picture/raw/master/1.jpg)

### 6.3.2 采用分布式数据库架构

分布式数据库架构适合大数据量、负载高的情况，它有良好的拓展性和高可用性。通过在多台服务器之间分布数据，可以实现在多台服务器之间的负载均衡，提高访问效率。

# 7. 查询缓存优化

## 7.1 概述

> 开启Mysql的查询缓存，当执行**完全相同**的SQL语句的时候，服务器就会直接从缓存中读取结果，当数据被修改，之前的缓存会失效，修改比较频繁的表不适合做查询缓存。

## 7.2 操作流程

![20180919131632347](https://gitee.com/aik-aid/picture/raw/master/20180919131632347.png)

1. 客户端发送一条查询给服务器；
2. 服务器先会检查查询缓存，如果命中了缓存，则立即返回存储在缓存中的结果。否则进入下一阶段；
3. 服务器端进行SQL解析、预处理，再由优化器生成对应的执行计划；
4. MySQL根据优化器生成的执行计划，调用存储引擎的API来执行查询；
5. 将结果返回给客户端。

## 7.3 查询缓存配置

1. 查看当前的MySQL数据库是否支持查询缓存：

   ```sql
   SHOW VARIABLES LIKE 'have_query_cache';	
   ```

   ![1555249929012](https://gitee.com/aik-aid/picture/raw/master/1555249929012.png)

2. **Mysql8，已经取消了查询缓存** 

3. 查看当前MySQL是否开启了查询缓存 ：

   ```sql
   SHOW VARIABLES LIKE 'query_cache_type';
   ```

   ![1555250015377](https://gitee.com/aik-aid/picture/raw/master/1555250015377.png)

4. 查看查询缓存的占用大小 ：

   ```sql
   SHOW VARIABLES LIKE 'query_cache_size';
   ```

   ![1555250142451](https://gitee.com/aik-aid/picture/raw/master/1555250142451.png)

5. 查看查询缓存的状态变量：

   ```sql
   SHOW STATUS LIKE 'Qcache%';
   ```

   ![1555250443958](https://gitee.com/aik-aid/picture/raw/master/1555250443958.png)

   各个变量的含义如下：

   | 参数                    | 含义                                                         |
   | ----------------------- | ------------------------------------------------------------ |
   | Qcache_free_blocks      | 查询缓存中的可用内存块数                                     |
   | Qcache_free_memory      | 查询缓存的可用内存量                                         |
   | `Qcache_hits`           | `查询缓存命中数`                                             |
   | `Qcache_inserts`        | `添加到查询缓存的查询数`                                     |
   | Qcache_lowmen_prunes    | 由于内存不足而从查询缓存中删除的查询数                       |
   | `Qcache_not_cached`     | `非缓存查询的数量（由于 query_cache_type 设置而无法缓存或未缓存）` |
   | Qcache_queries_in_cache | 查询缓存中注册的查询数                                       |
   | Qcache_total_blocks     | 查询缓存中的块总数                                           |

## 7.4 开启查询缓存

MySQL的查询缓存默认是关闭的，需要手动配置参数 query_cache_type ， 来开启查询缓存。query_cache_type 该参数的可取值有三个 ：

| 值          | 含义                                                         |
| ----------- | ------------------------------------------------------------ |
| OFF 或 0    | 查询缓存功能关闭                                             |
| ON 或 1     | 查询缓存功能打开，SELECT的结果符合缓存条件即会缓存，否则，不予缓存，显式指定 SQL_NO_CACHE，不予缓存 |
| DEMAND 或 2 | 查询缓存功能按需进行，显式指定 SQL_CACHE 的SELECT语句才会缓存；其它均不予缓存 |

在 /usr/my.cnf 配置中，增加以下配置 ：

![1555251383805](https://gitee.com/aik-aid/picture/raw/master/1555251383805.png)

配置完毕之后，重启服务既可生效 ；

然后就可以在命令行执行SQL语句进行验证 ，执行一条比较耗时的SQL语句，然后再多执行几次，查看后面几次的执行时间；获取通过查看查询缓存的缓存命中数，来判定是否走查询缓存。

## 7.5 查询缓存SELECT选项

可以在SELECT语句中指定两个与查询缓存相关的选项 ：

`SQL_CACHE : 如果查询结果是可缓存的，并且 query_cache_type 系统变量的值为ON或 DEMAND ，则缓存查询结果 。`

`SQL_NO_CACHE : 服务器不使用查询缓存。它既不检查查询缓存，也不检查结果是否已缓存，也不缓存查询结果。`

例子：

```sql
SELECT SQL_CACHE id, name FROM customer;
SELECT SQL_NO_CACHE id, name FROM customer;
```

## 7.6 查询缓存失效的情况

1）` SQL 语句不一致的情况， 要想命中查询缓存，查询的SQL语句必须一致。`

```sql
SQL1 : select count(*) from tb_item;
SQL2 : Select count(*) from tb_item; //区别就是第二个是大写
```

2） `当查询语句中有一些不确定的时，则不会缓存。如 ： now() , current_date() , curdate() , curtime() , rand() , uuid() , user() , database() 。`

```sql
SQL1 : select * from tb_item where updatetime < now() limit 1;
SQL2 : select user();
SQL3 : select database();
```

3） `不使用任何表查询语句。`

```sql
select 'A';
```

4）` 查询 mysql， information_schema或 performance_schema 数据库中的表时，不会走查询缓存。`(默认的系统数据库)

```sql
select * from information_schema.engines;
```

5） `在存储的函数，触发器或事件的主体内执行的查询。`

6） `如果表更改，则使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除`。这包括使用`MERGE`映射到已更改表的表的查询。一个表可以被许多类型的语句，如被改变 INSERT， UPDATE， DELETE， TRUNCATE TABLE， ALTER TABLE， DROP TABLE，或 DROP DATABASE 。

