# 1. 行

4种行格式：`Compact` 、`Redundant` 、`Dynamic` 和`Compressed`。主要介绍Compact

<img src="http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/image-20211218222755510.png" alt="image-20211218222755510" style="zoom: 150%;" />

- 变长字段长度列表：逆序存放的；对于CHAR，有可能是变长的(如UTF-8用1~3个字节存，utfmb4用1 ~ 4个字节存)
- NULL值列表：逆序存放，二进制位为1表示该列的值为NULL，0表示不是NULL
- 记录头信息：
  - delete_mask: 为0表示没被删，为1表示被删除了
  - min_rec_mask: B+树的每层非叶子结点中的最小记录都会添加这种这个标记(每个索引页中的主键值最小的记录的会加这个标记)
  - n_owened：所在组有多少条记录
  - heap_no: 当前记录在本页的位置。heap_no为0和1的分别代表Infimum + Supremum。
  - record_type: 当前记录的类型，0表示普通记录，1表示B+树非叶结点记录，2表示最小记录，3表示最大记录
  - next_record: 从当前记录的真实数据到下一条记录的真实数据的地址偏移量（指向的位置向左就是NULL表，右边就是真实数据，这也就是为什么NULL表要逆序）。相当于指针。为0表示没有下一个
- 记录的真实信息：隐藏列有 row_id(非必须)，transaction_id,roll_pointer

这里需要提一下`InnoDB`表对主键的生成策略：

1. 优先使用用户自定义主键作为主键
2. 如果用户没有定义主键，则选取一个`Unique`键作为主键
3. 如果表中连`Unique`键都没有定义的话，则`InnoDB`会为表默认添加一个名为`row_id`的隐藏列作为主键。

---

行溢出数据

- 一行的长度(不包括隐藏列 和 记录头信息) 不超过65535
- 一个列要占据三部分存储空间：真实数据，字段长度，NULL值标识(指定为NOT NULL可以没有这个存储空间)
- 所以varchar没有not null的话最多存65532个字节，因为长度两字节，标识1字节。

# 2. 页

## 2.1 基本概念

1. 因为访问磁盘的效率是非常地下的，所以如果InnoDB 存储引擎是一条一条的把记录从磁盘中读取出来的话，会严重拖慢效率
2. InnoDB 采取的方式是：`将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位`，InnoDB中页的大小一般为 16 KB。

> 页是MySQL 中磁盘和内存交互的基本单位，也是MySQL 是管理存储空间的基本单位。

## 2.2 数据页(索引页)概述

![image-20211218225647267](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/image-20211218225647267.png)

| 名称               | 中文名             | 占用空间大小 | 简单描述                 |
| ------------------ | ------------------ | ------------ | ------------------------ |
| File Header        | 文件头部           | 38字节       | 页的一些通用信息         |
| Page Header        | 页面头部           | 56字节       | 数据页专有的一些信息     |
| Infimum + Supremum | 最小记录和最大记录 | 26字节       | 两个虚拟的行记录         |
| User Records       | 用户记录           | 不确定       | 实际存储的行记录内容     |
| Free Space         | 空闲空间           | 不确定       | 页中尚未被使用的空间     |
| Page Directory     | 页面目录           | 不确定       | 页中的某些记录的相对位置 |
| File Trailer       | 文件尾部           | 8字节        | 检验页是否完整           |

## 2.3 File Header

1. File Header 针对各种类型的页都通用
2. 它描述了一些针对各种页都通用的一些信息，比方说这个页的编号是多少，它的上一个页、下一个页是谁等信息

| 名称                             | 占用空间大小 | 描述                                                         |
| -------------------------------- | ------------ | ------------------------------------------------------------ |
| FIL_PAGE_SPACE_OR_CHKSUM         | 4字节        | 页的校验和（checksum值）                                     |
| FIL_PAGE_OFFSET                  | 4 字节       | 页号                                                         |
| FIL_PAGE_PREV                    | 4 字节       | 上一个页的页号                                               |
| FIL_PAGE_NEXT                    | 4 字节       | 下一个页的页号                                               |
| FIL_PAGE_LSN                     | 8 字节       | 页面被最后修改时对应的日志序列位置（英文名是：Log Sequence Number） |
| FIL_PAGE_TYPE                    | 2 字节       | 该页的类型                                                   |
| FIL_PAGE_FILE_FLUSH_LSN          | 8 字节       | 仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值 |
| FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID | 4 字节       | 页属于哪个表空间                                             |

- FIL_PAGE_PREV 和FIL_PAGE_NEXT

我们前边强调过，`InnoDB`都是以页为单位存放数据的，有时候我们存放某种类型的数据占用的空间非常大（比方说一张表中可以有成千上万条记录），`InnoDB`可能不可以一次性为这么多数据分配一个非常大的存储空间，如果分散到多个不连续的页中存储的话需要把这些页关联起来，`FIL_PAGE_PREV`和`FIL_PAGE_NEXT`就分别代表本页的上一个和下一个页的页号。这样通过建立一个双向链表把许许多多的页就都串联起来了，而无需这些页在物理上真正连着。需要注意的是，并不是所有类型的页都有上一个和下一个页的属性，不过我们本集中唠叨的`数据页`（也就是类型为`FIL_PAGE_INDEX`的页）是有这两个属性的，所以所有的数据页其实是一个双链表，就像这样：

![image-20211219144017599](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/image-20211219144017599.png)

## 2.4 Page Header

设计`InnoDB`的大叔们为了能得到一个数据页中存储的记录的状态信息，比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等，特意在页中定义了一个叫`Page Header`的部分，它是`页`结构的第二部分，这个部分占用固定的`56`个字节，专门存储各种状态信息，具体各个字节都是干嘛的看下表：

| 名称              | 占用空间大小 | 描述                                                         |
| ----------------- | ------------ | ------------------------------------------------------------ |
| PAGE_N_DIR_SLOTS  | `2`字节      | 在页目录中的槽数量                                           |
| PAGE_HEAP_TOP     | `2`字节      | 还未使用的空间最小地址，也就是说从该地址之后就是`Free Space` |
| PAGE_N_HEAP       | `2`字节      | 本页中的记录的数量（包括最小和最大记录以及标记为删除的记录） |
| PAGE_FREE         | `2`字节      | 第一个已经标记为删除的记录地址（各个已删除的记录通过`next_record`也会组成一个单链表，这个单链表中的记录可以被重新利用） |
| PAGE_GARBAGE      | `2`字节      | 已删除记录占用的字节数                                       |
| PAGE_LAST_INSERT  | `2`字节      | 最后插入记录的位置                                           |
| PAGE_DIRECTION    | `2`字节      | 记录插入的方向                                               |
| PAGE_N_DIRECTION  | `2`字节      | 一个方向连续插入的记录数量                                   |
| PAGE_N_RECS       | `2`字节      | 该页中记录的数量（不包括最小和最大记录以及被标记为删除的记录） |
| PAGE_MAX_TRX_ID   | `8`字节      | 修改当前页的最大事务ID，该值仅在二级索引中定义               |
| PAGE_LEVEL        | `2`字节      | 当前页在B+树中所处的层级                                     |
| PAGE_INDEX_ID     | `8`字节      | 索引ID，表示当前页属于哪个索引                               |
| PAGE_BTR_SEG_LEAF | `10`字节     | B+树叶子段的头部信息，仅在B+树的Root页定义                   |
| PAGE_BTR_SEG_TOP  | `10`字节     | B+树非叶子段的头部信息，仅在B+树的Root页定义                 |

## 2.5 记录之间的联系

在记录头信息中有一个`next_record`字段，它表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量。

> 1. 比方说第一条记录的`next_record`值为`32`，意味着从第一条记录的真实数据的地址处向后找`32`个字节便是下一条记录的真实数据。
> 2. `下一条记录`指得并不是按照我们插入顺序的下一条记录，而是按照主键值由小到大的顺序的下一条记录。
> 3. 而且规定 ***Infimum记录（也就是最小记录）*** 的下一条记录就本页中主键值最小的用户记录，而本页中主键值最大的用户记录的下一条记录就是 ***Supremum记录（也就是最大记录）***

![image-20211219144857367](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/image-20211219144857367.png)

从图中可以看出来，我们的记录按照主键从小到大的顺序形成了一个单链表。

## 2.6 Page Directory

现在我们了解了记录在页中按照主键值由小到大顺序串联成一个单链表，那如果我们想根据主键值查找页中的某条记录该咋办呢？比如说这样的查询语句：

```mysql
SELECT * FROM page_demo WHERE c1 = 3;
```

最笨的办法：从`Infimum`记录（最小记录）开始，沿着链表一直往后找，总有一天会找到（或者找不到[摊手]），在找的时候还能投机取巧，因为链表中各个记录的值是按照从小到大顺序排列的，所以当链表的某个节点代表的记录的主键值大于你想要查找的主键值时，你就可以停止查找了，因为该节点后边的节点的主键值依次递增。

这个方法在页中存储的记录数量比较少的情况用起来也没啥问题，但是如果一个页中存储了非常多的记录，这么查找对性能来说还是有损耗的，所以设计`InnoDB`的人从书的目录中找到了灵感。

我们平常想从一本书中查找某个内容的时候，一般会先看目录，找到需要查找的内容对应的书的页码，然后到对应的页码查看内容。设计`InnoDB`的大叔们为我们的记录也制作了一个类似的目录，他们的制作过程是这样的：

1. 将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组。
2. 每个组的最后一条记录（也就是组内最大的那条记录）的头信息中的`n_owned`属性表示该记录拥有多少条记录，也就是该组内共有几条记录。
3. 将每个组的最后一条记录的`真实数据地址偏移量`单独提取出来按顺序存储到靠近`页`的尾部的地方，这个地方就是所谓的`Page Directory`，也就是`页目录`（此时应该返回头看看页面各个部分的图）。页面目录中的这些地址偏移量被称为`槽`（英文名：`Slot`），所以这个页面目录就是由`槽`组成的。
4. 其中最小记录所在的分组只能由一条记录，最大记录所在的分组有1~8条记录，剩下的分组中记录的范围在4 ~ 8 之间

比方说现在的`page_demo`表中正常的记录共有6条，`InnoDB`会把它们分成两组，第一组中只有一个最小记录，第二组中是剩余的5条记录，看下边的示意图：

![image-20211219150914846](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/image-20211219150914846.png)

现在看怎么从这个`页目录`中查找记录。因为各个槽代表的记录的主键值都是从小到大排序的，所以我们可以使用所谓的`二分法`来进行快速查找。4个槽的编号分别是：`0`、`1`、`2`、`3`、`4`，所以初始情况下最低的槽就是`low=0`，最高的槽就是`high=4`。比方说我们想找主键值为`5`的记录，过程是这样的：

1. 目的是找到第一个比本记录主键大的槽
2. 计算中间槽的位置：`(0+4)/2=2`，所以查看`槽2`对应记录的主键值为`8`，又因为`8 > 5`，所以设置`high=2`，`low`保持不变。
3. 重新计算中间槽的位置：`(0+2)/2=1`，所以查看`槽1`对应的主键值为`4`。所以设置`low=1`，`high`保持不变。
4. 因为`high - low`的值为1，所以确定主键值为`5`的记录在`槽2`对应的组中，接下来就是通过遍历`槽2`对应的组的链表来进行查找了。由于一个组中包含的记录条数只能是1~8条，所以遍历一个组中的记录的代价是很小的。

所以在一个数据页中查找指定主键值的记录的过程分为两步：

1. 通过二分法确定该记录所在的槽。
2. 通过记录的`next_record`属性遍历该槽所在的组中的各个记录。

## 2.7 File Trailer

我们知道`InnoDB`存储引擎会把数据存储到磁盘上，但是磁盘速度太慢，需要以`页`为单位把数据加载到内存中处理，如果该页中的数据在内存中被修改了，那么在修改后的某个时间需要把数据同步到磁盘中。但是在同步了一半的时候中断电了咋办，这不是莫名尴尬么？为了检测一个页是否完整（也就是在同步的时候有没有发生只同步一半的尴尬情况），设计`InnoDB`的大叔们在每个页的尾部都加了一个`File Trailer`部分，这个部分由`8`个字节组成，可以分成2个小部分：

- 前4个字节代表页的校验和

  这个部分是和`File Header`中的校验和相对应的。每当一个页面在内存中修改了，在同步之前就要把它的校验和算出来，因为`File Header`在页面的前边，所以校验和会被首先同步到磁盘，当完全写完时，校验和也会被写到页的尾部，如果完全同步成功，则页的首部和尾部的校验和应该是一致的。如果写了一半儿断电了，那么在`File Header`中的校验和就代表着已经修改过的页，而在`File Trialer`中的校验和代表着原先的页，二者不同则意味着同步中间出了错。

- 后4个字节代表页面被最后修改时对应的日志序列位置（LSN）

  这个部分也是为了校验页的完整性的，只不过我们目前还没说`LSN`是个什么意思，所以大家可以先不用管这个属性。

这个`File Trailer`与`FILE Header`类似，都是所有类型的页通用的。

# 3.  表空间

1. 虽然我们有了页，B+树中同一层级的页通过前后指针相连，但是这个相连是逻辑上的相连，不是物理上的。因此相连的两个页离得很远的话，那么就是随机IO，随机IO的速度非常慢。
2. 因此才引入了区的概念，所谓区就是物理上连续的64个页组成的，也就是1MB.这样顺序相连的页使用的就是`顺序IO`了，速度会快很多
3. 其中叶子节点有自己独有的区，非叶子节点也有自己独有的区。
4. 存放叶子节点的区的集合就算是一个段，同理存放非叶子节点的区也算一个段
5. 表空间就可以认为这两个段的集合

# 4. Buffer

## 4.1 为什么要引入Buffer

1. 以InnoDB为存储引擎的数据库，数据是放在磁盘当中的。但如果每次读写都要进行磁盘IO，那么效率会非常低
2. 为此，InnoDB提供了Buffer Pool。
3. 数据是以页为单位的。查询一条记录，会从硬盘把一个数据页加载进Buffer Pool。更新数据也是直接在Buffer Pool中更新。
5. Buffer默认大小为128MB

## 4.2 Buffer的内部组成

1. `控制块`：为了更好的管理Buffer中的缓存页，Buffer为每个缓存页都创建了一个控制块，来记录该页所属的表空间，页号，地址等

![image-20220105200541591](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/image-20220105200541591.png)

2. `缓存页的哈希处理`: 把`表空间号+页号`作为key，`缓存页`作为value，维护一个哈希表，这样我们就可以快速判定页是不是在Buffer Pool中

3. `free List`：空闲链表

- 把所有空闲的缓存页所对应的控制块作为一个节点放入其中。

- 每次加载一个页到Buffer Pool中，就从free 链表中取一个空闲的缓存页，然后把该空闲页对应的节点从链表中移除。

4. `flush list`: 存储脏页的链表

- 每次修改了缓存页以后，如果把他立刻同步到磁盘上，性能损耗很大。所以我们采取在未来的某个时间节点进行同步，至于缺点哪些是脏页就需要借助`flush list`
- 把修改过的缓存页的控制块作为节点加入到flush list中

5. `LRU list`: 用来确定哪些页面要在缓存不够的时候被替换出去

- 将LRU链表分为两部分，左边一部分为young区域（存储使用频率高的缓存页），右边一部分为old取（存储使用频率不高的区域）
- 划分的比例是由`innodb_old_blocks_pct`决定的，innodb默认为37，表示old区域占据LRU链表的比例（可以解决预加载问题）
- 新进来的缓存
- 朴素lru的缺点：如果直接放到头部的话，那么面对全表扫描这种情况，就会导致热点页被移除，留下来的是非热点页

## 4.3 刷新脏页到磁盘

CheckPoint

1. MySQL 正常关闭时，会把内存的脏页都 flush 到磁盘上
2. 系统空闲时，后台线程会自动进行刷脏。每s或者每10s从缓冲池中的`脏页列表`刷新一定比例的页，`异步的`
3. 根据LRU算法回溢出最近最少使用的页，如果此页为脏页，那么需要强制执行刷新到磁盘中取
4. redo log 文件是固定大小的，如果写满了就要擦除以前的记录，在擦除之前需要把旧记录更新到磁盘中的数据文件中
5. 脏页太多了，也会强制进行刷脏。

---

后台由专门的线程每隔一段时间负责把脏页刷新到磁盘，主要有两种刷新路径

- 从`LRU链表`的old区中刷新一部分页面到磁盘
- 从`flush`链表中刷新一部分到磁盘

还有

- `BUF_FLUSH_SINGLE_PAGE`当用户线程在加载一个页面进磁盘时，这时候没有可用内存了，而且LRU尾部没有直接可以直接释放掉的未修改的页面，那么这时候就会将LRU链表尾部的一个脏页刷新到磁盘。
