# 1. 体系结构

## 1.1 整体架构

1. 网络连接层：包括通信协议、线程处理、用户名密码认证三个部分。

- 检测客户端版本是否兼容MySQL服务端。
- 为每一个连接请求分配一个线程
- 验证用户名密码以及对应主机是否可以连接到Mysql服务器

2. Server层: 所有**跨存储引擎的功能**在这一层实现，如存储过程、触发器、视图等

- `SQL Interface`: 接受用户的 SQL 命令，并且返回用户需要查询的结果

- `查询缓存`(Caches & Buffers)通过 Query Cache 进行操作，如果数据在 Query Cache 中，则直接返回结果给客户端。（Mysql8删除了）
- `分析器`(Parser)：进行词法分析将语句识别为对应的SQL语句，进行语法分析判断语法是否正确。
- `优化器`(Optimizer)：确定是否选用索引，选取哪个索引，多表时的查询顺序.
- `执行器`：通过调用对应存储引擎的API实现数据的提取和存储。
- `Management Serveices & Utilities`：系统管理和控制工具，备份、安全、复制、集群等

3. 存储引擎层:

- 真正负责数据的存储和提取

4. 系统文件层

- 数据存储层，主要是将数据存储在文件系统之上，并完成与存储引擎的交互

![image-20210828094155978](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/image-20210828094155978.png)

## 1.2 连接器

1. 连接器使用池化技术，来提高线程利用率，减少线程的频繁创建和关闭
2. 如果太长时间没动静，连接器就会自动断开，这个时间是由参数 wait_timeout 控制的，默认值是 8 小时，再次使用这个连接进行访问会报错
3. 长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接；短连接是指执行几次就断开。推荐使用长连接
4. 长连接期间会将一些数据到内存中，过长的连接会导致OOM

- 定期断开长连接
- 执行 `mysql_reset_connection` 使得连接恢复到刚创建完，而且不需要重连和重做权限验证

## 1.3 查询缓存

大多数情况下不建议使用查询缓存，因为查询缓存往往弊大于利，失效非常频繁；

缓存失效的场景

- SQL 语句不一致的情况
- 如果表更改，则使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除
- 使用一些函数，如now(),current_date(),user()等
- 不使用任何表查询语句

## 1.4 优化器

优化什么

- 表里面有多个索引的时候，决定使用哪个索引

- 一个语句有多表关联（join）的时候，决定各个表的连接顺序。

优化方案：选取IO成本 + CPU成本

- **IO 成本**: 把磁盘加载进内存的成本，一页的成本是1
- **CPU 成本**：将数据读入内存后，还要检测数据是否满足条件和排序等 CPU 操作的成本；检测记录的成本是 0.2。

确定扫描行数

- Mysql不能准确知道，只能根据统计信息来估算记录

# 2. 存储引擎

## 2.1 基本介绍

1. 存储引擎就是`存储数据`，`建立索引`，`锁`，`外键`等等技术的实现方式 。
2. 存储引擎是基于表的，而不是基于库的。所以存储引擎也可被称为表类型。
3. mysql支持插件式的存储引擎,从而在不同场景选用不同存储引擎，达到更好的效果

MySQL 支持的存储引擎：

- MySQL 支持的引擎包括：InnoDB、MyISAM、MEMORY、Archive、Federate、CSV、BLACKHOLE 等
- MySQL5.5 之前的默认存储引擎是 MyISAM，5.5 之后就改为了 InnoDB

## 2.2 引擎对比

* 事务：InnoDB 支持事务，MyISAM 和 Memory 不支持事务
* 外键：InnoDB 支持外键，MyISAM 和 Memory 不支持外键
* 索引：InnoDB 是聚集（聚簇）索引，MyISAM 是非聚集（非聚簇）索引，Memory使用Hash索引。
* 锁粒度：InnoDB 最小的锁粒度是行锁，MyISAM 和 Memory 最小的锁粒度是表锁
* MVCC: InnoDB 支持 MVCC, 而 MyISAM 不支持 MVCC；
* 存储结构：InnoDB数据和索引是一起存储的；MyISAM的数据和索引是分开存储的（.MYD存储数据，.MYI存储索引）。Memory的表数据存储在内存当中，结构存储在磁盘中

- InnoDB 不保存表的具体行数。而 MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快：

- 应用场景
  - MyISAM：适合对于事务的完整性没有要求，以读和插入操作为主，只有极少的更新和删除
  - MEMORY：表的数据不是很多，对于需要快速定位记录可以提高极快的访问速度
  - InnoDB：如果对于事务要求高，并发下要求数据的一致性，除了查询和插入以外，还有很多更新和删除的，选择InnoDB

> Merge是一组MyISAM表的集合，这些MyISAM表必须结构完全相同。

## 2.3 引擎操作

* 查询数据库支持的存储引擎

  ```mysql
  SHOW ENGINES;
  SHOW VARIABLES LIKE '%storage_engine%'; -- 查看Mysql数据库默认的存储引擎 
  ```

* 查询某个数据库中所有数据表的存储引擎

  ```mysql
  SHOW TABLE STATUS FROM 数据库名称;
  ```

* 查询某个数据库中某个数据表的存储引擎

  ```mysql
  SHOW TABLE STATUS FROM 数据库名称 WHERE NAME = '数据表名称';
  ```

* 创建数据表，指定存储引擎

  ```mysql
  CREATE TABLE 表名(
  	列名,数据类型,
      ...
  )ENGINE = 引擎名称;
  ```

* 修改数据表的存储引擎

  ```mysql
  ALTER TABLE 表名 ENGINE = 引擎名称;
  ```

# 3. 范式

## 3.1 前置知识

### 3.1.1 各种名词

**关系**：对应一个表

**元组（tuple）**：每一个行就是元组

**属性（attribute）**：列的名字

**候选键（prime attribute）**：由关系的一个或多个属性组成，候选键都具备键的特征，都有资格成为主键。

**主属性（prime attribute）**：所有候选键所包含的属性都是主属性。

**外键（foreign key）**：如果某一个关系A中的一个（组）属性是另一个关系B的键，则该（组）属性在A中称为外键。

**依赖（relation）**：列属性间存在的某种联系。

### 3.1.2 依赖

- 函数依赖：A → B，如果通过 A 属性(属性组)的值，可以确定唯一 B 属性的值，则称 B 依赖于 A
- 完全函数依赖：A → B，如果A是一个属性组，则 B 属性值的确定需要依赖于 A 属性组的所有属性值
- 部分函数依赖：A → B，如果 A 是一个属性组，则 B 属性值的确定只需要依赖于 A 属性组的某些属性值
- 传递函数依赖：A → B，B → C，如果通过A属性(属性组)的值，可以确定唯一 B 属性的值，在通过 B 属性(属性组)的值，可以确定唯一 C 属性的值，则称 C 传递函数依赖于 A

## 3.2 第一范式

属性（对应于表中的字段）不能再被分割，也就是这个字段只能是一个值，不能再分为多个其他的字段了。**1NF 是所有关系型数据库的最基本要求** ，也就是说关系型数据库中创建的表一定满足第一范式。

简而言之，**第一范式每一列不可再拆分，称为原子性**

## 3.3 第二范式

介绍第二范式

> **2NF：**在满足第一范式的基础上，非主属性完全依赖于键码(候选码)，消除非主属性对主码的部分函数依赖。简而言之，**表中的每一个字段 （所有列）都完全依赖于主键，记录的唯一性**

作用：遵守第二范式减少数据冗余，通过主键区分相同数据。



**分解前**

| Sno  | Sname  | Sdept  | Mname  | Cname  | Grade |
| :--: | :----: | :----: | :----: | :----: | :---: |
|  1   | 学生-1 | 学院-1 | 院长-1 | 课程-1 |  90   |
|  2   | 学生-2 | 学院-2 | 院长-2 | 课程-2 |  80   |
|  2   | 学生-2 | 学院-2 | 院长-2 | 课程-1 |  100  |
|  3   | 学生-3 | 学院-2 | 院长-2 | 课程-2 |  95   |

以上学生课程关系中，{Sno, Cname} 为键码，有如下函数依赖:

- Sno -> Sname, Sdept
- Sdept -> Mname
- Sno, Cname-> Grade

Grade 完全函数依赖于键码，它没有任何冗余数据，每个学生的每门课都有特定的成绩。

Sname, Sdept 和 Mname 都部分依赖于键码，当一个学生选修了多门课时，这些数据就会出现多次，造成大量冗余数据。

**分解后**

关系-1

| Sno  | Sname  | Sdept  | Mname  |
| :--: | :----: | :----: | :----: |
|  1   | 学生-1 | 学院-1 | 院长-1 |
|  2   | 学生-2 | 学院-2 | 院长-2 |
|  3   | 学生-3 | 学院-2 | 院长-2 |

有以下函数依赖:

- Sno -> Sname, Sdept
- Sdept -> Mname

关系-2

| Sno  | Cname  | Grade |
| :--: | :----: | :---: |
|  1   | 课程-1 |  90   |
|  2   | 课程-2 |  80   |
|  2   | 课程-1 |  100  |
|  3   | 课程-2 |  95   |

有以下函数依赖:

- Sno, Cname -> Grade

## 3.4 第三范式

**3NF：**在满足第二范式的基础上，消除传递依赖。简而言之，**非主键都直接依赖于主键，而不是通过其它的键来间接依赖于主键**。

作用：可以通过主键 id 区分相同数据，修改数据的时候只需要修改一张表（方便修改），反之需要修改多表。



非主属性不传递函数依赖于键码。

上面的 关系-1 中存在以下传递函数依赖:

- Sno -> Sdept -> Mname

可以进行以下分解:

关系-11

| Sno  | Sname  | Sdept  |
| :--: | :----: | :----: |
|  1   | 学生-1 | 学院-1 |
|  2   | 学生-2 | 学院-2 |
|  3   | 学生-3 | 学院-2 |

关系-12

| Sdept  | Mname  |
| :----: | :----: |
| 学院-1 | 院长-1 |
| 学院-2 | 院长-2 |

## 3.5 总结

- 1NF：属性不可再分。
- 2NF：1NF 的基础之上，消除了非主属性对于码的部分函数依赖。
- 3NF：3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖 。

