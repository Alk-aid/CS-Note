# 1. 几个有趣的位操作

1. **利用或操作 `|` 和空格将英文字符转换为小写**

```c
('a' | ' ') = 'a'
('A' | ' ') = 'a'
```

1. **利用与操作 `&` 和下划线将英文字符转换为大写**

```c
('b' & '_') = 'B'
('B' & '_') = 'B'
```

1. **利用异或操作 `^` 和空格进行英文字符大小写互换**

```c
('d' ^ ' ') = 'D'
('D' ^ ' ') = 'd'
```

以上操作能够产生奇特效果的原因在于 ASCII 编码。字符其实就是数字，恰巧这些字符对应的数字通过位运算就能得到正确的结果，有兴趣的读者可以查 ASCII 码表自己算算，本文就不展开讲了。

1. **判断两个数是否异号**

```cpp
int x = -1, y = 2;
bool f = ((x ^ y) < 0); // true

int x = 3, y = 2;
bool f = ((x ^ y) < 0); // false
```

这个技巧还是很实用的，利用的是补码编码的符号位。如果不用位运算来判断是否异号，需要使用 if else 分支，还挺麻烦的。读者可能想利用乘积或者商来判断两个数是否异号，但是这种处理方式可能造成溢出，从而出现错误。

1. **不用临时变量交换两个数**

```c
int a = 1, b = 2;
a ^= b;
b ^= a;
a ^= b;
// 现在 a = 2, b = 1
```

1. **加一**

```c
int n = 1;
n = -~n;
// 现在 n = 2
```

1. **减一**

```c
int n = 2;
n = ~-n;
// 现在 n = 1
```

PS：上面这三个操作就纯属装逼用的，没啥实际用处，大家了解了解乐呵一下就行。



# 2 n&(n-1)

## 2.1 思想

```java
while(n!=0){
    count++;
    n=n&()
}
```



`n&(n-1)` 这个操作是算法中常见的，作用是消除数字 `n` 的二进制表示中的最后一个 1。

![img](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/1.png)

其核心逻辑就是，`n - 1` 一定可以消除最后一个 1，同时把其后的 0 都变成 1，这样再和 `n` 做一次 `&` 运算，就可以仅仅把最后一个 1 变成 0 了。

## 2.2 用途

### I 汉明码

![img](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/title.png)

就是让你返回 n 的二进制表示中有几个 1。因为 n & (n - 1) 可以消除最后一个 1，所以可以用一个循环不停地消除 1 同时计数，直到 n 变成 0 为止。

```java
int hammingWeight(uint32_t n) {
    int res = 0;
    while (n != 0) {
        n = n & (n - 1);
        res++;
    }
    return res;
}

```

### II 判断一个数是不是2的指数

一个数如果是 2 的指数，那么它的二进制表示一定只含有一个 1：

```java
bool isPowerOfTwo(int n) {
    if (n <= 0) return false;
    return (n & (n - 1)) == 0;
}
```

### III 查找只出现一次的数

```java
int singleNumber(vector<int>& nums) {
    int res = 0;
    for (int n : nums) {
        res ^= n;
    }
    return res;
}

```

# 3. n&(~n+1)

提取出最右的1

等价于

```java
int div = 1;
while ((div & ret) == 0)
    div <<= 1;
```

等价于

```
n & -n 
```

# 1. [汉明距离](https://leetcode-cn.com/problems/hamming-distance/)

## 1.1 题目

两个整数之间的 [汉明距离](https://baike.baidu.com/item/汉明距离) 指的是这两个数字对应二进制位不同的位置的数目。

给你两个整数 `x` 和 `y`，计算并返回它们之间的汉明距离。

```
输入：x = 1, y = 4
输出：2
解释：
1   (0 0 0 1)
4   (0 1 0 0)
       ↑   ↑
上面的箭头指出了对应二进制位不同的位置。
```

## 1.2 题解一

大多数编程语言都内置了计算二进制表达中 1 的数量的函数。在工程中，我们应该直接使用内置函数。

```java
class Solution {
    public int hammingDistance(int x, int y) {
        return Integer.bitCount(x ^ y);
    }
}
```

**复杂度分析**

- 时间复杂度：O(1)*O*(1)。不同语言的实现方法不一，我们可以近似认为其时间复杂度为 O(1)*O*(1)。
- 空间复杂度：O(1)*O*(1)

## 1.3 题解二

移位实现位计数

```java
class Solution {
    public int hammingDistance(int x, int y) {
        int s = x ^ y, ret = 0;
        while (s != 0) {
            ret += s & 1;
            s >>= 1;
        }
        return ret;
    }
}
```

**复杂度分析**

- 时间复杂度：*O*(log*C*)，其中 C*C* 是元素的数据范围，在本题中log*C*=log(2^31)=31。
- 空间复杂度：O*(1)。

## 1.4 题解三

Brian Kernighan 算法

在方法二中，对于 s=(10001100)2 的情况，我们需要循环右移 8 次才能得到答案。而实际上如果我们可以跳过两个 1 之间的 0，直接对 1 进行计数，那么就只需要循环 3 次即可。

我们可以使用Brian Kernighan 算法进行优化，具体地，该算法可以被描述为这样一个结论：记 f(x) 表示 x 和 x−1 进行与运算所得的结果（即 f(x)=x & (x-1)），那么 f(x) 恰为 x 删去其二进制表示中最右侧的 1 的结果。该运算将 x*x* 的二进制表示的最后一个 1变成 0

基于该算法，当我们计算出 s = *x*⊕*y*，只需要不断让 s = f(s)，直到 s=0即可。这样每循环一次，*s* 都会删去其二进制表示中最右侧的 1，最终循环的次数即为 *s* 的二进制表示中 1 的数量。

```java
class Solution {
    public int hammingDistance(int x, int y) {
        int s = x ^ y, ret = 0;
        while (s != 0) {
            s &= s - 1;
            ret++;
        }
        return ret;
    }
}
```

**复杂度分析**

- 时间复杂度：*O*(log*C*)，其中 C*C* 是元素的数据范围，在本题中log*C*=log(2^31)=31。
- 空间复杂度：O*(1)。

# 2. [216. 组合总和 III](https://leetcode-cn.com/problems/combination-sum-iii/)

找出所有相加之和为 ***n*** 的 ***k\*** 个数的组合***。\***组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。

**说明：**

- 所有数字都是正整数。
- 解集不能包含重复的组合。 

**示例 1:**

```
输入: k = 3, n = 7
输出: [[1,2,4]]
```

**示例 2:**

```
输入: k = 3, n = 9
输出: [[1,2,6], [1,3,5], [2,3,4]]
```

---

本题也可以用回溯法,不过这里介绍位运算法

---

![image-20210719233825364](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/image-20210719233825364.png)

```java
class Solution {
    List<List<Integer>> res=new ArrayList<>();
    List<Integer> path =new ArrayList<>();
    public List<List<Integer>> combinationSum3(int k, int n) {
        for(int mask=0;mask < (1 << 9) ;mask++){
            if(check(k,n,mask)){
                res.add(new ArrayList<>(path));
            }
        }
        return res;
    }
    public boolean check(int k,int n, int mask){
        path.clear();
        for(int i=0;i<9;i++){
            if(((mask >> i) & 1) !=0  ){
                path.add(i+1);
            }
        }
        if(path.size()!=k)
            return false;
        int sum=0;
        for( int num : path){
            sum+=num;
        }
        return sum==n;
    }
}
```

# 3. [颠倒二进制位](https://leetcode-cn.com/problems/reverse-bits/)

```java
public class Solution {
    // you need treat n as an unsigned value
    public int reverseBits(int n) {
        int res=0;
        for(int i=0;i<32 && n!=0;i++){
            res |=(n&1)<<(31-i);
            n>>=1;
        }
        return res;
    }
}
```

1. n&1 就是将n的最后一位取反 值为0 或者 1

# 4. [数字的补数](https://leetcode-cn.com/problems/number-complement/)

```java
class Solution {
    public int findComplement(int num) {
        int pow=1;
        int res=0;
        while(num > 0){
            int old= num & 1;
            int cur=old^=1;
            res+=pow*cur;
            pow*=2;
            num>>=1;
        }
        return res;
    }
}
```

