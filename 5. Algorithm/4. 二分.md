# 0. 技巧

1. 排序数组中的搜索问题，首先想到 二分法 解决

# 1. 模板

使用左闭右开比较好，可以统一

## 1.1 左闭右开法

```java
int binarySearch(int[] nums,int target){
    int left = 0, right = nums.length;
    while(left < right){
        int mid = left + (right - left) / 2;
        if (nums[mid] < target){
            left = mid + 1;
        } else if (nums[mid] > target){
            right = mid;
        } else {
            return mid;
        }
    }
}
//采用左闭右开的写法
public int LeftBinary(int[] nums, int target){
    int left = 0, right = nums.length;
    while (left < right){
        int mid = left + (right - left) / 2;
        if (nums[mid] < target){
            left = mid + 1;
        } else if (nums[mid] > target){
            right = mid;
        } else {
            right = mid;
        }
    }
    if (left == nums.length || nums[left] != target)
        return -1;
    return left;
}
public int RightBinary(int[] nums, int target){
    int left = 0, right = nums.length;
    while (left < right){
        int mid = left + (right - left) / 2;
        if (nums[mid] < target){
            left = mid + 1;
        } else if (nums[mid] > target){
            right = mid;
        } else {
            left =mid + 1;
        }
    }
    if (left == 0 || nums[left-1] != target)
        return -1;
    return left - 1;
}
```

## 1.2 左闭右闭法

```java
//采用左闭右闭的写法
public int LeftBinary(int[] nums, int target){
    int left = 0, right = nums.length - 1;
    while (left <= right){
        int mid = left + (right - left) / 2;
        if (nums[mid] < target){
            left = mid + 1;
        } else if (nums[mid] > target){
            right = mid - 1;
        } else {
            right = mid - 1;
        }
    }
    if (left == nums.length || nums[left] != target)
        return -1;
    return left;
}
public int RightBinary(int[] nums, int target){
    int left = 0, right = nums.length-1;
    while (left <= right){
        int mid = left + (right - left) / 2;
        if (nums[mid] < target){
            left = mid + 1;
        } else if (nums[mid] > target){
            right = mid - 1;
        } else {
            left =mid + 1;
        }
    }
    if (left == 0 || nums[left-1] != target)
        return -1;
    return left - 1;
}
```

## 1.3 总结

1. left的取值范围是 [0,nums.length],所以最后要进行越界判断

# 2. 旋转数组

## 2.1 [搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)

### 2.1.1 我的解法

```java
class Solution {
    public int search(int[] nums, int target) {
        int minIndex = 0;
        for (int i = 0; i< nums.length-1; i++){
            if (nums[i] > nums[i+1]){
                minIndex = i+1;
                break;
            }
        }
        int left = 0, right = 0;

        if (target <= nums[nums.length - 1]){
            left = minIndex;
            right = nums.length - 1;
        }
        else{
            left = 0;
            right = minIndex - 1;
        } 
        int res = binarySearch(nums,target,left,right);
        return res;
    }
    private int binarySearch(int[] nums, int target, int x, int y){
        int left = x, right = y;
        while (left <= right){
            int mid = left + (right - left) / 2;
            if (nums[mid] < target)
                left = mid + 1;
            else if (nums[mid] > target)
                right = mid -1;
            else 
                return mid;
        }
        return -1;
    }
}
```

我是通过找到临界点，将数组分为两个有序的子数组，然后对其进行二分查找

### 2.1.2 优秀解法

```java
class Solution {
    public int search(int[] nums, int target) {
        int left = 0, right = nums.length;
        while (left < right){
            int mid = left + (right - left) / 2;
            if (nums[mid]  == target)   return mid;
            // 在左半部
            if (nums[mid] > nums[nums.length - 1]){
                if (nums[0] <= target && target < nums[mid]) right = mid;
                else left = mid + 1;
            }
            // 在右半部
            else{
               if (nums[mid] < target && target <= nums[nums.length - 1])   left = mid + 1;
               else right = mid;
            }
        }
        return nums[left] == target ? left : -1;
    }
}
```

时间复杂度: O*(log*n*)

### 2.1.3 获得的思考

1. 不管是完全有序，还是部分有序，遇到这种数组题目都要考虑是否可以通过二分查找来进行实现

## 2.2 [搜索旋转排序数组 II](https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/)

### 2.2.1 解法

```java
class Solution {
    public boolean search(int[] nums, int target) {
        int left = 0, right = nums.length;
        while (left < nums.length && nums[left] == nums[nums.length - 1])
            left++;
        if (left == nums.length)  return nums[0] == target;
        int start = left;
        while (left < right){
            int mid = left + (right - left) / 2;
            if (nums[mid] == target)    return true;
            // 在左半部
            if (nums[mid] > nums[nums.length - 1]){
                if (nums[start] <= target && target < nums[mid]) right = mid;
                else left = mid + 1;
            } else {
                if (nums[mid] < target && target <= nums[nums.length - 1])   left = mid + 1;
                else right = mid;
            }
        }
        return false;
    }
}
```

## 2.3 [ 寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)

之所以比较的是最右边的值，而不是最左边的值是因为考虑了不旋转的情况。

```java
class Solution {
    public int findMin(int[] nums) {
        int left = 0, right =nums.length,len = nums.length;
        while (left < right){
            int mid = left + (right - left) / 2;
            
            if(nums[mid] > nums[len - 1]){
                left = mid + 1;
            }
            else {
                if (mid == 0 || nums[mid] < nums[mid - 1]) 
                    return nums[mid];
                right = mid;
            }
        }
        return -1;
    }
}
```

## 2.4 [寻找旋转排序数组中的最小值 II](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/)

```java
class Solution {
    public int findMin(int[] nums) {
        if (nums.length == 1)
            return nums[0];
        int left = 0, right = nums.length;
        while (left != nums.length && nums[left] == nums[nums.length - 1])
            left++;
        if (left == nums.length) return nums[0];
        while (left < right){
            int mid = left + (right - left) / 2;
            if (nums[mid] > nums[nums.length - 1]) 
                left = mid + 1;
            else {
                if (mid == 0 || nums[mid] < nums[mid -1])   return nums[mid];
                else right = mid;
            }
        }
        return nums[left];
    }
}
```



# 3. [在排序数组中查找数字 I](https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/)

```java
class Solution {
    public int search(int[] nums, int target) {
        int leftIndex = leftBinarySearch(nums,target);
        int rightIndex = rightBinarySearch(nums,target);
        if (leftIndex == -1 || rightIndex == -1 ) return 0;
        return rightIndex - leftIndex + 1;
    }
    public int leftBinarySearch(int[] nums, int target){
        int left = 0, right = nums.length;
        while (left < right){
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) left = mid + 1;
            else if (nums[mid] > target) right = mid;
            else right = mid;
        }
        return left == nums.length ? -1 : left;
    }
    public int rightBinarySearch(int[] nums, int target){
        int left = 0, right = nums.length;
        while (left < right){
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) left = mid + 1;
            else if (nums[mid] > target) right = mid;
            else left = mid + 1;
        }
        return left == -1 ? -1 : left -1 ;
    }
}
```

# 4. [二维数组中的查找](https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/)

<img src="http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/6584ea93812d27112043d203ea90e4b0950117d45e0452d0c630fcb247fbc4af-Picture1.png" alt="Picture1.png" style="zoom: 33%;" />

```java
class Solution {
    public boolean findNumberIn2DArray(int[][] matrix, int target) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0)
            return false;
        int n = matrix.length, m = matrix[0].length;
        int i = 0, j = m -1;
        while (i < n && j >= 0){
            if (matrix[i][j] > target) j--;
            else if (matrix[i][j] < target) i++;
            else return true;
        }
        return false;
    }
}
```

