| 排序法 | 平均时间 | 最差情形 | 稳定度 | 额外空间 | 备注                          |
| ------ | -------- | -------- | ------ | -------- | ----------------------------- |
| 冒泡   | O($n^2$) | O($n^2$) | 稳定   | O(1)     | n小时较好                     |
| 选择   | O(n2)    | O($n^2$) | 不稳定 | O(1)     | n小时较好                     |
| 插入   | O(n2)    | O($n^2$) | 稳定   | O(1)     | 大部分已排序时较好            |
| 基数   | O(logRB) | O(logRB) | 稳定   | O(n)     | B是真数(0-9)，R是基数(个十百) |
| 快速   | O(nlogn) | O(n2)    | 不稳定 | O(nlogn) | n大时较好                     |
| 归并   | O(nlogn) | O(nlogn) | 稳定   | O(1)     | n大时较好                     |
| 堆     | O(nlogn) | O(nlogn) | 不稳定 | O(1)     | n大时较好                     |

# 1. 异或

两个数出现奇数次，其他所有的数都出现偶数次，找出这个出现奇数次的数 要求时间O(N)，空间O(1)

![image-20210415231128552](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/image-20210415231128552.png)

# 2 冒泡排序

冒泡排序的本质是交换排序

```java
for(int e=nums.length-1;e>0;e--) // 
{
    for(int i=0;i<e;i++){
        if(arr[i]>arr[i+1])
            swap(a,i,i+1);
    }
}
```

# 3 选择排序

```java
for(int i=0;i<arr.len-1;i++){ //【0,i-1】是位置正确的，现在要处理第i点的位置
    int minIndex=i;
    for(int j=i+1;j<=arr.len-1;j++){
        minIndex=arr[j]<arr[minIndex]?j:minIndex;
    }
    swap(arr,minIndex,i);
}
```

# 4 插入排序

前面两个算法流程和数据状况是无关的,但是这个和数据状况是有关的

```java
//0~i-1上的数有序 然后将i上的数插入到前面有序数组的合适位置
for(int i=1;i<arr.len;i++){// [0,i-1]是有序的 -> [0,i]是有序的 所以要操作第i点
    for(int j=i-1;j>=0&&arr[j]>arr[j+1];j--)
        swap(arr,j,j+1);
}

```

# 5. 归并排序

空间复杂度O(N)

![image-20210817104539604](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/image-20210817104539604.png)

## 5.1 算法

```java
public static void mergeSort(int[] arr) {//这个是对外提供的接口
    if (arr == null || arr.length < 2)
        return;
    sort(arr, 0, arr.length - 1);
}

private static void sort(int[] arr, int left, int right) {
    if (left >= right)
        return;
    int mid = left + ((right - left) >> 1);
    sort(arr, left, mid);
    sort(arr, mid + 1, right);
    merge(arr, left, mid, right);
}

private static void merge(int[] arr, int left, int mid, int right) {
    int[] temp = new int[right - left + 1];
    int i = left, j = mid + 1, k = 0;
    while (i <= mid && j <= right)
        temp[k++] = (arr[i] <= arr[j]) ? arr[i++] : arr[j++];
    while (i <= mid)
        temp[k++] = arr[i++];
    while (j <= right)
        temp[k++] = arr[j++];
    for (i = 0; i < k; i++)
        arr[left + i] = temp[i];
}
```

## 5.2 小和问题

```java
public static int mergeSort(int[] arr){
    if(arr==null||arr.length<2)
        return 0;
    return proess(arr,0,arr.length-1);
}
private int process(int[] arr,int l,int r){
    if(l==r)
        return 0;
    int mid=l+((r-l)>>1);
    return 	process(arr,l,mid)+
        	process(arr,mid+1,r)+
        	merge(arr,l,mid,r);
}
private int merge(int[] arr,int l,int mid,int r){
    int[] temp=new int[r-l+1];
    int i=0;
    int j=l,k=mid+1;
    int res=0;
    while(j<=mid&&k<=r){
        res+=arr[j]<arr[k]?(r-k+1)*arr[k]:0;
        temp[i++]=arr[j]<arr[k]?arr[j++]:arr[k++];//注意相等的时候先拷贝右子树
    }
    while(j<=mid)
        temp[i++]=arr[j++];
    while(k<=r)
        temp[i++]=arr[k++];
    for(int i=0;i<help.length;i++){
        arr[l+i]=temp[i];
    }
    return res;
}
```

## 5.3 逆序对

```java
package leetcode.editor.cn;

//在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。 
//
// 
//
// 示例 1: 
//
// 输入: [7,5,6,4]
//输出: 5 
//
// 
//
// 限制： 
//
// 0 <= 数组长度 <= 50000 
// 👍 393 👎 0

public class ShuZuZhongDeNiXuDuiLcof {
    public static void main(String[] args) {
        Solution solution = new ShuZuZhongDeNiXuDuiLcof().new Solution();
        int i = solution.reversePairs(new int[]{7, 5, 6, 4});
        System.out.println(i);
    }

    //leetcode submit region begin(Prohibit modification and deletion)
    class Solution {
        public int reversePairs(int[] nums) {
            if(nums==null||nums.length<2)
                return 0;
            return process(nums,0,nums.length-1);
        }
        private int process(int[] nums,int l,int r){
            if(l==r)
                return 0;
            int mid=l+((r-l)>>1);
            return
                    process(nums,l,mid)+
                    process(nums,mid+1,r)+
                    merge(nums,l,mid,r);
        }

        private int merge(int[] nums, int l, int mid, int r) {
            int[] help=new int[r-l+1];
            int i=0;
            int p1=l,p2=mid+1;
            int res=0;
            while(p1<=mid&&p2<=r){
                res+=nums[p1]>nums[p2]?(r-p2+1):0;//5 3    2 1
                help[i++]=nums[p1]>nums[p2]?nums[p1++]:nums[p2++];
            }
            while (p1<=mid)
                help[i++]=nums[p1++];
            while(p2<=r)
                help[i++]=nums[p2++];
            for(i=0;i<help.length;i++)
                nums[l+i]=help[i];
            return res;
        }
    }
//leetcode submit region end(Prohibit modification and deletion)

}
```



# 6. 快排

## 6.1 荷兰国旗问题

问题一
给定一个数组arr，和一个数num，请把小于等于num的数放在数 组的左边，大于num的
数放在数组的右边。要求额外空间复杂度O(1)，时间复杂度O(N)

> 1. i小于等于num，[i]和≤区的下一个数交换，≤向右扩，i++
> 2. i＞num，i++

---

问题二(荷兰国旗问题)
给定一个数组arr，和一个数num，请把小于num的数放在数组的 左边，等于num的数放
在数组的中间，大于num的数放在数组的 右边。要求额外空间复杂度O(1)，时间复杂度
O(N)

> 1. i小于num，[i]和<区的下一个数交换，<向右扩，i++
> 2. i==num ,i++
> 3. i>num,[i]和>区的前一个元素叫交换，>向左扩，i不动

## 6.2 快排

空间复杂度为O(logN) 如果不改进的话为O(N) 因为递归开了N层

时间复杂度为O(NlogN)

**快排每次都可以确定一些元素存放的下标，那就是值等于nums[pivot]**

![image-20210817164839333](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/image-20210817164839333.png)

```java
public static void quickSort(int[] nums) {
    if (nums == null || nums.length < 2)
        return;
    sort(nums, 0, nums.length - 1);
}

public static void sort(int[] nums, int left, int right) {
    if (left >= right)
        return;
    int pivot = left + (int) (Math.random() * (right - left + 1));
    swap(nums, pivot, right);
    int[] p = partition(nums, left, right);
    sort(nums, left, p[0]);
    sort(nums, p[1], right);
}

public static int[] partition(int[] nums, int left, int right) {
    int less = left - 1;
    int more = right;
    while (left < more) {
        if (nums[left] < nums[right])
            swap(nums, ++less, left++);
        else if (nums[left] > nums[right])
            swap(nums, --more, left);
        else
            left++;
    }
    swap(nums, more++, right);
    return new int[]{less, more};
}
```



# 7. 堆排序

```java
package class02;

import java.util.Arrays;

public class Code03_HeapSort {

    public static void heapSort(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        for (int i = 0; i < arr.length; i++) {
            heapInsert(arr, i);
        }
        int size = arr.length;
        swap(arr, 0, --size);
        while (size > 0) {
            heapify(arr, 0, size);
            swap(arr, 0, --size);
        }
    }
	//上浮
    public static void heapInsert(int[] arr, int index) {
        if(index <=0)
            return 0;
        while (arr[index] > arr[(index - 1) / 2]) {
            swap(arr, index, (index - 1) /2);
            index = (index - 1)/2 ;
        }
    }
	//下c
    public static void heapify(int[] arr, int index, int size) {
        int left = index * 2 + 1;
        while (left < size) {
            //找出左右两个结点中更大的那一个
            int largest = left + 1 < size && arr[left + 1] > arr[left] ? left + 1 : left;
            largest = arr[largest] > arr[index] ? largest : index;
            if (largest == index) {
                break;
            }
            swap(arr, largest, index);
            index = largest;
            left = index * 2 + 1;
        }
    }

    public static void swap(int[] arr, int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
}
```

# 8. 桶排序

1. 优先级高的越后面排
2. 几进制就用几个捅、
3. 桶排序思想下的排序都是不基于比较的排序
4. 时间复杂度为O(N)，额外空间负载度O(M)
5. 应用范围有限，需要样本的数据状况满足桶的划分

```java
package class03;

import java.util.Arrays;

public class Code02_RadixSort {

    // only for no-negative value
    public static void radixSort(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        radixSort(arr, 0, arr.length - 1, maxbits(arr));
    }

    public static int maxbits(int[] arr) {
        int max = Integer.MIN_VALUE;
        for (int i = 0; i < arr.length; i++) {
            max = Math.max(max, arr[i]);
        }
        int res = 0;
        while (max != 0) {
            res++;
            max /= 10;
        }
        return res;
    }

    public static void radixSort(int[] arr, int begin, int end, int digit) {
        final int radix = 10;
        int i = 0, j = 0;

        int[] bucket = new int[end - begin + 1];
        for (int d = 1; d <= digit; d++) {
            int[] count = new int[radix];
            for (i = begin; i <= end; i++) {
                j = getDigit(arr[i], d);
                count[j]++;
            }
            for (i = 1; i < radix; i++) {
                count[i] = count[i] + count[i - 1];
            }
            for (i = end; i >= begin; i--) {//先入桶的先出
                j = getDigit(arr[i], d);
                bucket[count[j] - 1] = arr[i];
                count[j]--;
            }
            for (i = begin, j = 0; i <= end; i++, j++) {
                arr[i] = bucket[j];
            }
        }
    }

    public static int getDigit(int x, int d) {
        return ((x / ((int) Math.pow(10, d - 1))) % 10);
    }
}
```



# 8. 二分

## 8.1 局部最小

arr中的数都是无序的 但是相邻两个数一定不相等。求一个局部最小

步骤

1. 先自己证明一下一定存在局部最小

# 9. 对数器

```java
public class test {
    public static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    // 生成随机数
    public static int[] generateRandomArray(int arrSize, int arrValue) {
        int arr[] = new int[new Random().nextInt(arrSize) + 1];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = ((new Random().nextInt(arrValue) + 1) - (new Random().nextInt(arrValue) + 1));
        }
        return arr;
    }

    public static int[] sorted(int[] arr) {
        Arrays.sort(arr);
        return arr;
    }

    // 数组的拷贝
    public static int[] copyArray(int[] arr) {
        if (arr == null) {
            return null;
        } else {
            int[] temp = new int[arr.length];
            for (int i = 0; i < arr.length; i++) {
                temp[i] = arr[i];
            }
            return temp;
        }
    }

    // 比较值
    public static boolean isEqual(int[] arr1, int[] arr2) {
        if ((arr1 != null && arr2 == null) || (arr2 != null && arr1 == null))
            return false;
        if (arr1 == null && arr2 == null)
            return true;
        if (arr1.length != arr2.length)
            return false;
        for (int i = 0; i < arr1.length; i++) {
            if (arr1[i] != arr2[i])
                return false;
        }
        return true;
    }

    public static void quickSort(int[] nums) {
        if (nums == null || nums.length < 2)
            return;
        sort(nums, 0, nums.length - 1);
    }

    public static void sort(int[] nums, int left, int right) {
        if (left >= right)
            return;
        int pivot = left + (int) (Math.random() * (right - left + 1));
        swap(nums, pivot, right);
        int[] p = partition(nums, left, right);
        sort(nums, left, p[0]);
        sort(nums, p[1], right);
    }

    public static int[] partition(int[] nums, int left, int right) {
        //对[left,right-1]中的元素进行快排，最后形成< = >区间
        int less = left - 1;
        int more = right;
        while (left < more) {
            //小于区间
            if (nums[left] < nums[right])
                swap(nums, ++less, left++);
            //大于区间
            else if (nums[left] > nums[right])
                swap(nums, --more, left);
            //等于区间
            else
                left++;
        }
        swap(nums, more++, right);
        return new int[]{less, more};
    }

    public static void main(String[] args) {
        int testTime = 100;  // 测试次数
        int arrSize = 20;  // 产生10以下的随机数组长度
        int arrValue = 10;  //  产生100以下的随机数组值,值的取值范围[0~100)
        for (int i = 0; i < testTime; i++) {
            int arr1[] = generateRandomArray(arrSize, arrValue);
//            int[] arr1 = new int[]{1, 2, 3, 4, 5, 0};
            int arr2[] = copyArray(arr1);

            sorted(arr1);  // 正确排序
            quickSort(arr2);  // 插入排序
            boolean flag = true;
            if (!isEqual(arr1, arr2)) {
                flag = false;
            }
            System.out.println(flag ? "Right！" : "Error！");
        }

    }

}
```





# 10. master公式

![image-20210416001320773](http://aikaid-img.oss-cn-shanghai.aliyuncs.com/img/image-20210416001320773.png)

# 11. 比较器

1）比较器的实质就是重载比较运算符
2）比较器可以很好的应用在特殊标准的排序上
3）比较器可以很好的应用在根据特殊标准排序的结构上

```java
import java.util.Arrays;
import java.util.Comparator;
import java.util.PriorityQueue;
import java.util.TreeSet;

public class Code03_Comparator {

	public static class Student {
		public String name;
		public int id;
		public int age;

		public Student(String name, int id, int age) {
			this.name = name;
			this.id = id;
			this.age = age;
		}
	}

	public static class IdAscendingComparator implements Comparator<Student> {

		@Override
		public int compare(Student o1, Student o2) {
			return o1.id - o2.id;
		}

	}

	public static class IdDescendingComparator implements Comparator<Student> {

		@Override
		public int compare(Student o1, Student o2) {
			return o2.id - o1.id;
		}

	}

	public static class AgeAscendingComparator implements Comparator<Student> {

		@Override
		public int compare(Student o1, Student o2) {
			return o1.age - o2.age;
		}

	}

	public static class AgeDescendingComparator implements Comparator<Student> {

		@Override
		public int compare(Student o1, Student o2) {
			return o2.age - o1.age;
		}

	}

	public static void printStudents(Student[] students) {
		for (Student student : students) {
			System.out.println("Name : " + student.name + ", Id : " + student.id + ", Age : " + student.age);
		}
	}

	public static void printArray(Integer[] arr) {
		if (arr == null) {
			return;
		}
		for (int i = 0; i < arr.length; i++) {
			System.out.print(arr[i] + " ");
		}
		System.out.println();
	}

	public static class MyComp implements Comparator<Integer> {

		@Override
		public int compare(Integer o1, Integer o2) {
			return o2 - o1;
		}

	}

	public static void main(String[] args) {
		Student student1 = new Student("A", 2, 23);
		Student student2 = new Student("B", 3, 21);
		Student student3 = new Student("C", 1, 22);

		Student[] students = new Student[] { student1, student2, student3 };

		Arrays.sort(students, new IdAscendingComparator());
		printStudents(students);
		System.out.println("===========================");

		Arrays.sort(students, new IdDescendingComparator());
		printStudents(students);
		System.out.println("===========================");

		Arrays.sort(students, new AgeAscendingComparator());
		printStudents(students);
		System.out.println("===========================");

		Arrays.sort(students, new AgeDescendingComparator());
		printStudents(students);
		System.out.println("===========================");
		System.out.println("===========================");
		System.out.println("===========================");
		System.out.println("===========================");

		PriorityQueue<Student> maxHeapBasedAge = new PriorityQueue<>(new AgeDescendingComparator());
		maxHeapBasedAge.add(student1);
		maxHeapBasedAge.add(student2);
		maxHeapBasedAge.add(student3);
		while (!maxHeapBasedAge.isEmpty()) {
			Student student = maxHeapBasedAge.poll();
			System.out.println("Name : " + student.name + ", Id : " + student.id + ", Age : " + student.age);
		}
		System.out.println("===========================");

		PriorityQueue<Student> minHeapBasedId = new PriorityQueue<>(new IdAscendingComparator());
		minHeapBasedId.add(student1);
		minHeapBasedId.add(student2);
		minHeapBasedId.add(student3);
		while (!minHeapBasedId.isEmpty()) {
			Student student = minHeapBasedId.poll();
			System.out.println("Name : " + student.name + ", Id : " + student.id + ", Age : " + student.age);
		}
		System.out.println("===========================");
		System.out.println("===========================");
		System.out.println("===========================");

		TreeSet<Student> treeAgeDescending = new TreeSet<>(new AgeDescendingComparator());
		treeAgeDescending.add(student1);
		treeAgeDescending.add(student2);
		treeAgeDescending.add(student3);

		Student studentFirst = treeAgeDescending.first();
		System.out.println("Name : " + studentFirst.name + ", Id : " + studentFirst.id + ", Age : " + studentFirst.age);

		Student studentLast = treeAgeDescending.last();
		System.out.println("Name : " + studentLast.name + ", Id : " + studentLast.id + ", Age : " + studentLast.age);
		System.out.println("===========================");

	}

}

```

# 12. 拓扑排序